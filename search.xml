<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8. 判断js数据类型的方式</title>
      <link href="/2022/01/18/8-pan-duan-js-shu-ju-lei-xing-de-fang-shi/"/>
      <url>/2022/01/18/8-pan-duan-js-shu-ju-lei-xing-de-fang-shi/</url>
      
        <content type="html"><![CDATA[<p>数据类型分为基本类型和引用类型。</p><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>String, Number, Boolean, Null, Undefined, Symbol</p><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>Object, Array, Date, Function, Error, RegExp, Math, Number, String, Boolean, Globle</p><h5 id="js内置类型"><a href="#js内置类型" class="headerlink" title="js内置类型"></a>js内置类型</h5><p>String, Number, Boolean, Null, Undefined, Symbol, Object</p><h5 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h5><p>typeof、instanceof、constructor、Object.prototype.toString.call()  </p><ul><li><h6 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h6>typeof可以对基本类型（包括function）做出准确的判断，但对于引用类型，用它就有点力不从心了。<br>typeof 返回一个表示数据类型的字符串，返回结果包括：<font color="blue"> number、 </font><font color="blue"> boolean、 </font><font color="blue"> string、 </font><font color="blue"> object、 </font><font color="blue"> undefined、 </font><font color="blue"> function、 </font><font color="blue"> Symbol </font>7种数据类型。</li></ul><p>对于引用类型，返回的都是object，其实返回object也没有错，因为所有对象的原型链最终都指向了Object, Object是所有对象的<code>祖宗</code>。<br>但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了。</p><p><font color="red">注意：typeof null也是返回object</font>  </p><ul><li><h6 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h6><p>判断对象和构造函数在原型链上是否有关系，如果有关系，返回真，否则返回假</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 判断a1和Aaa是否在同一个原型链上，是的话返回真，否则返回假</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a1 <span class="token keyword">instanceof</span> <span class="token class-name">Aaa</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Aaa</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于基本数据类型与引用类型的判断：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bool <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> nul <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nul <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> und <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>und <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> oDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>oDate <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fun <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的运行结果我们可以看到，基本数据类型是没有检测出他们的类型，但是我们使用下面的方式创建num、str、boolean，是可以检测出类型的：  </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'abcdef'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> boolean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boolean <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h6 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h6><p>查看对象对应的构造函数，constructor 在其对应对象的原型下面，是自动生成的。当我们写一个构造函数的时候，程序会自动添加：构造函数名.prototype.constructor = 构造函数名  </p><p>s</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// Aaa.prototype.constructor = Aaa; // 每一个函数都会有的，都是自动生成的</span> <span class="token comment">// Aaa.prototype.constructor = Aaa;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>判断数据类型的方法：  </p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>constructor <span class="token operator">===</span> String<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bool<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Boolean<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> nul <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nul<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 </span><span class="token keyword">const</span> und <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>und<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span><span class="token keyword">const</span> oDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>oDate<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span>constructor <span class="token operator">===</span> RegExp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fun<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的测试中我们可以看到，undefined和null是不能够判断出类型的，并且会报错。因为null和undefined是无效的对象，因此是不会有constructor存在的。<br>同时我们也需要注意到的是：使用constructor是不保险的，因为constructor属性是可以被修改的，会导致检测出的结果不正确。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 程序可以自动添加，当我们写个构造函数的时候，程序会自动添加这句代码</span><span class="token class-name">Aaa</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Aaa<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token constant">BBB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 此时我们就修改Aaa构造函数的指向问题</span><span class="token class-name">Aaa</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token constant">BBB</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Aaa<span class="token punctuation">.</span>construtor <span class="token operator">===</span> Aaa<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，constructor并没有正确检测出正确的构造函数</p><p><font color="red"> 备注：使用Object.create()创建的js对象，没有constructor </font></p><ul><li><h6 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h6>可以说不管是什么类型，它都可以立即判断出。<br>toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object xxx],xxx是具体的数据类型，其中包括：<br>String,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument,… 基本上所有对象的类型都可以通过这个方法获取到。 <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object String]</span><span class="token keyword">const</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//[object Boolean]</span><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Number]</span><span class="token keyword">const</span> nul <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>nul<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Null]</span><span class="token keyword">const</span> und <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>und<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Undefined]</span><span class="token keyword">const</span> oDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>oDate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Date]</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Object]</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Array]</span><span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object RegExp]</span><span class="token keyword">const</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>fun<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Function]</span><span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Error]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>从这个结果也可以看出，不管是什么类型的，Object.prototype.toString.call();都可以判断出其具体的类型。<br>优缺点总结：<br>类型 | 优点 |  缺点  </li><li>|-|-<br>typeof | 使用简单 | 只能检测出基本类型（除了null） |<br>instanceof | 能检测出引用类型 | 不能检测出基本类型，且不能跨iframe  |<br>constructor| 基本能检测所有的类型（除了null和undefined |  constructor易被修改，也不能跨iframe IE6下，undefined和null均为Object |<br>Object.prototype.toString.call | 检测出所有的类型 | / |<br>instanceof和constructor不能跨iframe。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> oF <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span> oF <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> ifArray <span class="token operator">=</span> window<span class="token punctuation">.</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Array<span class="token punctuation">;</span>        <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ifArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> JS变量与类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. js中null与undefined的区别</title>
      <link href="/2022/01/18/7-js-zhong-null-yu-undefined-de-qu-bie/"/>
      <url>/2022/01/18/7-js-zhong-null-yu-undefined-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h5 id="js中null-与-undefined-的区别"><a href="#js中null-与-undefined-的区别" class="headerlink" title="js中null 与 undefined 的区别"></a>js中null 与 undefined 的区别</h5><p>在JavaScript中存在这样两种原始类型:Null与Undefined。<br>Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。<br>Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。  </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> oValue<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>oValue <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true  没有初始化</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">===</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'notExistElement'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当页面上不存在id为”notExistElement”的DOM节点时，这段代码显示为”true”，因为我们尝试获取一个不存在的对象。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined  </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="为什么null的类型是Object？"><a href="#为什么null的类型是Object？" class="headerlink" title="为什么null的类型是Object？"></a>为什么null的类型是Object？</h6><p>其实这是JavaScript最初实现的一个错误，后来被ECMAScript沿用下来。在今天我们可以解释为，null即是一个不存在的对象的占位符，但是在实际编码时还是要注意这一特性。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span> <span class="token comment">// true</span><span class="token keyword">null</span> <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ECMAScript认为undefined是从null派生出来的，所以把它们定义为值相等的，类型不相等。</p>]]></content>
      
      
      <categories>
          
          <category> JS变量与类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. 理解值类型和引用类型</title>
      <link href="/2022/01/14/6-li-jie-zhi-lei-xing-he-yin-yong-lei-xing/"/>
      <url>/2022/01/14/6-li-jie-zhi-lei-xing-he-yin-yong-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>值类型也称基本类型string、number、array也就是除了object以外的类型  </p><p>例一：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'aaaaa'</span>a<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'bar'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为js内部对基本类型a进行a.foo=’bar’操作时，会在内部创建一个对应的包装类型（在上例中也就是一个String类型）的临时对象，对a的操作会有这个基本类型代理，不管是赋值还是调用成员函数（也就是变量a可以使用String的函数，也可以给自己添加属性），操作完后，这个临时对象就释放掉了（给自己添加的属性也一起释放掉了）。下次访问时，会重新创建一个新的临时对象（访问不到释放了的对象中的属性）</p><p>例二：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">a<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'bar'</span>a<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>foo2 <span class="token operator">=</span> <span class="token string">'bar2'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> a<span class="token punctuation">.</span>foo2<span class="token punctuation">)</span> <span class="token comment">// undefined "bar2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对__proto__操作起作用不是因为临时对象没有释放，而是临时对象是String,Sring是函数，函数的__proto__是他构造函数的prototype,跟这个函数创建出来的临时对象没关系了。这个临时对象只是引用了他的构造函数的prototype而已（构造函数的prototype不会因为临时对象被释放而被释放）。而所有同类型的对象的构造函数是同一个。也就是同一个prototype，所以可以修改到更深层。</p><p>例三：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'aaaaa'</span><span class="token keyword">var</span> b <span class="token operator">=</span> ab <span class="token operator">=</span> <span class="token string">'ccccc'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token comment">// aaaaa ccccc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是引用的话，a、b两个值应该一起改变。这是值类型，所以是两个无关的值。</p><p>例四：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span><span class="token string">'aaa'</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> b <span class="token operator">=</span> ab<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'bbbbb'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token comment">// &#123;name: "bbbbb"&#125; &#123;name: "bbbbb"&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>引用类型，一个修改，一起改变</p><p>例五：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'aaaaa'</span><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token string">'aaaaa'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span> <span class="token comment">// true</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'aaaaa'</span><span class="token punctuation">)</span>str <span class="token operator">==</span> str2<span class="token boolean">true</span>str <span class="token operator">===</span> str2<span class="token boolean">false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值一样，但是类型不一样。String,Number,Boolean在JS中是基本类型，基本类型是存储在栈(stack)内存中的,数据大小确定，内存空间大小可以分配。</p><p>而引用类型是存储在堆(heap)内存中的,例如对象, 栈中存在的仅仅是一个堆的指针，这也就是我们日常遇到 a = {num:1}, b=a, b.num1 = 2, 那么a.num1 也为2 的原因。因为a,b同时指向同一个地址。</p><p>前两种方式定义出来的是在栈中并且值相等，而第三种方法定义出来的仅仅是栈中的一个指针。<br>所以这也是为什么 三种方式定义出来的不一样。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 5</span>str<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token string">'world'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment">//undefined</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span>lengh<span class="token punctuation">)</span> <span class="token comment">// 5</span>str1<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token string">'world'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment">//undefined</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span>lengh<span class="token punctuation">)</span> <span class="token comment">// 5</span>str2<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token string">'world'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment">//world</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>indexOf <span class="token operator">===</span> <span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>indexOf<span class="token punctuation">)</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span>indexOf <span class="token operator">===</span> <span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>indexOf<span class="token punctuation">)</span> <span class="token comment">//true</span>str <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// false</span>str1 <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="str-又-不属于String-却拥有-String-的方法"><a href="#str-又-不属于String-却拥有-String-的方法" class="headerlink" title="str 又 不属于String 却拥有 String 的方法?"></a>str 又 不属于String 却拥有 String 的方法?</h6><p>这是JS中的设计。</p><ul><li>原始资料类型的方法与属性是”借”来的</li><li>一个原始的资料类型值，并没有如对象会有属性或方法，</li><li>原始的资料类型在运算时用的属性与方法，是向包装对象”借来”的用的，</li><li>所以原始资料类型是可以向 new String() 或者 new Number()借来所有的方法。但是自己本身却没有属性和方法。</li></ul><p>所以这也就是为什么第一种第二种我们无法去自定义属性却可以使用对应类型的方法的原因。</p>]]></content>
      
      
      <categories>
          
          <category> JS变量与类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. js基本类型的装箱与拆箱</title>
      <link href="/2022/01/12/5-js-ji-ben-lei-xing-de-zhuang-xiang-yu-chai-xiang/"/>
      <url>/2022/01/12/5-js-ji-ben-lei-xing-de-zhuang-xiang-yu-chai-xiang/</url>
      
        <content type="html"><![CDATA[<h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>所谓装箱，就是把基本类型转变为对应的对象。装箱分为隐式和显示。</p><h5 id="隐式装箱"><a href="#隐式装箱" class="headerlink" title="隐式装箱"></a>隐式装箱</h5><p>每当读取一个基本类型的值时，后台会创建一个该基本类型所对应的对象。在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。具体到代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">num<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '123.00'</span><span class="token comment">//上方代码在后台的真正步骤为</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们访问 num 时，要从内存中读取这个数字的值，此时访问过程处于读取模式。在读取模式中，后台进行了三步处理：</p><ul><li>创建一个 Number 类型的实例</li><li>在实例上调用方法</li><li>销毁实例<h5 id="显式装箱"><a href="#显式装箱" class="headerlink" title="显式装箱"></a>显式装箱</h5>通过内置对象 Boolean、Object、String 等可以对基本类型进行显示装箱。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h4>拆箱与装箱相反，把对象转变为基本类型的值。拆箱过程内部调用了抽象操作 ToPrimitive 。该操作接受两个参数，第一个参数是要转变的对象，第二个参数 PreferredType 是对象被期待转成的类型。第二个参数不是必须的，默认该参数为 number，即对象被期待转为数字类型。有些操作如 String(obj) 会传入 PreferredType 参数。有些操作如 obj + “ “ 不会传入 PreferredType。  </li></ul><p>具体转换过程是这样的。默认情况下，ToPrimitive 先检查对象是否有 valueOf 方法，如果有则再检查 valueOf 方法是否有基本类型的返回值。如果没有 valueOf 方法或 valueOf 方法没有返回值，则调用 toString 方法。如果 toString 方法也没有返回值，产生 TypeError 错误。  </p><p>PreferredType 影响 valueOf 与 toString 的调用顺序。如果 PreferrenType 的值为 string。则先调用 toString ,再调用 valueOf。</p><p>具体测试代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"valueOf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"toString"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">String</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// toString</span><span class="token comment">// valueOf</span><span class="token comment">// Uncaught TypeError: Cannot convert object to primitive value</span>obj <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">;</span><span class="token comment">// valueOf</span><span class="token comment">// toString</span><span class="token comment">// Uncaught TypeError: Cannot convert object to primitive value</span><span class="token function">Number</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// valueOf</span><span class="token comment">// toString</span><span class="token comment">// Uncaught TypeError: Cannot convert object to primitive value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JS变量与类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. js中的变量在内存中的具体存储形式</title>
      <link href="/2022/01/11/4-js-zhong-de-bian-liang-zai-nei-cun-zhong-de-ju-ti-cun-chu-xing-shi/"/>
      <url>/2022/01/11/4-js-zhong-de-bian-liang-zai-nei-cun-zhong-de-ju-ti-cun-chu-xing-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h4><p>javascript中的变量分为基本类型和引用类型。  </p><ul><li>基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，按值访问。</li><li>引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，javascript不允许直接访问堆内存中的位置，因此操作对象时，实际上操作的事对象的引用。  <h5 id="结合代码与图理解"><a href="#结合代码与图理解" class="headerlink" title="结合代码与图理解"></a>结合代码与图理解</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token string">"this is string"</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> a3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 变量b存在于栈中，&#123; x: 10 &#125;作为对象存在于堆中</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 变量c存在于栈中，[1, 2, 3]作为对象存在于堆中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="访问堆内存中的引用数据类型"><a href="#访问堆内存中的引用数据类型" class="headerlink" title="访问堆内存中的引用数据类型:"></a>访问堆内存中的引用数据类型:</h5></li><li>访问栈内存，获取该对象的地址引用</li><li>通过地址，从堆内存中获取需要的数据<h5 id="基本类型发生复制行为"><a href="#基本类型发生复制行为" class="headerlink" title="基本类型发生复制行为"></a>基本类型发生复制行为</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值，最后这些变量都是相互独立互不影响的。<h5 id="引用类型发生复制行为"><a href="#引用类型发生复制行为" class="headerlink" title="引用类型发生复制行为"></a>引用类型发生复制行为</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>b<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>引用类型的复制，同样为新的变量b分配一个新的值，保存在栈内存中，不同的是，这个值仅仅是引用类型的一个地址指针</li><li>他们两个指向同一个值，也就是地址指针相同，在堆内存中访问到的具体对象实际上是同一个,因此改变b.x时，a.x也发生了变化，这就是引用类型的特性</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS变量与类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. js Symbol类型在实际开发中的应用</title>
      <link href="/2022/01/07/3-js-symbol-lei-xing-zai-shi-ji-kai-fa-zhong-de-ying-yong/"/>
      <url>/2022/01/07/3-js-symbol-lei-xing-zai-shi-ji-kai-fa-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h4 id="开发应用"><a href="#开发应用" class="headerlink" title="开发应用"></a>开发应用</h4><ul><li><p>Symbol 是一种基本数据类型，由Symbol函数生成</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 无参数情况</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token comment">// Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Symbol(foo)</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c <span class="token operator">===</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token comment">// Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Symbol is not a constructor at new Symbol</span><span class="token comment">// instanceof 的结果为 false</span><span class="token keyword">var</span> aa <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aa <span class="token keyword">instanceof</span> <span class="token class-name">Symbol</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token comment">// 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Symbol(abc)</span><span class="token comment">// Symbol 值不能与其他类型的值进行运算，会报错</span><span class="token keyword">var</span> sym1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'My symbol'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"your symbol is "</span> <span class="token operator">+</span> sym1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Cannot convert a Symbol value to a string</span><span class="token comment">// Symbol 值可以显式转为字符串</span><span class="token keyword">var</span> sym2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'My symbol'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>sym2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Symbol(My symbol)'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Symbol(My symbol)'</span><span class="token comment">// Symbol的唯一性，可以作为标识符，用于对象的属性名</span><span class="token keyword">var</span> symbol1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> symbol2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> symbol3 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 写法一</span><span class="token constant">A</span><span class="token punctuation">[</span>symbol1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>symbol1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span><span class="token comment">// 写法二</span><span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    symbol2<span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>symbol2<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span><span class="token comment">// 写法三</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> symbol3<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>value<span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>symbol3<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font style="color: red">注意：</font> 该属性不会出现在 <font style="color: red"> for…in </font>、<font style="color: red"> for…of </font> 循环中，也不会被<font style="color: blue"> Object.keys() </font>、<font style="color: blue"> Object.getOwnPropertyNames() </font>、<font style="color: blue"> JSON.stringify() </font> 返回。但是，它也不是私有属性，有一个<font style="color: blue"> Object.getOwnPropertySymbols </font>  方法，可以获取指定对象的所有 Symbol 属性名。</p></li><li><p>使用同一个 Symbol 值，可以使用 Symbol.for</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> s1 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token keyword">var</span> s2 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s1 <span class="token operator">===</span> s2<span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> s1 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Symbol<span class="token punctuation">.</span><span class="token function">keyFor</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "foo"</span> <span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Symbol<span class="token punctuation">.</span><span class="token function">keyFor</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用  </p></li></ul><p>当需要区分形状，正方形，圆形，菱形 会使用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> shape <span class="token operator">=</span> <span class="token punctuation">&#123;</span> triangle<span class="token operator">:</span> ‘triangle’<span class="token punctuation">,</span> circle<span class="token operator">:</span> ‘circle’<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不优雅，可以使用:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> shape <span class="token operator">=</span> <span class="token punctuation">&#123;</span> triangle<span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> circle<span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> JS变量与类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. js对象的底层数据结构</title>
      <link href="/2022/01/05/2-js-dui-xiang-de-di-ceng-shu-ju-jie-gou/"/>
      <url>/2022/01/05/2-js-dui-xiang-de-di-ceng-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h4 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h4><p>javascript中的变量分为基本类型和引用类型。  </p><ul><li>基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，按值访问。</li><li>引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，javascript不允许直接访问堆内存中的位置，因此操作对象时，实际上操作的事对象的引用。  <h5 id="结合代码与图理解"><a href="#结合代码与图理解" class="headerlink" title="结合代码与图理解"></a>结合代码与图理解</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token string">"this is string"</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> a3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 变量b存在于栈中，&#123; x: 10 &#125;作为对象存在于堆中</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 变量c存在于栈中，[1, 2, 3]作为对象存在于堆中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="访问堆内存中的引用数据类型"><a href="#访问堆内存中的引用数据类型" class="headerlink" title="访问堆内存中的引用数据类型:"></a>访问堆内存中的引用数据类型:</h5></li><li>访问栈内存，获取该对象的地址引用</li><li>通过地址，从堆内存中获取需要的数据<h5 id="基本类型发生复制行为"><a href="#基本类型发生复制行为" class="headerlink" title="基本类型发生复制行为"></a>基本类型发生复制行为</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值，最后这些变量都是相互独立互不影响的。<h5 id="引用类型发生复制行为"><a href="#引用类型发生复制行为" class="headerlink" title="引用类型发生复制行为"></a>引用类型发生复制行为</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>b<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>引用类型的复制，同样为新的变量b分配一个新的值，保存在栈内存中，不同的是，这个值仅仅是引用类型的一个地址指针</li><li>他们两个指向同一个值，也就是地址指针相同，在堆内存中访问到的具体对象实际上是同一个,因此改变b.x时，a.x也发生了变化，这就是引用类型的特性</li></ul>]]></content>
      
      
      <categories>
          
          <category> JS变量与类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. js语言类型与Symbol,Iteratorl理解</title>
      <link href="/2022/01/04/1-js-yu-yan-lei-xing-yu-symbol-iteratorl-li-jie/"/>
      <url>/2022/01/04/1-js-yu-yan-lei-xing-yu-symbol-iteratorl-li-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="JavaScript规定了几种语言类型？"><a href="#JavaScript规定了几种语言类型？" class="headerlink" title="JavaScript规定了几种语言类型？"></a>JavaScript规定了几种语言类型？</h4><p>七种： 1.Undefined, 2.Null, 3.Boolean, 4.String, 5.Number, 6.Symbol, 7.Object  </p><h5 id="Symbol的概念"><a href="#Symbol的概念" class="headerlink" title="Symbol的概念"></a>Symbol的概念</h5><p>Symbol表示独一无二的值，它是一切非字符串的对象key的集合。<br>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，但是即使描述相同，Symbol值也不相等。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s1 <span class="token operator">===</span> s2 <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为： </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span>o<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> value<span class="token operator">:</span> v<span class="token operator">++</span><span class="token punctuation">,</span> done<span class="token operator">:</span> v <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> v <span class="token keyword">of</span> o<span class="token punctuation">)</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 1 2 3 ... 9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h5><p>Javascript表示集合的数据结构，有数组(Array)、对象(Object)、Map、Set四种。用户可以组合使用，定义自己的数据结构。例如:数组的成员为Map,Map的成员为对象。这样就需要一种统一的机制，来处理不同的数据结构。<br>遍历器(Iterator)就是这样一种机制，它是一种接口，为不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator机制，就可以完成遍历操作。（即依次处理该数据结构的所有成员）。  </p><h5 id="Iterator（遍历器）的作用"><a href="#Iterator（遍历器）的作用" class="headerlink" title="Iterator（遍历器）的作用"></a>Iterator（遍历器）的作用</h5><ul><li>为各种数据结构，提供一个统一的、简便的访问接口</li><li>使得数据结构的成员能够按照某种次序排序</li><li>ES6提供了一种新的遍历命令<font color='red'> for…of </font>循环，Iterator接口主要供<font color='red'> for…of </font>消费  <h5 id="Iterator（遍历器）的遍历过程"><a href="#Iterator（遍历器）的遍历过程" class="headerlink" title="Iterator（遍历器）的遍历过程"></a>Iterator（遍历器）的遍历过程</h5></li><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的<font color='red'> next </font>方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的<font color='red'> next </font>方法，指针将指向数据结构的第二个成员。</li><li>不断调用指针对象的<font color='red'> next </font>方法，直到指针指向数据结构的结束位置。<br>每一次调用数据结构的<font color='red'> next </font>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<font color='red'> value </font>和<font color='red'> done </font>两个属性的对象。其中，<font color='red'> value </font>是当前成员的值，<font color='red'> done </font>是一个布尔值，表示遍历是否结束。（true表示结束，false表示不结束）<br>下面是一个模拟遍历器<font color='red'> next </font>方法返回值的例子:<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">makeIterator</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> nextIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">?</span>        <span class="token punctuation">&#123;</span>value<span class="token operator">:</span> array<span class="token punctuation">[</span>nextIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span> <span class="token operator">:</span>        <span class="token punctuation">&#123;</span>done<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="默认Iterator接口"><a href="#默认Iterator接口" class="headerlink" title="默认Iterator接口"></a>默认Iterator接口</h5>Iterator接口的目的，就是为所有的数据结构，提供一种统一的访问机制，即<font color='red'> for…of </font>循环。当使用<font color='red'> for…of </font>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。<br>一种数据结构只要部署了Iterator接口，就称这种数据结构是可遍历的。(iterable)<br>ES6规定，默认的Iterator接口部署在数据结构的<font color='red'> Symbol.iterator </font>属性，或者说，一个数据结构只要具有<font color='red'> Symbol.iterator </font>属性，就可以认为是可遍历的。<font color='red'> Symbol.iterator </font>就是当前数据结构默认的遍历器生成函数，返回值为一个遍历器。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>            <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>                    value<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                    done<span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。<br>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for…of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性，另外一些数据结构没有（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。<br>原生具备 Iterator 接口的数据结构：  </li><li>Array</li><li>Map </li><li>Set: 类似于数组，只不过其成员值都是唯一的，没有重复的值。</li><li>String</li><li>TypedArray: 一个TypedArray对象描述一个底层的二进制数据缓存区的一个类似数组(array-like)视图。</li><li>函数的 arguments 对象</li><li>NodeList 对象: NodeList 对象是一个节点的集合，是由 Node.childNodes 和 document.querySelectorAll返回的.NodeList不是一个数组，是一个类似数组的对象(Like Array Object).虽然NodeList不是一个数组，但是可以使用forEach()对其进行迭代。还可以使用Array.from()将其转换为实际数组。<br>以数组为例： <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> iter <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: 'a', done: false &#125;</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: 'b', done: false &#125;</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: 'c', done: false &#125;</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: undefined, done: true &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。<br>一个对象如果要具备可被for…of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">RangeIterator</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">start<span class="token punctuation">,</span> stop</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stop <span class="token operator">=</span> stop<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">next</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>done<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> value<span class="token operator">:</span> value<span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>done<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">range</span> <span class="token punctuation">(</span><span class="token parameter">start<span class="token punctuation">,</span> stop</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RangeIterator</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token parameter"><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0, 1, 2</span><span class="token punctuation">&#125;</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;done: false, value: '0'&#125;</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;done: false, value: '1'&#125;</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;done: false, value: '2'&#125;</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;done: true, value: undefined&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>上面代码是一个类部署 Iterator 接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。  </li></ul>]]></content>
      
      
      <categories>
          
          <category> JS变量与类型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-泛型（读自C#从入门到精通 第2版）</title>
      <link href="/2020/05/14/c-xue-xi-bi-ji-fan-xing-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/05/14/c-xue-xi-bi-ji-fan-xing-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="ArrayList类缺陷"><a href="#ArrayList类缺陷" class="headerlink" title="ArrayList类缺陷"></a>ArrayList类缺陷</h4><p>在ArrayList类中，所有的元素类型都为object类型。.NET中的object类是所有类的基类，因此ArrayList类可以接受任何类型的值作为它的元素。使用ArrayList中的元素时，必须强制进行类型转换，将元素转换为合适的类型。如果元素是值类型的值，会引起CLR进行拆箱和装箱的操作，造成一定的性能开销。而且，还必须小心处理类型转换中可能出现的错误。</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型是一种类型占位符，或称为类型参数。我们知道在一个方法中，一个变量的值可以作为参数，但其实这个变量的类型本身也可以作为参数。泛型允许程序员在代码中将变量或参数的类型先用“类型占位符”来代替，在调用的时候再指定这个类型参数是什么。</p><p>在System.Collections.Generic命名空间中包含了多个泛型集合类，List<T>和Dictionary&lt;K,V&gt;是其中常用的两种泛型集合类，在实际应用中有很重要的作用。</p><h5 id="List-lt-T-gt-类"><a href="#List-lt-T-gt-类" class="headerlink" title="List&lt;T&gt;类"></a>List&lt;T&gt;类</h5><p>List类是ArrayList相对应的泛型集合，用法与ArrayList类似，有更好的类型安全性，无需拆、装箱。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法List&lt;T&gt; 集合名 &#x3D; new List&lt;T&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在泛型定义中，泛型类型参数“<T>”是必须指定的，其中的“T”是定义泛型类时的占位符，其并不是一种类型，仅代表某种可能的类型。在定义时“T”会被使用的类型代替。泛型集合List<T>中只能有一个参数类型，“<T>”中的“T”可以对集合中的元素类型进行约束。</p><p><strong>注意：泛型集合必须实例化，实例化时和普通类实例化时相同，必须在后面加上“()”。</strong></p><p>List<T>的添加、删除和检索等方法和ArrayList相似，但是不需要像ArrayList那样装箱和拆箱。<br>用法与ArrayList基本相同，ArrayList示例可查看链接：<a href="https://blog.csdn.net/JeayNeverGiveUp/article/details/105998420">ArrayList类相关方法</a></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; List类部分方法示例List&lt;int&gt; list1 &#x3D; new List&lt;int&gt;();list1.Add(1);list1.Add(2);list1.Insert(2, 3);int[] strs1 &#x3D; &#123; 5, 6 &#125;;list1.AddRange(strs1);int[] strs2 &#x3D; &#123; 4 &#125;;list1.InsertRange(3, strs2);Console.WriteLine(&quot;list1的容量为&#123;0&#125;，数目为&#123;1&#125;&quot;, list1.Capacity, list1.Count); &#x2F;&#x2F; 8 6foreach (var i in list1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 1 2 3 4 5 6Console.WriteLine();list1.Remove(1);foreach (var i in list1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 2 3 4 5 6Console.WriteLine();list1.RemoveAt(3);foreach (var i in list1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 2 3 4 6Console.WriteLine();list1.RemoveRange(1, 2); &#x2F;&#x2F; list1.RemoveRange(index, count)foreach (var i in list1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 2 6Console.WriteLine();Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Dictionary-lt-K-V-gt-类"><a href="#Dictionary-lt-K-V-gt-类" class="headerlink" title="Dictionary&lt;K,V&gt;类"></a>Dictionary&lt;K,V&gt;类</h5><p>在System.Collections.Generic命名空间中，与HashTable相对应的泛型集合是Dictionary&lt;K,V&gt;，其存储数据的方式和哈希表相似，通过键/值来保存元素，并具有泛型的全部特征，编译时检查类型约束，读取时无需进行类型转换。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法Dictionary&lt;K, V&gt; 泛型集合名 &#x3D; new Dicitionary&lt;K, V&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中“K”为占位符，具体定义时用存储键“Key”的数据类型代替，“V”同样也是占位符，用元素的值“Value”的数据类型代替，这样在定义该集合时，就声明了存储元素的键和值的数据类型，保证了类型的安全性。</p><p>Dictionary用法与Hashtable基本相同，Hashtable示例可查看链接：<a href="https://blog.csdn.net/JeayNeverGiveUp/article/details/106056179">ArrayList类相关方法</a></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 部分示例Dictionary&lt;string, string&gt; openWith &#x3D; new Dictionary&lt;string, string&gt;();openWith.Add(&quot;txt&quot;, &quot;test.exe&quot;);openWith.Add(&quot;bmp&quot;, &quot;paint.exe&quot;);foreach(var i in openWith)&#123;    Console.WriteLine(i.Key + &quot;: &quot; + i.Value);&#125;&#x2F;** * txt: test.exe * bmp: paint.exe *&#x2F;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="泛型优点"><a href="#泛型优点" class="headerlink" title="泛型优点"></a>泛型优点</h5><ul><li>性能高。使用泛型不需要进行类型转换，可以避免装箱和拆箱操作，能提高性能</li><li>类型安全。泛型集合对其存储对象进行了类型约束，不是定义时声明的类型，是无法存储到泛型集合中的，从而保证了数据的类型安全</li><li>代码重用。使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。在处理集合类时，如果遇到下列情况，则可考虑使用泛型类<br>1&gt; 如需要对多种类型进行相同的操作处理。<br>2&gt;  如需要处理值类型，使用泛型则可避免装箱/拆箱带来的性能开销。</li><li>使用泛型可以在应用程序编译时发现类型错误，增强程序的健壮性</li><li>减少不必要的重复编码，使代码结构更加清晰</li></ul><p><strong>可以根据需要创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-常用非泛型集合类-Hashtable类（读自C#从入门到精通 第2版）</title>
      <link href="/2020/05/13/c-xue-xi-bi-ji-chang-yong-fei-fan-xing-ji-he-lei-hashtable-lei-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/05/13/c-xue-xi-bi-ji-chang-yong-fei-fan-xing-ji-he-lei-hashtable-lei-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="HashTable类"><a href="#HashTable类" class="headerlink" title="HashTable类"></a>HashTable类</h4><p>HashTable称为哈希表，利用键/值来存储数据。每个元素都是一个键/值对，并且是一一对应的，通过“键”就可以得到“值”。</p><p><strong>常用属性</strong><br>| 属性名称 | 属性说明 |<br>|–|–|<br>| Count | 获取包含在Hashtable中键/值对的数目 |<br>| Keys | 获取包含在Hashtable中所有键的集合 |<br>| Values | 获取包含在Hashtable中所有值得集合 |<br><strong>常用方法</strong><br>| 方法名称 | 方法说明 |<br>|–|–|<br>| Add | 将带有指定键和值得元素添加到Hashtable中 |<br>| Clear | 从Hashtable中移除所有元素 |<br>| Contains | 确认Hashtable是否包含特定键 |<br>| GetEnumberator | 返回IDictionaryEnumberator，可以遍历Hashtable |<br>| Remove | 从Hashtable中移除带有指定键的元素 |<br><strong>常用构造函数声明</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Hashtable ht1 &#x3D; new Hashtable(); &#x2F;&#x2F; 使用所有默认值构建哈希表实例（初始容量为 16，负载因子为 0.75），实际容量为16 * 0.75 &#x3D; 12Hashtable ht2 &#x3D; new Hashtable(20); &#x2F;&#x2F; 指定哈希表的初始容量为20，实际容量为20 * 0.75 &#x3D; 15Hashtable ht3 &#x3D; new Hashtable(20, 0.8f); &#x2F;&#x2F; 初始容量为20个元素，加载因子为0.8,实际容量为10 *0.8 &#x3D; 16Hashtable ht4 &#x3D; new Hashtable(s1); &#x2F;&#x2F; 传入实现了IDicitionary接口的参数创建哈希表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>加载因子：</p><ul><li>加载因子是表示Hsah表中元素的填满的程度。若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但冲突的机会加大了。反之,加载因子越小,填满的元素越少。好处是:冲突的机会减小了,但空间浪费多了</li><li>冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Hashtable openWith &#x3D; new Hashtable();openWith.Add(&quot;bmp&quot;, &quot;paint.exe&quot;);openWith.Add(&quot;did&quot;, &quot;paint.exe&quot;);openWith.Add(&quot;rtf&quot;, &quot;wordpad.exe&quot;);Console.WriteLine(&quot;键&#x3D;\&quot;rtf\&quot;，值&#x3D;&#123;0&#125;&quot;, openWith[&quot;rtf&quot;]); &#x2F;&#x2F; wordpad.exeopenWith[&quot;doc&quot;] &#x3D; &quot;winword.exe&quot;; &#x2F;&#x2F; 如果对不存在的键设置值，则添加新的键值对&#x2F;&#x2F; 通常添加之前用ContainsKey来判断某个键是否存在if(!openWith.ContainsKey(&quot;ht&quot;))&#123;    openWith.Add(&quot;ht&quot;, &quot;ht.exe&quot;);    Console.WriteLine(openWith[&quot;ht&quot;]); &#x2F;&#x2F; ht.exe&#125;&#x2F;&#x2F; 遍历foreach(DictionaryEntry de in openWith) &#x2F;&#x2F; Hashtable的键&#x2F;值是DicitionaryEntry类型&#123;    Console.WriteLine(&quot;键 &#x3D; &#123;0&#125;，值 &#x3D; &#123;1&#125;&quot;, de.Key, de.Value);&#125;&#x2F;** * 键 &#x3D; ht，值 &#x3D; ht.exe * 键 &#x3D; rtf，值 &#x3D; wordpad.exe * 键 &#x3D; bmp，值 &#x3D; paint.exe * 键 &#x3D; did，值 &#x3D; paint.exe * 键 &#x3D; doc，值 &#x3D; winword.exe *&#x2F;&#x2F;&#x2F; 删除openWith.Remove(&quot;doc&quot;);if (!openWith.ContainsKey(&quot;doc&quot;))    Console.WriteLine(&quot;false&quot;); &#x2F;&#x2F; falseConsole.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>遍历时应注意，Hashtable的每个元素都是一个键/值对，因此元素类型既不是键的类型，也不是值的类型，而是DictionaryEntry类型。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>int.Parse与int.TryParse的区别</title>
      <link href="/2020/05/13/int-parse-yu-int-tryparse-de-qu-bie/"/>
      <url>/2020/05/13/int-parse-yu-int-tryparse-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><strong>Convert.ToInt32<br>int.Parse（Int32.Parse）<br>int.TryParse<br>(int)</strong><br>四者都可以解释为将类型转换为 int，那它们的区别是什么呢？</p><p>Convert.ToInt32 与 int.Parse 较为类似，实际上 Convert.ToInt32 内部调用了 int.Parse：</p><ul><li>Convert.ToInt32 参数为 null 时，返回 0；</li><li>int.Parse 参数为 null 时，抛出异常。  </li><li>Convert.ToInt32 参数为 “” 时，抛出异常；</li><li>int.Parse 参数为 “” 时，抛出异常。 </li><li>Convert.ToInt32 可以转换的类型较多；</li><li>int.Parse 只能转换数字类型的字符串。<br>int.TryParse 与 int.Parse 又较为类似，但它不会产生异常，转换成功返回 true，转换失败返回 false。最后一个参数为输出值，如果转换失败，输出值为 0。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int m; if(int.TryParse(&quot;2&quot;),out m)&#123;...&#125;&#x2F;&#x2F; 返回true ,运行&#123;&#125;内，并给m赋值为2； if(int.TryParse(&quot;ddd&quot;),out m)&#123;...&#125;&#x2F;&#x2F; 返回false,不运行if&#123;&#125;内，并给m赋值为0；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>-常用非泛型集合类-ArrayList类</title>
      <link href="/2020/05/11/c-xue-xi-bi-ji-chang-yong-fei-fan-xing-ji-he-lei-arraylist-lei-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/05/11/c-xue-xi-bi-ji-chang-yong-fei-fan-xing-ji-he-lei-arraylist-lei-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<p>ArrayList是System.Collections命名空间中的非泛型集合类，类似于数组，有人称其为动态数组，其容量可以根据需要自动扩充，元素的索引也可根据元素数量重新分配，可以动态实现元素的添加、删除等操作。</p><p>可以将ArrayList类理解为Array的优化版本，该类既有数组的特征，又有集合的特性，例如，既可以通过下标进行元素访问，对元素进行排序、搜索，又可以像处理集合一样添加，在指定索引处插入及删除元素。</p><p><strong>常用属性</strong></p><ul><li>Capacity： 获取或设置ArrayList可包含的元素数，默认为4</li><li>Count: 获取ArrayList中实际包含的元素数</li><li>Item: 获取或设置指定索引处的元素</li></ul><p><strong>常用方法</strong></p><ul><li>Add(): 将元素添加到ArrayList的结尾处</li><li>AddRange(): 在ArrayList的末尾增加一定范围内的元素</li><li>Clear(): 清除ArrayList中的所有元素</li><li>Contains(): 检查某元素是否在ArrayList中</li><li>IndexOf: 返回ArrayList中某个元素值得第一个匹配项对应的索引</li><li>Insert(): 将元素插入ArrayList的指定索引处</li><li>Remove(): 从ArrayList移除特定元素的第一个匹配项</li><li>Reverse(): 将ArrayList或它的一部分中的元素的顺序反转</li><li>Sort(): 对ArrayList或它的一部分中的元素进行排序</li></ul><p><em><strong>由于ArrayList中元素的类型默认为object，因此在获取集合元素时需要强制进行类型转换。并且由于object是引用类型，在与值类型进行转换时会引起装箱和拆箱的操作，因此需要付出一些性能代价。</strong></em></p><p><strong>为了实现上面的例子，必须在using区添加System.Collections命名空间。</strong></p><h5 id="创建ArrayList"><a href="#创建ArrayList" class="headerlink" title="创建ArrayList"></a>创建ArrayList</h5><p>ArrayList的四种创建方式：</p><ol><li>使用默认的初始容量创建ArrayList，该实例没有任何元素<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList al1 &#x3D; new ArrayList();al1.Add(&quot;hello&quot;);al1.Add(&quot;C#&quot;);al1.Add(&quot;world!&quot;);Console.WriteLine(&quot;al1中容量是&#123;0&#125;, 个数是&#123;1&#125;&quot;, al1.Capacity, al1.Count); &#x2F;&#x2F; 4 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>使用实现了ICollection接口的集合类来初始化新创建的ArrayList,该实例与参数中的集合具有相同的初始容量<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList al2 &#x3D; new ArrayList(al1);Console.WriteLine(&quot;al2容量是&#123;0&#125;, 个数是&#123;1&#125;&quot;,al2.Capacity, al2.Count); &#x2F;&#x2F; 3 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>经由一个整数数值来初始化ArrayList的容量<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList al3 &#x3D; new ArrayList(18);Console.WriteLine(&quot;al3的容量是：&#123;0&#125;, 元素个数是&#123;1&#125;&quot;, al3.Capacity, al3.Count); &#x2F;&#x2F; 18 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>将指定abc字符串重复n次构造数组，以下以三次示例<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList al4 &#x3D; ArrayList.Repeat(&quot;abc&quot;, 3);Console.WriteLine(&quot;al4的容量是：&#123;0&#125;，元素个数是&#123;1&#125;&quot;, al4.Capacity, al4.Count); &#x2F;&#x2F; 4 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="向ArrayList中添加元素的方法"><a href="#向ArrayList中添加元素的方法" class="headerlink" title="向ArrayList中添加元素的方法"></a>向ArrayList中添加元素的方法</h4></li></ol><ul><li>Add方法可以将单个元素添加到列表的尾部；AddRange方法可以获取一个实现ICollection接口的集合实例，例如，Array、Queue、Stack等，并将这个集合实例按顺序添加到列表的尾部。</li><li>使用Insert和InsertRange方法向ArrayList中指定的位置插入元素。Insert方法用于添加单个元素到指定的索引位置，InsertRange从指定的位置开始添加一个实现了ICollection接口的实例。</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList a1 &#x3D; new ArrayList(20);a1.Add(&quot;我是元素1&quot;);a1.Add(&quot;我是元素2&quot;);string[] strs &#x3D; &#123; &quot;我是元素3&quot;, &quot;我是元素4&quot; &#125;;a1.AddRange(strs);a1.Insert(0, &quot;新增第1个元素&quot;);ArrayList a2 &#x3D; new ArrayList();a2.Add(&quot;我是新增元素1&quot;);a2.Add(&quot;我是新增元素2&quot;);a1.InsertRange(2, a2);foreach(var i in a1)&#123;    Console.WriteLine(i);&#125;&#x2F;** * 新增第1个元素 * 我是元素1 * 我是新增元素1 * 我是新增元素2 * 我是元素2 * 我是元素3 * 我是元素4 *&#x2F;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除ArrayList中的元素"><a href="#删除ArrayList中的元素" class="headerlink" title="删除ArrayList中的元素"></a>删除ArrayList中的元素</h4><p>ArrayList提供了Remove、RemoveAt和RemoveRange3种方法将指定元素从集合中移除。</p><ul><li>Remove方法接受一个object类型的参数，用于移除指定元素值的第一个匹配集合元素</li><li>RemoveAt方法接受一个int类型的参数，用于删除指定索引的集合元素</li><li>RemoveRange方法从集合中移除一定范围的元素</li></ul><p>Clear方法可移除所有的元素</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList a1 &#x3D; new ArrayList(20);int[] strs &#x3D; &#123; 0, 1, 2, 3, 4&#125;;a1.AddRange(strs);foreach(var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 01234&#125;Console.WriteLine();a1.Remove(0);foreach(var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 1234&#125;Console.WriteLine();a1.RemoveAt(1);foreach(var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 134&#125;Console.WriteLine();a1.RemoveRange(1, 2); &#x2F;&#x2F; a1.RemoveRange(index, count)foreach(var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 1&#125;Console.WriteLine();a1.Clear();foreach (var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 空 &#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>使用Sort方法对ArrayList集合中的元素进行排序。Sort有3种重载方法。</p><ul><li>使用集合元素的比较方式进行排序。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public virtual void Sort();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用自定义比较器进行排序<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public virtual void Sort(IComparer comparer);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用自定义比较器进行指定范围的排序<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public virtual void Sort(int index, int count, Icomparer comparer);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>示例：<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList a1 &#x3D; new ArrayList();a1.AddRange(new string[5] &#123; &quot;Array1&quot;, &quot;Array2&quot;, &quot;Array5&quot;, &quot;Array3&quot;, &quot;Array&quot; &#125;);foreach (var i in a1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; Array1 Array2 Array5 Array3 ArrayConsole.WriteLine();a1.Sort();foreach (var i in a1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; Array Array1 Array2 Array3 Array5Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找ArrayList中的集合元素"><a href="#查找ArrayList中的集合元素" class="headerlink" title="查找ArrayList中的集合元素"></a>查找ArrayList中的集合元素</h4></li><li>IndexOf: 从前向后搜索指定的字符串，如果找到，则返回匹配的第1项的自0开始的索引，否则返回-1</li><li>LastIndexOf: 从后向前搜索指定的字符串，如果找到，则返回匹配的最后一项的自0开始的索引，否则返回-1</li><li>BinarySearch: 使用二分算法从集合中搜索指定的值，并返回找到的从0开始的索引，否则返回-1</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[] nums &#x3D; &#123; 1, 2, 3, 4, 5, 4 &#125;;ArrayList a1 &#x3D; new ArrayList(nums);int i &#x3D; a1.IndexOf(3);Console.WriteLine(i); &#x2F;&#x2F; 2int j &#x3D; a1.LastIndexOf(4);Console.WriteLine(j); &#x2F;&#x2F; 5int k &#x3D; a1.BinarySearch(4);int m &#x3D; a1.BinarySearch(0);Console.WriteLine(k); &#x2F;&#x2F; 3Console.WriteLine(m); &#x2F;&#x2F; -1Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型List"><a href="#泛型List" class="headerlink" title="泛型List"></a>泛型List</h4><p>因为ArrayList存在不安全类型与装箱拆箱的缺点，所以在C#2.0后出现了泛型的概念。而List类是ArrayList类的泛型等效类。它的大部分用法都与ArrayList相似，因为List类也继承了IList接口。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">List&lt;int&gt; list &#x3D; new List&lt;int&gt;();&#x2F;&#x2F;新增数据list.Add(1);list.Add(3);&#x2F;&#x2F; list.Add(&quot;1&quot;) &#x2F;&#x2F; 报错，只能为int型，不能为stringforeach (var i in list)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 1 3Console.WriteLine();&#x2F;&#x2F;修改数据list[0] &#x3D; 2;foreach (var i in list)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 2 3Console.WriteLine();&#x2F;&#x2F;移除数据list.RemoveAt(0);foreach (var i in list)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 3Console.WriteLine();Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-匿名方法与lambda表达式（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/20/c-xue-xi-bi-ji-ni-ming-fang-fa-yu-lambda-biao-da-shi-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/20/c-xue-xi-bi-ji-ni-ming-fang-fa-yu-lambda-biao-da-shi-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h4><p>要将代码块传递为委托参数，创建匿名方法则是唯一的方法。匿名方法就是为了将代码块传递为委托参数，因此也有人将其称为匿名委托。使用C#的匿名方法可以使委托及事件的代码编写更加精简、高效。一般情况下，事件注册事件处理方法，需要首先定义这个方法，如果该方法仅用于订阅特定的事件，则可使用代码更加简明的匿名方法。<br><strong>示例</strong><br>委托与事件中的烧水示例，Heater类不变，去掉Alarm类和Display类，使用匿名方法订阅事件修改Main方法中的代码。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Heater heater &#x3D; new Heater();heater.BoilEvent +&#x3D; delegate (int param) &#x2F;&#x2F;水快开时报警的匿名方法&#123;    Console.WriteLine(&quot;Alarm: 嘀嘀嘀，水已经&#123;0&#125;度了！&quot;, param);&#125;;heater.BoilEvent +&#x3D; delegate (int param) &#x2F;&#x2F; 表示水温的匿名方法&#123;    Console.WriteLine(&quot;Display: 水快烧开了，当前温度：&#123;0&#125;度！&quot;, param);&#125;;heater.BoilWater();Console.ReadKey();&#x2F;*** Alarm: 嘀嘀嘀，水已经97度了!* Display：水快烧开了，当前温度：97度。* Alarm: 嘀嘀嘀，水已经98度了!* Display：水快烧开了，当前温度：98度。* Alarm: 嘀嘀嘀，水已经99度了!* Display：水快烧开了，当前温度：99度。* Alarm: 嘀嘀嘀，水已经100度了!* Display：水快烧开了，当前温度：100度。*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>lambda表达式是一种可用于创建委托或表达式目录树类型的匿名函数。通过使用lambda表达式，可以写入可作为参数传递或作为函数调用值返回的本地函数。lambda表达式对于编写LINQ查询表达式特别有用。若要创建lambda表达式，需要在lambda运算符 =&gt; 左侧指定输入参数（如果有），然后在另一侧输入表达式或语句块。<br><strong>联想理解：类似于ES6的箭头函数</strong><br>示例：使用lambda表达式实现委托，进行数组排序。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Linq.Expressions;namespace LambdaTest&#123;    class Program    &#123;        public delegate bool SortDelegate(int[] x); &#x2F;&#x2F; 定义委托SortDelegate        static void Main(string[] args)        &#123;            int[] arr &#x3D; new int[] &#123; 8, 9, 2, 1, 4, 3 &#125;;            Console.WriteLine(&quot;排序前的数组：&quot;);            foreach (int i in arr) Console.Write(i); &#x2F;&#x2F; 892143            Console.WriteLine();            &#x2F;&#x2F; 用lamdba表达式实例化委托            SortDelegate myDelegate &#x3D; array &#x3D;&gt;            &#123;                for (int i &#x3D; array.GetUpperBound(0); i &gt;&#x3D; 0; i--)                &#123;                    &#x2F;&#x2F; 冒泡排序                    for (int j &#x3D; 0; j &lt;&#x3D; i; j++)                    &#123;                        if (array[j] &lt;&#x3D; array[i])                        &#123;                            int temp &#x3D; array[j];                            array[j] &#x3D; array[i];                            array[i] &#x3D; temp;                        &#125;                    &#125;                &#125;                return true;            &#125;;            myDelegate(arr);            Console.WriteLine(&quot;排序后的数组：&quot;);            foreach(int i in arr) Console.Write(i); &#x2F;&#x2F; 984321            Console.ReadKey();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记--委托与事件（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/16/c-xue-xi-bi-ji-wei-tuo-yu-shi-jian-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/16/c-xue-xi-bi-ji-wei-tuo-yu-shi-jian-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>委托也叫代理，即把事情交给别人代办。C#中如果将一个方法委托给一个对象，对象即可全权代理该方法的执行。使用委托时首先要定义委托，声明委托所能代理方法的类型。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法&lt;访问修饰符&gt; delegate 返回类型 委托名();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>委托没有具体的实现体，委托能够代表什么样的方法由它的返回值类型和参数列表决定。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 示例public delegate void testDelegate(string name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义了上述委托示例之后要使用委托，首先要实例化委托，也就是将其指向某个方法，即调用委托的构造函数，并将相关联的方法作为参数传递。然后通过调用    委托，执行相关方法的代码，实现委托。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 使用委托对数组进行降序排列using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace DelegateSort&#123;    class Program    &#123;        public delegate bool SortDelegate(int[] x); &#x2F;&#x2F; 定义委托SortDelegate        static void Main(string[] args)        &#123;            int[] arr &#x3D; new int[] &#123; 8, 9, 5, 3, 4, 6, 1 &#125;;            Console.WriteLine(&quot;排序前的数组是： &quot;);            foreach (int i in arr) Console.Write(&quot;&#123;0&#125;&quot;, i); &#x2F;&#x2F; 8953461            SortDelegate myDelegate; &#x2F;&#x2F; 声明委托变量            myDelegate &#x3D; new SortDelegate(Test.SortArray); &#x2F;&#x2F; 实例化委托变量，委托Test的SortArray            myDelegate(arr); &#x2F;&#x2F; 传递参数，调用委托排序            Console.WriteLine(&quot;&quot;);            Console.WriteLine(&quot;排序后的数组是：&quot;);            foreach (int i in arr) Console.Write(&quot;&#123;0&#125;&quot;, i); &#x2F;&#x2F; 9865431            Console.ReadKey();        &#125;    &#125;    class Test    &#123;        public static bool SortArray(int[] array )        &#123;            &#x2F;&#x2F; 定义方法SortArray用于按照降序排序            &#x2F;&#x2F; GetUpperBound(int dimension): 获取数组中指定维度最后一个元素的索引。 dimension Int32 数组的从零开始的维度，其上限需要确定。            for (int i &#x3D; array.GetUpperBound(0); i &gt;&#x3D; 0; i--) &#x2F;&#x2F; 循环从后向前取出数组的元素            &#123;                &#x2F;&#x2F; 冒泡排序，将数值小的元素移到后面，直到所有的元素按照降序排列                for(int j &#x3D; 0; j &lt;&#x3D; i; j++)                &#123;                    if(array[j] &lt;&#x3D; array[i]) &#x2F;&#x2F; 判断数组前面的值是否小于后面的值                    &#123;                        Swap(ref array[j], ref array[i]); &#x2F;&#x2F; 交换二者的位置                    &#125;                &#125;            &#125;            return true; &#x2F;&#x2F; 并非所有代码都有返回值，故加return true        &#125;        static void Swap(ref int x, ref int y) &#x2F;&#x2F; 交换方法        &#123;            int temp &#x3D; y;            y &#x3D; x;            x &#x3D; temp;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件是C#中的一个高级概念，是操作发生时允许执行特定应用程序的代码的机制。事件要么在相关联的操作发生前发生（事前事件），要么在操作发生后发生（事后事件）。例如，当用户单击窗口中的按钮时，将引发一个事后事件，以允许执行特定于应用程序的方法。</p><p>类或对象可以通过事件向其他类或对象通知发生的相关事情。发送（或引发）事件的类称为“发行者”，接收（或处理）事件的类称为“订户”。在典型的C# Windows窗体或Web应用程序中，可以订阅由控件（如按钮和列表框）引发的事件。</p><p>定义和使用事件的步骤：<br>(1) 在一个类中声明关于事件的委托。</p><pre class="line-numbers language-none"><code class="language-none">public delegate void 事件类型名称(object serder, EventArgs e); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>事件类型名称建议用EventHandler结尾。如果想自定义事件的参数EventArgs，可以用EventArgs类派生自己的事件参数类，也可以没有参数。<br>(2)在类中声明事件，使用步骤(1)的delegate作为事件的类型。 </p><pre class="line-numbers language-none"><code class="language-none">public event 事件类型名称 事件名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3)在类中需要引发事件的方法中，编写引发事件的方法。</p><pre class="line-numbers language-none"><code class="language-none">事件名称(this, new EventArgs());&#x2F;&#x2F; 或者if(事件名称 !&#x3D; null) 事件名称 (this, new EventArgs());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(4)订阅事件，当事件发生时通知订户。</p><pre class="line-numbers language-none"><code class="language-none">带有事件的类实例.事件名称 +&#x3D; new 事件名称(事件处理方法名称);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(5)编写事件处理方法。</p><pre class="line-numbers language-none"><code class="language-none">public void 事件处理方法(object sender, EventArgs e)&#123;&#x2F;&#x2F; 相关代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>(6)在适当的条件下触发事件，即需要调用步骤(3)中的引发事件的方法。</p><p><strong>事件的定义和使用示例</strong><br>假设设计一个高档热水器，通电加热到水温超过96℃的时候，扬声器会发出语音告诉你水的温度，液晶屏显示水温的变化，提示水快烧开了。定义一个类来代表热水器的类Heater，它有代表水温的字段temperature，有给水加热的BoilWater()方法，发出语音警报的MakeAlert()方法，显示水温的ShowMsg()方法。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace HeaterEvent&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Heater heater &#x3D; new Heater(); &#x2F;&#x2F; 创建热水器对象heater            Alarm alarm &#x3D; new Alarm(); &#x2F;&#x2F; 创建报警器对象alarm            heater.BoilEvent +&#x3D; alarm.MakeAlert; &#x2F;&#x2F; 给alarm的MakeAlert方法订阅事件            heater.BoilEvent +&#x3D; Display.ShowMsg; &#x2F;&#x2F; 订阅静态方法            heater.BoilWater(); &#x2F;&#x2F; 烧水，会自动调用订阅过的对象方法            Console.ReadKey();            &#x2F;**             * Alarm: 嘀嘀嘀，水已经97度了!             * Display：水快烧开了，当前温度：97度。             * Alarm: 嘀嘀嘀，水已经98度了!             * Display：水快烧开了，当前温度：98度。             * Alarm: 嘀嘀嘀，水已经99度了!             * Display：水快烧开了，当前温度：99度。             * Alarm: 嘀嘀嘀，水已经100度了!             * Display：水快烧开了，当前温度：100度。             *&#x2F;        &#125;    &#125;    public class Heater &#x2F;&#x2F; 热水器类Heater    &#123;        private int temperature; &#x2F;&#x2F; 声明表示水温的字段        public delegate void BoilHandler(int param); &#x2F;&#x2F; 声明关于事件的委托        public event BoilHandler BoilEvent; &#x2F;&#x2F; 声明水要烧开的事件        public void BoilWater() &#x2F;&#x2F; 烧水的方法        &#123;            for(int i &#x3D; 0; i &lt;&#x3D; 100; i++) &#x2F;&#x2F; 循环表示水温的变化            &#123;                temperature &#x3D; i; &#x2F;&#x2F; 设置水的温度                if(temperature &gt; 96) &#x2F;&#x2F; 水温超过96度，引发事件BoilEvent                &#123;                    &#x2F;*if(BoilEvent !&#x3D; null)                    &#123;                        &#x2F;&#x2F; 如果有对象订阅                        BoilEvent(temperature); &#x2F;&#x2F; 调用所有订阅对象的方法                    &#125;*&#x2F;                    &#x2F;&#x2F; 优化                    BoilEvent?.Invoke(temperature); &#x2F;&#x2F; 如果有对象订阅，调用所有订阅对象的方法                &#125;            &#125;        &#125;    &#125;    public class Alarm &#x2F;&#x2F; 定义报警类    &#123;        public void MakeAlert(int param) &#x2F;&#x2F; 水快开时报警的方法        &#123;            Console.WriteLine(&quot;Alarm: 嘀嘀嘀，水已经&#123;0&#125;度了!&quot;, param);        &#125;    &#125;    public class Display &#x2F;&#x2F; 显示水温的显示类    &#123;        &#x2F;&#x2F; 静态方法 ShowMsg用于显示水温        public static void ShowMsg(int param)        &#123;            Console.WriteLine(&quot;Display：水快烧开了，当前温度：&#123;0&#125;度。&quot;, param);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记--抽象类与密封类（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/15/c-xue-xi-bi-ji-chou-xiang-lei-yu-mi-feng-lei-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/15/c-xue-xi-bi-ji-chou-xiang-lei-yu-mi-feng-lei-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<p><strong>继承是面向对象设计理论的基石，抽象理论和方法是继承理论的顶梁柱。</strong></p><h4 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h4><p>用来描述共性的类叫做抽象类，抽象类中不考虑具体实现，只确定必须具有的行为，即确定抽象方法。</p><p>如教师的任务是教学，具体教什么，如何教，每个教师都有自己独特的一面，对教学这个动作就可以提取出来作为抽象方法，而不考虑具体实现内容。</p><p>包含抽象方法的类就是抽象类，抽象类和抽象方法声明使用<strong>abstract</strong>关键字。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法&lt;访问修饰符&gt; abstract class 抽象类名&#123;&#x2F;&#x2F; 类体&lt;访问修饰符&gt; abstract 返回类型方法(); &#x2F;&#x2F; 抽象方法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 示例public abstract class Test&#123;public abstract void Display(); &#x2F;&#x2F; 抽象方法 --&gt; Display()后面不能加 &#123;&#125;, 声明了abstract无法声明主体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现抽象方法"><a href="#实现抽象方法" class="headerlink" title="实现抽象方法"></a>实现抽象方法</h4><p><strong>C#中通过方法重写来实现抽象方法。</strong></p><ul><li>当一个抽象基类派生一个派生类时，派生类将继承基类的所有特征，重新实现所有的抽象方法。</li><li>在派生类中实现基类的抽象方法，是使用override关键字来重写基类方法。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace AbstractTest&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Manager objManager &#x3D; new Manager(&quot;jay&quot;);            objManager.Display(); &#x2F;&#x2F; name: jay            Console.ReadKey();        &#125;    &#125;    public abstract class Employee &#x2F;&#x2F; 声明抽象类    &#123;        public abstract void Display(); &#x2F;&#x2F; 抽象方法Display()    &#125;    public class Manager: Employee &#x2F;&#x2F; 创建抽象类Employee的派生类Manager类    &#123;        private string name;        public Manager(string name) &#x2F;&#x2F; 构造函数实现name初始化        &#123;            this.name &#x3D; name;        &#125;        public override void Display() &#x2F;&#x2F; 重写基类Employee中的抽象方法Display()        &#123;            Console.WriteLine(&quot;name: &quot; + name);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接口、类和抽象类"><a href="#接口、类和抽象类" class="headerlink" title="接口、类和抽象类"></a>接口、类和抽象类</h4>一个类可以同时继承类和接口，或者抽象类和接口，抽象类和类不能在一个类的继承列表中同时出现。</li></ul><p>如果派生类同时继承类或抽象类和接口，一定要把类或者抽象类写在前面，接口写在后面，类名和接口名之间用“,”隔开，接口没有先后顺序。每一种继承都要根据各自的规则去实现。</p><h6 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h6><ul><li>抽象类是一个不完全的类，需要通过派生类完善</li><li>接口只是对类的约束，它仅仅承诺了类能够调用的方法</li><li>一个类一次可以实现若干个接口，但一个类只能继承一个基类</li><li>抽象类只需派生类实现它的抽象方法，接口要求必须实现它的所有成员</li><li>在实际编程中，接口的使用要比抽象类广泛得多</li></ul><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>与抽象类相反的是，C#支持创建密封类，密封类是不能当做基类的类。其他的类不能从此类派生，从而保证了密封类的密封性和安全性。在C#中使用<strong>sealed</strong>关键字创建密封类。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 示例public sealed class Animal &#x2F;&#x2F; 创建密封类&#123;public Animal() &#x2F;&#x2F; 创建构造函数&#123;&#x2F;&#x2F; 函数主体Console.WriteLine(&quot;Animal被构造&quot;)&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当从Animal派生派生类时，编译器会提示出现错误。设计类的时候，通常情况下是不需要将类设置为密封类的，因为密封类会让类的扩展性非常差，这个类也无法再次扩展和派生。但是出于某种目的，当程序块只需要完成某些特定的功能或者在商业上为了保密，就可以使用密封类对类进行密封，以保证类的可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记--接口（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/14/c-xue-xi-bi-ji-jie-kou-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/14/c-xue-xi-bi-ji-jie-kou-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="统一的标准-接口"><a href="#统一的标准-接口" class="headerlink" title="统一的标准-接口"></a>统一的标准-接口</h4><p>接口是面向对象编程的一个重要技术，在C#中负责实现多重继承。一个接口定义一个协定，实现接口的类或结构必须遵守其协定。</p><h5 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h5><ul><li>接口用来描述一种程序的规定，可定义属于任何类或结构的一组相关行为。</li><li>接口可由方法、属性、事件、索引器或这4种成员类型的任何组合构成。</li><li>接口不能包含常数、字段、运算符、实例构造函数、析构函数或类型，也不能包含任何种类的静态成员。</li><li>接口成员一定是公共的。</li><li>接口不能包含其所定义的成员的任何实现语句，接口只指定实现该接口的类或必须提供的成员。<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法：&lt;访问修饰符&gt; interface 接口名&#123;&#x2F;&#x2F;接口主体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h5>定义了接口后，就要在类或结构中实现。C#中通常把派生类和基类的关系称为继承，类和接口的关系称为实现。</li></ul><p>实现接口的语法和继承类一样，都有“：”，接口中的方法在类中实现时不是重载，不需要使用override关键字。</p><p><strong>示例： 声明接口IPoint描述一个点的坐标并实现该接口。</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; IPoint.csusing System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace interfaceTest&#123;    interface IPoint    &#123;        &#x2F;&#x2F; 定义属性成员x，它含有读&#x2F;写抽象访问        int x &#123; get; set; &#125;        &#x2F;&#x2F; 定义属性成员y，它含有读&#x2F;写抽象访问        int y &#123; get; set; &#125;        &#x2F;**         * 对接口名称建议以“I”开头，如Ipoint；         * 对接口的访问修饰符可以选择使用，但是接口的方法前面不能添加任何访问修饰符，它是隐式公开的；         * 接口不能包含构造函数，接口不能实现任何方法、属性和索引器。         *&#x2F;    &#125;    &#x2F;&#x2F; 从接口IPoint派生一个新类，这个类用来实现Point接口成员    class Point: IPoint    &#123;        &#x2F;&#x2F; 定义两个类内部访问的私有成员变量        private int px;        private int py;        &#x2F;&#x2F; 构造函数实现类的私有化，为私有变量赋值        public Point(int x, int y)        &#123;            px &#x3D; x;            py &#x3D; y;        &#125;        &#x2F;&#x2F; 接口属性实现        public int x        &#123;            get &#123; return px; &#125; &#x2F;&#x2F; 实现读访写            set &#123; px &#x3D; value; &#125; &#x2F;&#x2F; 实现写访问        &#125;        public int y        &#123;            get &#123; return py; &#125; &#x2F;&#x2F; 实现读访写            set &#123; py &#x3D; value; &#125; &#x2F;&#x2F; 实现写访问        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>IPoint接口内部声明了两个属性成员x和y，x和y一起组成了一个点的坐标。属性成员x和y包含抽象的读/写访问，分别表示属性成员可以对坐标进行读和写。<br>定义类Point来实现IPoint接口，它包含了对接口成员的具体实现。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Program.csusing System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace interfaceTest&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Point p &#x3D; new Point(5, 30); &#x2F;&#x2F; 应用接口的派生类Point实例化一个新的对象并进行初始化赋值            Console.WriteLine(&quot;新创建的Point点的坐标是：&quot;);            Console.WriteLine(&quot;x &#x3D; &#123;0&#125;, y &#x3D; &#123;1&#125;&quot;, p.x, p.y); &#x2F;&#x2F; x &#x3D; 5, y &#x3D; 30        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对接口名称建议以“I”开头，如Ipoint；</li><li>对接口的访问修饰符可以选择使用，但是接口的方法前面不能添加任何访问修饰符，它是隐式公开的；</li><li>接口不能包含构造函数，接口不能实现任何方法、属性和索引器。</li></ul><p>扩展：定义一个IPerson接口，接口包含DoWork和DoExercise两个抽象方法，并用Person类实现接口。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; IPerson.csinterface IPerson &#x2F;&#x2F; 声明接口IPerson&#123;void DoWork(); &#x2F;&#x2F; 声明DoWork方法void DoExercise(); &#x2F;&#x2F; 声明DoExercise方法&#125;&#x2F;&#x2F; 定义Person类实现IPerson接口public class Person: IPerson&#123;&#x2F;&#x2F; 定义基类的共有属性private string _name; &#x2F;&#x2F; 声明姓名字段public string Name &#x2F;&#x2F; 声明姓名属性&#123;get &#123; return this._name; &#125;set &#123;this._name &#x3D; value; &#125;&#125;public Person()&#123;&#125; &#x2F;&#x2F; 声明无参构造函数public Person(string name) &#x2F;&#x2F; 声明有参构造函数&#123;this._name &#x3D; name;&#125;public void DoWork() &#x2F;&#x2F; 定义工作方法&#123;Console.WriteLine(&quot;I&#39;m working!&quot;);&#125;public void DoExercise() &#x2F;&#x2F; 定义锻炼方法&#123;Console.WriteLine(&quot;I&#39;m doing exercise!&quot;);&#125;public void Display() &#x2F;&#x2F; 基类的共有方法&#123;Console.WriteLine(&quot;我是&#123;0&#125;&quot;, this._name);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Program.csPerson objPerson &#x3D; new Person(&quot;小明&quot;);objPerson.Display(); &#x2F;&#x2F;  我是小明objPerson.DoWork(); &#x2F;&#x2F; I&#39;m working!objPerson.DoExercise(); &#x2F;&#x2F; I&#39;m doing exercise!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="接口的实现-1"><a href="#接口的实现-1" class="headerlink" title="接口的实现"></a>接口的实现</h5><ul><li>C#中的派生类只能有一个基类，不支持类的多重继承，但可以继承多个接口，通过接口实现多继承。</li><li>如在现实中儿子不但可以继承父亲的财产，如伯父无子女，也可以继承伯父的财产，在C#中这属于多重继承，要用接口来实现，其实接口就是为了实现多重继承而产生的。</li><li>在C#中接口可以多继承，接口之间可以互相继承，普通类和抽象类可以继承自接口。</li><li>一个类可以同时继承一个类和多个接口，但是接口不能继承类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-多态（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/13/c-xue-xi-bi-ji-duo-tai-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/13/c-xue-xi-bi-ji-duo-tai-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h5><p>同一操作作用于不同的类的对象，不同的类的对象进行不同的执行，最后产生不同的执行结果。</p><h5 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h5><p>C#中支持基于接口的多态和基于继承的多态，基于继承的多态设计在基类中定义方法，并在派生类中重写方法。</p><p>多态和重写是紧密联系的，重写是实现多态的重要手段。重写基类方法就是修改它的实现，或者说在派生类中对继承的基类方法重新编写。</p><p>在基类中用<strong>virtual</strong>关键字声明的方法（叫做虚拟方法）在派生类中可以重写。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法访问修饰符 virtual 返回类型 方法名()&#123;&#x2F;&#x2F; 方法体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;...public virtual void Display() &#x2F;&#x2F; 基类中定义成虚拟方法，使用virtual关键字&#123;&#x2F;&#x2F; Father does sth....&#125;&#125;class Son: Father&#123;...public override void Display() &#x2F;&#x2F; 重写基类的Display方法&#123;&#x2F;&#x2F; Son does sth....&#x2F;&#x2F; 若想派生类方法执行后，继续执行基类方法，执行 base.Display() 方法base.Display();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重写时，子类重写方法的访问级别和父类虚拟方法的访问级别必须相同。</strong></p><h5 id="方法重载、重写和隐蔽"><a href="#方法重载、重写和隐蔽" class="headerlink" title="方法重载、重写和隐蔽"></a>方法重载、重写和隐蔽</h5><p>在基类和派生类中可以存在同名方法，这些同名的方法可以分为重载、重写和隐藏3种类型。</p><ul><li>重载<br>重载是在同一个作用域内发生（比如一个类里面），定义一系列同名方法，但是方法的参数列表不同，就是签名不同，签名由方法名和参数组成。<br>能通过传递不同的参数来决定到底调用哪一个同名方法。</li></ul><p><strong>注意返回值类型不同不能构成重载，因为签名不包括返回值。</strong></p><ul><li>重写<br>基类方法中使用virtual关键字声明的方法和派生类中使用override关键字声明的方法名称相同，参数列表也相同，就是基类方法和派生类方法的签名相同，实现了派生类重写基类中的同名方法。</li><li>隐藏<br>基类中的方法不声明为virtual（默认为非虚方法），在派生类中声明与基类同名时，需使用new关键字，以隐藏基类同名方法。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;...public virtual void Display() &#x2F;&#x2F; 基类中定义成虚拟方法，使用virtual关键字&#123;&#x2F;&#x2F; Father does sth....&#125;public void Display(int id)&#123;&#x2F;&#x2F; 若想执行无参方法this.Display();&#x2F;&#x2F; 有参方法Console.WriteLine(&quot;id: &quot; + id);&#125;&#125;class Son: Father&#123;...public override void Display() &#x2F;&#x2F; 重写基类的Display方法&#123;&#x2F;&#x2F; do sth....&#x2F;&#x2F; 若想派生类方法执行后，继续执行基类方法，执行 base.Display() 方法base.Display();&#125;public new void Display(int no) &#x2F;&#x2F; 使用new隐藏基类&#123;&#x2F;&#x2F; do sth....&#x2F;&#x2F; 若想派生类方法执行后，继续执行基类方法，执行 base.Display() 方法base.Display();&#x2F;&#x2F; 隐藏基类自定义方法Console.WriteLine(&quot;no: &quot; + no);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-数据类型相关代码笔记（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/10/c-xue-xi-bi-ji-shu-ju-lei-xing-xiang-guan-dai-ma-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/10/c-xue-xi-bi-ji-shu-ju-lei-xing-xiang-guan-dai-ma-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="数据类型相关操作"><a href="#数据类型相关操作" class="headerlink" title="数据类型相关操作"></a>数据类型相关操作</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">var intNum &#x3D; 250;int i &#x3D; intnum; &#x2F;&#x2F; var 型变量intnum隐式转换成整型var name &#x3D; &quot;john&quot;;string strname &#x3D; name; &#x2F;&#x2F; var型变量name隐式转换成string型Console.WriteLine(&quot;转换后的内容是&#123;0&#125;，&#123;1&#125;&quot;, i, name); &#x2F;&#x2F; 转换后的内容是250, johnConsole.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">decimal pi &#x3D; 3.14159M; &#x2F;&#x2F; 字母M表示是decimal类型int r &#x3D; 12; &#x2F;&#x2F; 圆的半径decimal s &#x3D; 0; &#x2F;&#x2F; 圆的面积s &#x3D; pi*r*r;Console.WriteLine(&quot;圆的半径是&#123;0&#125;，\n圆的面积是&#123;1&#125;&quot;, r, s);Console.ReadLine();MessageBox.Show(&quot;圆的半径是&quot;+r+&quot;\n圆的面积是&quot;+s);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">float pi &#x3D; 3.14f; &#x2F;&#x2F; 定义一个单精度的实数int i &#x3D; (int)pi; &#x2F;&#x2F; 将单精度强制转换成整型计算，i的值是3，不是3.14，造成信息丢失Console.WriteLine(&quot;转换后的内容是&#123;0&#125;&quot;, i);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Convert类转换"><a href="#Convert类转换" class="headerlink" title="Convert类转换"></a>Convert类转换</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string myString &#x3D; &quot;true&quot;;bool MyBool &#x3D; Convert.ToBoolean(myString); &#x2F;&#x2F; 将string转换成Boolean型，Mybool &#x3D; truestring newString &#x3D; &quot;12345&quot;;int myInt &#x3D; Convert.ToInt32(newString); &#x2F;&#x2F; 将字符串转为数字值，myInt &#x3D; 12345Console.WriteLine(&quot;转换后的内容是&#123;0&#125;，&#123;1&#125;&quot;, MyBool, myInt); &#x2F;&#x2F; true 12345Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="隐式转换、显式转换使用举例："><a href="#隐式转换、显式转换使用举例：" class="headerlink" title="隐式转换、显式转换使用举例："></a>隐式转换、显式转换使用举例：</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(&quot;隐式、显式转换例子：&quot;);short r &#x3D; 25; &#x2F;&#x2F; 表示圆的半径int i &#x3D; r; &#x2F;&#x2F; 将短整型r隐式转换成整型float pi &#x3D; 3.14f; &#x2F;&#x2F; 定义一个单精度的实数double s1 &#x3D; pi * i * i; &#x2F;&#x2F; s1为double型，表示圆的面积int s2;s2 &#x3D; (int)pi * i * i; &#x2F;&#x2F; s2为int型，表示圆的面积 强制转换var name &#x3D; &quot;john&quot;;string strName &#x3D; name; &#x2F;&#x2F; var类型变量name隐式转换为string型Console.WriteLine(&quot;r&#x3D;25，圆的面积&#x3D;&#123;0&#125;,&#123;1&#125;&quot;, s1, s2);Console.WriteLine(&quot;转换成功！&quot;);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Convert转换使用举例："><a href="#Convert转换使用举例：" class="headerlink" title="Convert转换使用举例："></a>Convert转换使用举例：</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(&quot;隐式、显式转换例子：&quot;);short r &#x3D; 25; &#x2F;&#x2F; 表示圆的半径int i &#x3D; Convert.ToInt32(r); &#x2F;&#x2F; 将短整型r隐式转换成整型float pi &#x3D; 3.14f; &#x2F;&#x2F; 定义一个单精度的实数double s1 &#x3D; pi * i * i; &#x2F;&#x2F; s1为double型，表示圆的面积int s2;s2 &#x3D; Convert.ToInt32(pi) * i * i; &#x2F;&#x2F; s2为int型，表示圆的面积var memberName &#x3D; &quot;Johnson&quot;;string strName &#x3D; Convert.ToString(memberName); &#x2F;&#x2F; var型变量隐式转换为string型Console.WriteLine(&quot;r&#x3D;25，圆的面积&#x3D;&#123;0&#125;,&#123;1&#125;&quot;, s1, s2);Console.WriteLine(&quot;memberName&#x3D;&#123;0&#125;&quot;, memberName);Console.WriteLine(&quot;转换成功！&quot;);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串与数值之间的转换"><a href="#字符串与数值之间的转换" class="headerlink" title="字符串与数值之间的转换"></a>字符串与数值之间的转换</h4><ul><li>ToString()方法：数值类型的ToString()方法可以将数值型数据转换为字符串。</li><li>Parse()方法：数值类型的Parse()方法可以将字符串转换为数值型，例如,字符串转换为整型使用int.Parse(string)，字符串转换为双精度浮点型使用double.Parse(string)等。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int num1 &#x3D; 25;string str1 &#x3D; num1.ToString(); &#x2F;&#x2F; num1的toString()方法将num1转换成string赋值给str1string str2 &#x3D; &quot;38&quot;;int num2 &#x3D; int.Parse(str2); &#x2F;&#x2F; int.Parse()方法将字符串str2转换成int类型string str3 &#x3D; &quot;21&quot;;double num3 &#x3D; double.Parse(str3); &#x2F;&#x2F; double.Parse()将字符串转换为双精度浮点型、string str4 &#x3D; &quot;56&quot;;float num4 &#x3D; float.Parse(str4); &#x2F;&#x2F; float.Parse()将字符串转换成单精度浮点型Console.WriteLine(&quot;num1、num2、num3、num4对应的数值为: &#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;&quot;, num1, num2, num3,num4);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 拆箱：引用类型-&gt;值类型&#x2F;&#x2F; 装箱：值类型-&gt;引用类型int n &#x3D; 4; &#x2F;&#x2F; n是值类型object obj &#x3D; n; &#x2F;&#x2F; 装箱，把任何值类型隐式转换为object类型，其中object为引用类型console.writeline(&quot;n的初始值为：&#123;0&#125;，装箱后的值为：&#123;1&#125;&quot;, n, obj.tostring());int m &#x3D; (int)obj; &#x2F;&#x2F;拆箱，把一个object类型隐式的转换为值类型console.writeline(&quot;引用类型的值为：&#123;0&#125;，拆箱后的值为：&#123;1&#125;&quot;, obj.tostring(), m);console.readline();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="引用类型与值类型"><a href="#引用类型与值类型" class="headerlink" title="引用类型与值类型"></a>引用类型与值类型</h4><p>引用类型和值类型变量的使用是C#中的高级技巧之一。值类型变量中保存的是自己的实际数据，在赋值的时候会把源变量的数据复制一份，然后赋给目的变量；引用类型变量中保存的是“指向实际数据的指针”，即实际对象数据的内存地址，在进行赋值操作的时候，它和值类型一样，也是先有一个复制的操作，不过它复制的不是实际的数据，而是引用（真实数据的内存地址）。</p><ol><li>怎么区分值类型与引用类型以struct关键字定义的数据类型就是值类型，另外，枚举类型也是值类型；以class关键字定义的数据类型就是引用类型。</li><li>值类型变量与引用类型变量的使用区别值类型变量不需要使用new关键字来分配内存。相信大家使用int型变量时，就没有使用new来为其分配内存，定义完之后，就可以直接使用；引用类型变量则需要为其赋值后，才能使用。下面举例说明值类型与引用类型在使用上的区别。<br>首先定义两种类型的员工：结构体SEmployee和类CEmployee。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct SEmployee   &#123;       public int age;   &#125;   class CEmployee   &#123;       public int age;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">SEmployee se;se.age &#x3D; 4;CEmployee ce;ce &#x3D; new CEmployee();ce.age &#x3D; 5;Console.WriteLine(&quot;年龄：&#123;0&#125;&quot;, se.age);Console.WriteLine(&quot;年龄：&#123;0&#125;&quot;, ce.age);Console.ReadLine();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>值类型变量在定义后，就直接可以使用，而引用类型必须使用new关键字后才能使用。对于引用类型会有“未将对象引用设置到对象的实例”错误，而值类型不会发生这种错误。<h4 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h4>typeof运算符用于获得系统原型对象的类型，也就是Type类型。Type类包含关于值类型和引用类型的信息。</li></ol><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Type t  &#x3D; typeof(int);Console.WriteLine(&quot;类型：&#123;0&#125;&quot;, t); &#x2F;&#x2F; System.Int32Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="checked和unchecked运算符"><a href="#checked和unchecked运算符" class="headerlink" title="checked和unchecked运算符"></a>checked和unchecked运算符</h4><p>checked和unchecked运算符用于允许或者禁止对指定的运算进行检测，并指出相应的错误提示信息。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">byte s &#x3D; 255;checked &#x2F;&#x2F; checked会检查溢出报错，并给出错误提示&#x2F;&#x2F; unchecked &#x2F;&#x2F; checked 改为 unckcked,控制台不报错，输出1&#123;    s +&#x3D; 2;&#125;Console.WriteLine(s.ToString());Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成绩练习代码"><a href="#成绩练习代码" class="headerlink" title="成绩练习代码"></a>成绩练习代码</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(&quot;请输入成绩0-100：&quot;);int score &#x3D; int.Parse(Console.ReadLine());if (score &gt;&#x3D; 90)&#123;    Console.WriteLine(&quot;优秀&quot;);&#125;else if (score &gt;&#x3D; 80)&#123;    Console.WriteLine(&quot;良好&quot;);&#125;else if (score &gt;&#x3D; 70)&#123;    Console.WriteLine(&quot;中等&quot;);&#125;else if (score &gt;&#x3D; 60)&#123;    Console.WriteLine(&quot;及格&quot;);&#125;else&#123;    Console.WriteLine(&quot;不及格&quot;);&#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环练习代码"><a href="#循环练习代码" class="headerlink" title="循环练习代码"></a>循环练习代码</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; for循环计算0-100的和int sum &#x3D; 0;for (int i &#x3D; 1; i &lt;101; i++)&#123;    sum +&#x3D; i;&#125;Console.WriteLine(sum);Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; while循环计算0-100的和    int i &#x3D; 1, sum &#x3D; 0;    while(i &lt; 101)    &#123;        sum +&#x3D; i;        i++;    &#125;    Console.WriteLine(sum);    Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; do-while计算0-100的和int i&#x3D;1, sum &#x3D;0;do&#123;    sum +&#x3D; i;    i++;&#125; while (i &lt;&#x3D; 100);Console.WriteLine(sum);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; for-each循环string[]week &#x3D; &#123;&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;&#125;; &#x2F;&#x2F; 定义数组并赋值foreach(string s in week) &#x2F;&#x2F; 遍历数组&#123;    Console.WriteLine(s);&#125;Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 输出九九乘法表for (int i &#x3D; 1; i &lt; 10; i++)&#123;    for (int j &#x3D; 1; j &lt;&#x3D; i; j++)    &#123;        int k &#x3D; i*j;        Console.Write(&quot;&#123;0&#125;*&#123;1&#125; &#x3D; &#123;2&#125;&quot;, j, i, k);        if (i !&#x3D; j)Console.Write(&quot;,&quot;);    &#125;    Console.WriteLine();&#125;Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 输出小于100的素数Console.WriteLine(&quot;小于100的素数有：&quot;);for (int i &#x3D; 2; i &lt; 100; i++)&#123;    bool isPrime &#x3D; true;    for (int j &#x3D; 2; j &lt; i-1; j++)    &#123;        if (i % j &#x3D;&#x3D; 0)        &#123;            isPrime &#x3D; false;            break;        &#125;    &#125;    if (isPrime)Console.WriteLine(i);&#125;Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 复印纸数练习Console.WriteLine(&quot;请输入复印数量：&quot;);int num &#x3D; int.Parse(Console.ReadLine());double money &#x3D; 0;if (num &lt; 51) money &#x3D; 0.5*num;else money &#x3D; 0.5*50 + (num - 50)*0.2;Console.WriteLine(money);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-字符串操作相关笔记（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/10/c-xue-xi-bi-ji-zi-fu-chuan-cao-zuo-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/10/c-xue-xi-bi-ji-zi-fu-chuan-cao-zuo-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h5 id="字符串判等-Equals"><a href="#字符串判等-Equals" class="headerlink" title="字符串判等 Equals()"></a>字符串判等 Equals()</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Equals() 判断两个字符串是否相等，若相等则返回True，否则返回False * 语法：字符串变量1.Equals(字符串2) * 调用string类的静态方法： string.Equals(字符串1, 字符串2)*&#x2F;string str1 &#x3D; &quot;aaa&quot;;Console.WriteLine(str1.Equals(&quot;aaa&quot;)); &#x2F;&#x2F; true &lt;&#x3D;&#x3D;&gt; str1 &#x3D;&#x3D; &quot;aaa&quot;Console.WriteLine(str1.Equals(&quot;bbb&quot;)); &#x2F;&#x2F; flaseConsole.WriteLine(string.Equals(str1, &quot;aaa&quot;));  &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串比较-CompareTo"><a href="#字符串比较-CompareTo" class="headerlink" title="字符串比较 CompareTo( )"></a>字符串比较 CompareTo( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * CompareTo( )用于比较字符串变量与给定字符串的大小，返回值为0、1或者-1 * 字符串的比较方式是，找到两个字符串中第一个不相同的字符，该字符ASCII值小的字符串较小。 * 若一直比较到字符串结束，每个对应字符都相同，那么若两个字符串长度相同，则两个字符串相等； * 若两个字符串长度不同，则短的字符串较小。 * 若字符串变量小于字符串2，则返回-1，反之返回1;若字符串变量与字符串2相等，则返回0。 * 语法： 字符串变量.CompareTo(字符串2) * 也可以使用静态方法Compare( )比较字符串1和字符串2的大小，相等则返回0，字符串1小则返回-1，字符串1大则返回1 * 语法: string.Compare(字符串1, 字符串2); *&#x2F;string s &#x3D; &quot;123&quot;;string str &#x3D; s;Console.WriteLine(s.CompareTo(str)); &#x2F;&#x2F; 0Console.WriteLine(s.CompareTo(&quot;121&quot;)); &#x2F;&#x2F; 1Console.WriteLine(string.Compare(str, &quot;124&quot;)); &#x2F;&#x2F; -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串包含-Contains"><a href="#字符串包含-Contains" class="headerlink" title="字符串包含 Contains( )"></a>字符串包含 Contains( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Contains( )用于判断字符串变量是否包含指定字符或字符串，是则返回True，否则返回False。 * 语法： 字符串变量.Contains(字符1&#x2F;字符串1); *&#x2F;string s &#x3D; &quot;123&quot;;Console.WriteLine(s.Contains(&quot;1&quot;)); &#x2F;&#x2F; trueConsole.WriteLine(s.Contains(&quot;12&quot;)); &#x2F;&#x2F; trueConsole.WriteLine(s.Contains(&quot;123&quot;)); &#x2F;&#x2F; trueConsole.WriteLine(s.Contains(&quot;1234&quot;));  &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串位置-IndexOf"><a href="#字符串位置-IndexOf" class="headerlink" title="字符串位置 IndexOf( )"></a>字符串位置 IndexOf( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * IndexOf( )用于查找给定字符或字符串在字符串变量中第一次出现的位置，返回字符或者字符串首字母在字符串变量中的位置数值。 * 不存在，则返回-1 * 语法：字符串变量.IndexOf(字符1) * LastIndexOf( )，用于查找给定字符或字符串在字符串变量中最后一次出现的位置数值。 *&#x2F;string s &#x3D; &quot;123123&quot;;Console.WriteLine(s.IndexOf(&quot;1&quot;)); &#x2F;&#x2F; 0Console.WriteLine(s.IndexOf(&quot;23&quot;)); &#x2F;&#x2F; 1Console.WriteLine(s.IndexOf(&quot;4&quot;)); &#x2F;&#x2F; -1Console.WriteLine(s.LastIndexOf(&quot;2&quot;));  &#x2F;&#x2F; 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串截取-SubString"><a href="#字符串截取-SubString" class="headerlink" title="字符串截取 SubString( )"></a>字符串截取 SubString( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * SubString( )用于从字符串变量中获取指定位置开始的指定长度的子字符串，如果未指定子字符串长度，则取至字符串变量结尾，返回值为该子字符串。 * 语法：字符串变量.SubString(起始位置, 字符串长度) * 无长度参数即为从起始位置到末尾 * 若起始位置或者子字符串长度超出字符串变量允许范围，则系统返回异常ArgumentOutOfRangeException。 *&#x2F;string str &#x3D; &quot;Hello World!&quot;;Console.WriteLine(str.Substring(6)); &#x2F;&#x2F; worldConsole.WriteLine(str.Substring(0, 4)); &#x2F;&#x2F; hell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="插入子串-Insert"><a href="#插入子串-Insert" class="headerlink" title="插入子串 Insert( )"></a>插入子串 Insert( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Insert( )用于在字符串变量中指定位置插入给定子字符串，返回值为该子字符串。 * 语法：字符串变量.Insert(起始位置, 子字符串2) *&#x2F;string str &#x3D; &quot;world!&quot;;Console.WriteLine(str.Insert(0, &quot;hello &quot;)); &#x2F;&#x2F; hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="删除子串-Remove"><a href="#删除子串-Remove" class="headerlink" title="删除子串 Remove( )"></a>删除子串 Remove( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Remove( )用于在字符串变量中删除指定位置开始的指定长度的子字符串，返回值为删除指定子串后的字符串变量。 * 语法：字符串.Remove(起始位置, 子串长度) * 无长度参数即为从起始位置到末尾 *&#x2F;string str &#x3D; &quot;this is a test&quot;;Console.WriteLine(str.Remove(0, 5)); &#x2F;&#x2F; is a testConsole.WriteLine(str.Remove(1, 5)); &#x2F;&#x2F; ts a testConsole.WriteLine(str.Remove(4)); &#x2F;&#x2F; this<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="替换子串-Replace"><a href="#替换子串-Replace" class="headerlink" title="替换子串 Replace( )"></a>替换子串 Replace( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Replace( )用于替换字符串变量中的指定字符或子字符串，返回值为替换完毕后的字符串变量 * 语法：字符串变量.Replace(字符1, 字符2) &#x2F;&#x2F; 用字符2替换字符1 * 或者：字符串变量.Replace(字符串1, 字符串2) &#x2F;&#x2F; 用字符串2替换字符串1 *&#x2F;string str &#x3D; &quot;Tom is a good boy!&quot;;Console.WriteLine(str.Replace(&quot;Tom&quot;, &quot;Jack&quot;)); &#x2F;&#x2F; Jack is a good boy!Console.WriteLine(str.Replace(&#39;o&#39;, &#39;k&#39;)); &#x2F;&#x2F; Tkm is a gkkd bky!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="去除字符串空格-Trim"><a href="#去除字符串空格-Trim" class="headerlink" title="去除字符串空格 Trim( )"></a>去除字符串空格 Trim( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Trim( )用于去除字符串变量中头部和尾部的空格，返回值为去除空格的字符串变量 * 语法：字符串变量.Trim() * TrimStart()与TrimEnd()可以分别去除头部和尾部的空格 *&#x2F;string str &#x3D; &quot;   this is a test   &quot;;Console.WriteLine(str); &#x2F;&#x2F; (3空格)this is a test(3空格)   Console.WriteLine(str.Trim()); &#x2F;&#x2F; this is a testConsole.WriteLine(str.TrimStart()); &#x2F;&#x2F; this is a test(3空格)  Console.WriteLine(str.TrimEnd()); &#x2F;&#x2F; (3空格)this is a test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * String类是引用类型，每次改变String类对象的值，即修改字符串变量对应的字符串，都需要在内存中为新字符串重新分配空间。 * 在某些特定情况，例如，循环中可能需要反复修改一个字符串变量的值，内存开销会比较大。 * StringBuilder类则没有这一问题，StringBuilder类的对象可以调用ToString( )方法将StringBuilder类的内容作为String类字符串输出， * 调用Append( )和AppendLine( )方法添加内容。 *&#x2F;StringBuilder str &#x3D; new StringBuilder();str.Append(&quot;我爱你！&quot;);str.AppendLine(&quot;中国！&quot;);str.Append(&quot;我的祖国！&quot;);Console.WriteLine(str); &#x2F;&#x2F; 我爱你！中国！                                        &#x2F;&#x2F; 我的祖国！Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-数组操作相关笔记（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/10/c-xue-xi-bi-ji-shu-zu-cao-zuo-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/10/c-xue-xi-bi-ji-shu-zu-cao-zuo-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>语法：数据类型[] 数组名    /   数组名 = new 数据类型[]</p><pre class="line-numbers language-none"><code class="language-none">int[] a   &#x2F;   a &#x3D; new int[5]&#123;1, 2, 3, 4, 5&#125;   &#x2F;   a &#x3D; new int[5]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string[] week &#x3D; &#123; &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot; &#125;;for(int i &#x3D; 0; i &lt; week.Length; i++)&#123;    Console.WriteLine(week[i]);&#125;Console.ReadLine();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>语法：数据类型[, ]数组名</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[,] b &#x3D; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;;for (int i &#x3D; 0; i &lt; 3; i++)    for (int j &#x3D; 0; j &lt; 3; j++)        Console.WriteLine(&quot;&#123;0&#125;行&#123;1&#125;列元素为&#123;2&#125;&quot;, i, j, b[i, j]);for (int i &#x3D; 0; i &lt; 3; i++)&#123;    for (int j &#x3D; 0; j &lt; 3; j++)    &#123;        Console.Write(&quot;&#123;0,-5&#125;&quot;, b[i, j]); &#x2F;&#x2F; 输出数组元素，每个元素占五格，靠左对齐        &#x2F;**         * 1    2    3        * 4    5    6         * 7    8    9         *&#x2F;    &#125;    Console.WriteLine();&#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="三维数组"><a href="#三维数组" class="headerlink" title="三维数组"></a>三维数组</h4><p>可以把三维数组看做一本记录本，每页都是一个表格，那么，可以使用页号、行号、列号来定位三维数组的一个元素。<br>语法：数据类型[, , ] 数组名</p><h4 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h4><p> 交错数组可以看成是数组的数组，交错数组的每个元素又是一个数组<br> 语法：<br> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[][] &#x3D; new int[3][]&#123;    new int[] &#123; 1, 2, 3 &#125;,    new int[] &#123; 4, 5, 6 &#125;,    new int[] &#123; 7, 8, 9 &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[][] c;c &#x3D; new int[3][];c[0] &#x3D; new int[] &#123; 1, 2, 3 &#125;;c[1] &#x3D; new int[] &#123; 4, 5, 6, 7 &#125;;c[2] &#x3D; new int[] &#123; 8, 9, 10, 11, 12 &#125;;for (int i &#x3D; 0; i &lt; c.Length; i++)&#123;    for (int j &#x3D; 0; j &lt; c[i].Length; j++)    &#123;        Console.Write(&quot;&#123;0, -5&#125;&quot;, c[i][j]);    &#125;    Console.WriteLine();&#125;&#x2F;** * 1    2    3 * 4    5    6    7 * 8    9    10    11    12 *&#x2F;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组基本操作"><a href="#数组基本操作" class="headerlink" title="数组基本操作"></a>数组基本操作</h3><h4 id="数组排序与反转"><a href="#数组排序与反转" class="headerlink" title="数组排序与反转"></a>数组排序与反转</h4><p>Array类的静态方法Sort()可以实现数组的排序，无返回值。<br>语法：Array.Sort(数组名)</p><p>Array类的静态方法Reverse()可以实现数组的反转，无返回值。<br>语法：Array.Reverse(数组名)</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[] a &#x3D; &#123; 3, 8, 1, 7, 4 &#125;;Array.Sort(a);for (int i &#x3D; 0; i &lt; a.Length; i++)&#123;    Console.Write(&quot;&#123;0, -5&#125;&quot;, a[i]); &#x2F;&#x2F; 1    3    4    7    8&#125;Console.WriteLine();Array.Reverse(a);for (int i &#x3D; 0; i &lt; a.Length; i++)&#123;    Console.Write(&quot;&#123;0, -5&#125;&quot;, a[i]); &#x2F;&#x2F; 8    7    4    3    1&#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找数组元素"><a href="#查找数组元素" class="headerlink" title="查找数组元素"></a>查找数组元素</h4><p> Array类的静态方法IndexOf( )可以判断数组是否包含与给定值相等的元素，是则返回对应数组元素的下标，否则返回-1。<br>语法：Array.IndexOf(数组名, 要查找的值)</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[] a &#x3D; &#123; 4, 5, 2, 7, 1 &#125;;Console.WriteLine(Array.IndexOf(a, 4)); &#x2F;&#x2F; 0Console.WriteLine(Array.IndexOf(a, 10)); &#x2F;&#x2F; -1Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>####数组求和，最大值，最小值，平均值<br>Sum(), Max(), Min(), Average()<br>语法：数组名.Sum()</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[] a &#x3D; &#123; 3, 8, 1, 7, 4 &#125;;Console.WriteLine(a.Sum()); &#x2F;&#x2F; 23Console.WriteLine(a.Max()); &#x2F;&#x2F; 8Console.WriteLine(a.Min()); &#x2F;&#x2F; 1Console.WriteLine(a.Average()); &#x2F;&#x2F; 4.6Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组字符串相互转化"><a href="#数组字符串相互转化" class="headerlink" title="数组字符串相互转化"></a>数组字符串相互转化</h4><p> String类的静态方法Join( )可以将数组中所有元素连接起来，生成一个字符串，返回值为该字符串。<br> 语法：String.Join(分隔符, 数组名)  –&gt; Join( )方法分隔符类型为字符串</p><p> 方法Split( )可以根据分隔符将字符串切分为多个部分，每个部分作为一个数组元素生成一个字符串数组，返回值为该字符串数组。<br>语法：字符串变量.Split(分隔符)  –&gt; Split( )方法中的分隔符类型为字符型</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string[] a &#x3D; &#123; &quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;, &quot;!&quot; &#125;;string b &#x3D; String.Join(&quot; &quot;, a);Console.WriteLine(b);string[] a1 &#x3D; b.Split(&#39; &#39;);for (int i &#x3D; 0; i &lt; a1.Length; i++)&#123;    Console.WriteLine(a1[i]);&#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在字符串中查找、删除字符数组元素"><a href="#在字符串中查找、删除字符数组元素" class="headerlink" title="在字符串中查找、删除字符数组元素"></a>在字符串中查找、删除字符数组元素</h4><p> String类方法IndexOfAny( )用于在字符串中查找给定字符数组中的所有元素，返回字符数组元素在字符串中首次出现的位置值，查找失败则返回-1。<br> 语法：字符串变量.IndexOfAny(字符数组名)</p><p>String类方法LastIndexOfAny( )用于在字符串中查找给定字符数组中的所有元素，返回字符数组元素在字符串中最后出现的位置值，查找失败则返回-1。<br>语法：字符串变量.LastIndexOfAny(字符数组名)</p><p> String类方法Trim( )可以在字符串的首部和尾部去除给定字符数组中的所有元素，返回操作后的字符串。<br> 语法：字符串变量.Trim(字符数组名)</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">char[] a &#x3D; &#123; &#39;a&#39;, &#39;t&#39;, &#39;i&#39; &#125;;string str &#x3D; &quot;This is a test!&quot;;Console.WriteLine(str.IndexOfAny(a)); &#x2F;&#x2F; 2Console.WriteLine(str.LastIndexOfAny(a)); &#x2F;&#x2F; 13char[] b &#x3D; &#123; &#39;T&#39;, &#39;h&#39;, &#39;t&#39; &#125;;Console.WriteLine(str.Trim(b)); &#x2F;&#x2F; is is a test!Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p> 枚举类型用于声明一组命名常数。<br> 语法：enum 枚举类型名 {枚举成员列表}<br>例：enum Week { 星期一, 星期二, 星期三, 星期四, 星期五, 星期六, 星期天 };</p><p> 枚举类型week包含七个常数，默认第一个常数为0，对应“星期一”，每个名称对应的常数都比前边一个加1，最后一个常数为6，对应“星期天”。<br> 相当于为常数起了个名字，把七个常数组合在一起构成枚举类型week。</p><p> enum Week { 星期一 = 1, 星期二, 星期三, 星期四, 星期五, 星期六, 星期天 };<br> 给出第一个名称星期一对应的常数为1，后边的名称对应的常数值分别是2、3、4、5、6、7。<br> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 定义枚举类型变量x，选择枚举类型中的一个名称为变量x赋值Week x &#x3D; Week.星期一;&#x2F;&#x2F; 定义枚举类型变量y，将整数2强制转换为week类型的值赋值给变量Week y &#x3D; (Week)2;Console.WriteLine(x.ToString()); &#x2F;&#x2F; 星期一Console.WriteLine(y.ToString()); &#x2F;&#x2F; 星期二Console.WriteLine((Week)2); &#x2F;&#x2F; 输出枚举类型Week中常量2对应的名称 --&gt; 星期二Console.WriteLine((int)Week.星期天); &#x2F;&#x2F; 输出枚举类型Week中名称“星期天”对应的常量  --&gt;  7Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>枚举类型的最大作用是可以自定义一个类型，将许多相关的名称作为一个集合保存和使用，每个名称对应一个整型常量。</li><li>相对于直接使用数值，使用枚举类型可以使代码更加清晰易懂，便于记忆。</li><li>枚举类型的变量只能选择几个常量中的一个，方便控制变量取值范围，保证程序的执行过程安全可靠。</li><li>常量值和枚举值之间转换方便，使用枚举类型使代码更容易编写和维护。<h4 id="字符串与字符数组相互转化"><a href="#字符串与字符数组相互转化" class="headerlink" title="字符串与字符数组相互转化"></a>字符串与字符数组相互转化</h4>使用语句“string str = new string(‘a’,5);”创建包含5个相同字符的字符串str，str对应的字符串为“aaaaa”。<br>事实上，我们可以使用任意一个字符类型数组初始化一个字符串。<br>反之，一个字符串可以直接作为一个字符类型数组使用，直接在字符串名后面加上下标即可<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">char[] c &#x3D; &#123; &#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;W&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;！&#39; &#125;;string str &#x3D; new string(c);Console.WriteLine(str); &#x2F;&#x2F; Hello World!Console.WriteLine(str[0]); &#x2F;&#x2F; HConsole.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="foreach遍历二维数组"><a href="#foreach遍历二维数组" class="headerlink" title="foreach遍历二维数组"></a>foreach遍历二维数组</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[,] a &#x3D; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6&#125;, &#123; 7, 8, 9&#125; &#125;;foreach (int x in a)    Console.Write(&quot;&#123;0, -4&#125;&quot;, x);Console.ReadKey(); &#x2F;&#x2F; 1   2   3  4   5   6   7   8   9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>使用foreach循环遍历二维数组，访问数组元素的顺序是先行后列，因此输出结果为123456。</li><li>如果需要按照先列后行遍历数组元素的话，需要使用嵌套的for循环。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-类与对象相关笔记（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/10/c-xue-xi-bi-ji-lei-yu-dui-xiang-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/10/c-xue-xi-bi-ji-lei-yu-dui-xiang-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="C-类的修饰符"><a href="#C-类的修饰符" class="headerlink" title="C#类的修饰符"></a>C#类的修饰符</h4><ul><li>Public：公有的, 是类型和类型成员的访问修饰符。对其访问不受任何限制。</li><li>Private：私有的,私有成员只有在声明它们的类和结构体中才是可访问的。</li><li>Protected：保护成员，该类内部和继承类中可以访问。 </li><li>internal：内部访问,同一个程序集中的所有类都可以访问,一般都是限于本项目内。</li><li>Protected internal：受内部保护的,只限于本项目或是子类访问，其他不能访问。 </li></ul><p>一个类[包括接口，结构体，枚举，委托]上可以使用的访问修饰符有：public, internal默认的值是internal。<br>内部成员的默认级别</p><ul><li>class: private     enum: public    </li><li>interface(接口): public    struct: private</li></ul><h5 id="对象与类知识练习代码："><a href="#对象与类知识练习代码：" class="headerlink" title="对象与类知识练习代码："></a>对象与类知识练习代码：</h5><p>phone类文件，phone.cs</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public const string PhoneType &#x3D; &quot;GSM&quot;; &#x2F;&#x2F; 声明常量，隐式静态        public static string emergency_Call &#x3D; &quot;119&quot;;        private string phoneNumber; &#x2F;&#x2F; 定义私有字段表示电话号码        public string PhoneNumber &#x2F;&#x2F; 定义公有属性，设置和获取phoneNumber的值        &#123;            get &#123; return phoneNumber; &#125;            set &#123; phoneNumber &#x3D; value; &#125;        &#125;        public void Dial() &#x2F;&#x2F; 无参数方法成员，表示电话具有拨打功能        &#123;            Console.WriteLine(&quot;您正在拨打电话！&quot;);        &#125;        public void DialNumber(string number) &#x2F;&#x2F; 有参数方法成员，表示拨打具体电话号码        &#123;            Console.WriteLine(&quot;您正在拨打&quot; + number);        &#125;        public static void EmergencyCall() &#x2F;&#x2F; 静态方法EmergencyCall        &#123;            Console.WriteLine(&quot;您正在拨打急救电话119！&quot;);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Phone.EmergencyCall(); &#x2F;&#x2F; 您正在拨打急救电话119！Console.WriteLine(Phone.emergency_Call); &#x2F;&#x2F; 119Phone objPhone &#x3D; new Phone&#123;    PhoneNumber &#x3D; &quot;123456&quot;&#125;;Console.WriteLine(&quot;电话号码是&quot; + objPhone.PhoneNumber); &#x2F;&#x2F; 电话号码是123456objPhone.Dial(); &#x2F;&#x2F; 您正在拨打电话！objPhone.DialNumber(&quot;404404&quot;); &#x2F;&#x2F; 您正在拨打404404Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实例中定义了常量PhoneType、静态字段emergency_Call和静态方法EmergencyCall，对这些静态成员的使用方法是“类名.静态成员名”，不需要实例化；</li><li>类中还定义了如下实例成员：phoneNumber、有参数的Dial方法和无参数的Dial方法，使用的时候先要创建对象，以“对象名.实例成员名”的方式调用。</li></ul><h4 id="面向对象思想理解（OOP-Object-Oriented-Programming）"><a href="#面向对象思想理解（OOP-Object-Oriented-Programming）" class="headerlink" title="面向对象思想理解（OOP-Object Oriented Programming）"></a>面向对象思想理解（OOP-Object Oriented Programming）</h4><ul><li>万物皆为对象</li><li>程序是对象的集合，通过发送消息完成程序工作</li><li>每一个对象在内存中都有一个唯一的地址</li><li>对象是类的实例，类是对象的模板。</li></ul><h4 id="new-一个对象"><a href="#new-一个对象" class="headerlink" title="new 一个对象"></a>new 一个对象</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Phone objPhone &#x3D; new Phone()&#123;PhoneNumber &#x3D; &quot;12345&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Phone objPhone &#x3D; new Phone&#123;PhoneNumber &#x3D; &quot;12345&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="加括号与不加的区别"><a href="#加括号与不加的区别" class="headerlink" title="加括号与不加的区别"></a>加括号与不加的区别</h6><p>（1）加括号</p><ul><li><p>若括号为空，即无实参项，那么理解为调用默认构造函数；</p></li><li><p>若括号非空，即有实参项，可以理解为调用重载构造函数，或复合默认构造函数。</p></li></ul><p>（2）不加括号</p><p>调用默认构造函数，或复合默认构造函数。</p><h6 id="默认构造函数-与-复合默认构造函数的区别"><a href="#默认构造函数-与-复合默认构造函数的区别" class="headerlink" title="默认构造函数 与 复合默认构造函数的区别"></a>默认构造函数 与 复合默认构造函数的区别</h6><ul><li><p>默认构造函数：编译器会为每一个类默认提供一个构造函数，称之为默认构造函数。默认构造函数一般参数为空。</p></li><li><p>复合默认构造函数：一个由用户自定义的所有形式参数都赋有默认值的构造函数，称之为复合默认构造函数。</p></li></ul><p>两者联系：</p><ul><li><p>一个类中，若一旦有一个用户自定义构造函数，那么由编译器提供的默认构造函数就不再存在。用户自定义的构造函数为默认构造函数的重载版。</p></li><li><p>默认构造函数不复存在时，用户必须为这个类再自定义一个复合默认构造函数（选所有自定义构造函数其中之一，把形式参数均赋默认值即可）。</p></li></ul><p>不论自定义构造函数（即构造函数的重载版）有多少个，只允许有一个复合默认构造函数。</p>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-类与对象相关笔记2（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/10/c-xue-xi-bi-ji-lei-yu-dui-xiang-xiang-guan-bi-ji-2-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/10/c-xue-xi-bi-ji-lei-yu-dui-xiang-xiang-guan-bi-ji-2-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ul><li>构造函数是类的特殊方法成员，其名称和类名相同，主要用来完成对象的初始化。</li><li>C#通过new创建对象的过程实际上就是调用类的构造函数的过程，创建对象时调用构造函数对对象进行初始化。</li><li>每个类都有构造函数，如果没有定义，系统也会提供一个默认的构造函数，默认的构造函数一般不进行什么操作。</li><li>在访问一个类的时候，系统最先执行构造函数中的语句。</li><li>声明的构造函数是非静态的实例构造函数。构造函数也有静态的，静态构造函数用于初始化类中的静态字段成员。 <h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5></li><li>析构函数是对象销毁前释放所占用系统资源的类的成员。</li><li>析构函数的名字是在类名前面加一个符号“～”。析构函数不接受任何参数，也不返回任何值。</li><li>一个类只能有一个析构函数，析构函数不能手动调用，是系统自动调用的。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Point&#123;          public int X &#123; get; set; &#125; &#x2F;&#x2F; 定义属性X，得到和设置点的横坐标     public int Y &#123; get; set; &#125; &#x2F;&#x2F; 定义属性Y，得到和设置点的纵坐标     public static int z;     static Point() &#x2F;&#x2F; 定义静态构造函数     &#123;         z &#x3D; 100;     &#125;     public Point() &#x2F;&#x2F; 无参构造函数用于初始化     &#123;         X &#x3D; 0; Y &#x3D; 2; &#x2F;&#x2F; 初始化     &#125;     public Point(int val_x, int val_y) &#x2F;&#x2F; 有参数构造函数     &#123;         X &#x3D; val_x; Y &#x3D; val_y; &#x2F;&#x2F; 用指定的参数初始化X和Y     &#125;     ~Point() &#x2F;&#x2F; 析构函数     &#123;         Console.WriteLine(&quot;析构函数主要用于清理资源！&quot;);         Console.ReadKey();     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>Main方法测试代码<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(&quot;静态构造函数：&quot; + Point.z); &#x2F;&#x2F; 静态构造函数：100Point objPoint1 &#x3D; new Point();Console.WriteLine(&quot;无参构造函数演示&quot;);Console.WriteLine(&quot;X &#x3D; &quot; + objPoint1.X); &#x2F;&#x2F; X &#x3D; 0Console.WriteLine(&quot;Y &#x3D; &quot; + objPoint1.Y); &#x2F;&#x2F; Y &#x3D; 2Point objPoint2 &#x3D; new Point(80, 90);Console.WriteLine(&quot;有参构造函数演示&quot;);Console.WriteLine(&quot;X &#x3D; &quot; + objPoint2.X); &#x2F;&#x2F; X &#x3D; 80Console.WriteLine(&quot;Y &#x3D; &quot; + objPoint2.Y); &#x2F;&#x2F; Y &#x3D; 90Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5></li><li>C#定义方法时声明的参数称为形参（或称虚拟参数）,调用方法时传给形参的值称为实参。</li><li>参数传递类型有值传递与引用传递两种。值传递是C#默认的传递方式。</li><li>如果希望所调用的方法能更改实在参数的值，则必须使用ref或out关键字声明通过引用传递方式传递参数。</li><li>引用传递是把实在参数的地址传给形式参数，形式参数和实在参数指向同一个存储单元，对形式参数的改变就是对实在参数的改变。</li><li>out传递与ref类似，二者的区别是，ref要求参数在传递之前必须初始化，out则不要求初始化。</li></ul><h6 id="值传递示例"><a href="#值传递示例" class="headerlink" title="值传递示例"></a>值传递示例</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 定义值传递方法private void Swap(int num1, int num2) &#x2F;&#x2F; 交换数据的方法&#123;    int temp; &#x2F;&#x2F; 定义用于交换变量值得中间变量    temp &#x3D; num1; &#x2F;&#x2F; 将num1值赋值给中间变量temp    num1 &#x3D; num2; &#x2F;&#x2F; 将num2赋值给num1    num2 &#x3D; temp; &#x2F;&#x2F; 将中间变量存储的num1的值赋值给num2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int num1 &#x3D; 1;int num2 &#x3D; 2;Console.WriteLine(&quot;此实例演示值传递参数&quot;);Console.WriteLine(&quot;交换之前的字符串顺序为：num1-&#123;0&#125;, num2-&#123;1&#125;&quot;, num1, num2); &#x2F;&#x2F; 1   2Program objProgram &#x3D; new Program();objProgram.Swap(num1, num2);Console.WriteLine(&quot;交换之后的字符串顺序为：num1-&#123;0&#125;, num2-&#123;1&#125;&quot;, num1, num2); &#x2F;&#x2F; 1   2Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果显示并没有真正交换num1和num2两个变量的值，因为选择的是值传递的方法来传递参数。</p><h6 id="ref引用传递示例"><a href="#ref引用传递示例" class="headerlink" title="ref引用传递示例"></a>ref引用传递示例</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 定义引用传递方法private void Swap(ref int num1, ref int num2) &#x2F;&#x2F; 交换数据的方法&#123;    int temp; &#x2F;&#x2F; 定义用于交换变量值得中间变量    temp &#x3D; num1; &#x2F;&#x2F; 将num1值赋值给中间变量temp    num1 &#x3D; num2; &#x2F;&#x2F; 将num2赋值给num1    num2 &#x3D; temp; &#x2F;&#x2F; 将中间变量存储的num1的值赋值给num2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int num1 &#x3D; 1;int num2 &#x3D; 2;Console.WriteLine(&quot;此实例演示引用传递参数&quot;);Console.WriteLine(&quot;交换之前的字符串顺序为：num1-&#123;0&#125;, num2-&#123;1&#125;&quot;, num1, num2); &#x2F;&#x2F; 1   2Program objProgram &#x3D; new Program();objProgram.Swap(ref num1, ref num2);Console.WriteLine(&quot;交换之后的字符串顺序为：num1-&#123;0&#125;, num2-&#123;1&#125;&quot;, num1, num2); &#x2F;&#x2F; 2   1Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ref引用传递交换了两个变量的值，在使用ref方式传递参数时，定义和调用时都要使用ref关键字。</p><h6 id="out引用传递"><a href="#out引用传递" class="headerlink" title="out引用传递"></a>out引用传递</h6><ul><li>out关键字与ref关键字类似，也是声明引用传递参数的，但ref要求变量必须在传递之前对实在参数初始化。</li><li>尽管作为out参数传递的变量不需要在传递之前初始化，但需要调用方法在方法返回之前对out传递的参数赋值。</li><li>当希望方法返回多个值时，可以使用out方式，使用out参数的方法可以将变量用做返回类型，还可以将一个或多个对象作为out参数返回给调用方法。</li></ul><p>下面的例子使用out在一个方法调用中返回3个值。请注意，第3个参数所赋的值为null，这样能允许方法有选择地返回值。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">namespace PointClass&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            int value;            string str1, str2;            Console.WriteLine(&quot;此实例演示out引用传递&quot;);            Method(out int value, out string str1, out string str2);            Console.WriteLine(&quot;参数value的值是：&quot; + value); &#x2F;&#x2F; 参数value的值是：44            Console.WriteLine(&quot;参数str1的值是：&quot; + str1); &#x2F;&#x2F; 参数str1的值是：I&#39;ve been returned!            Console.WriteLine(&quot;参数str2的值是：&quot; + str2); &#x2F;&#x2F; 参数str2的值是：            Console.ReadKey();        &#125;        static void Method(out int i, out string s1, out string s2) &#x2F;&#x2F; 定义静态方法使用out进行参数的传递        &#123;            i &#x3D; 44;            s1 &#x3D; &quot;I&#39;ve been returned!&quot;;            s2 &#x3D; null;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-结构与类相关笔记（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/10/c-xue-xi-bi-ji-jie-gou-yu-lei-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/10/c-xue-xi-bi-ji-jie-gou-yu-lei-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h4 id="结构与类"><a href="#结构与类" class="headerlink" title="结构与类"></a>结构与类</h4><ul><li>结构和类相似，通常用来封装小型的相关变量组。</li><li>结构是一种值类型，通常创建结构要比创建类的速度快。如果需要一些紧凑循环，需要在其中创建大量的新数据结构，则应考虑使用结构而不是类。</li><li>在C#中，可以将结构看成轻量级的类。定义结构和定义类相似，采用struct进行定义，每个struct类型数据可以是常量、变量、构造函数、方法和属性等成员。</li></ul><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">&lt;访问修饰符&gt; struct结构名&#123;    &#x2F;&#x2F; 结构体定义&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用：通过声明结构体变量或使用new来实例化结构对象，然后通过“结构体变量.结构成员名”或“结构对象.结构成员”的方式来使用结构。</strong></p><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace StructTest&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student goodStu; &#x2F;&#x2F; 创建结构goodStu表示好学生            goodStu.stuNum &#x3D; &quot;20200409&quot;;            goodStu.stuName &#x3D; &quot;小明&quot;;            goodStu.stuAge &#x3D; 19;            goodStu.stuClass &#x3D; 1;            goodStu.stuGrade &#x3D; 100;            Console.WriteLine(&quot;结构演示：&quot;);            Console.WriteLine(&quot;三好学生：学号-&#123;0&#125;，姓名-&#123;1&#125;，年龄-&#123;2&#125;，班级-&#123;3&#125;，成绩-&#123;4&#125;&quot;, goodStu.stuNum, goodStu.stuName, goodStu.stuAge, goodStu.stuClass, goodStu.stuGrade);            goodStu.DoHomeWork(); &#x2F;&#x2F; 调用结构的方法            Console.ReadKey();            &#x2F;**             * 三好学生：学号-20200409，姓名-小明，年龄-19，班级-1，成绩-100             * I&#39;m doing homework!             *&#x2F;            Student normalStu &#x3D; new Student(&quot;20200410&quot;, &quot;小红&quot;, 19, 1, 80);            Console.WriteLine(&quot;普通学生：学号-&#123;0&#125;，姓名-&#123;1&#125;，年龄-&#123;2&#125;，班级-&#123;3&#125;，成绩-&#123;4&#125;&quot;, normalStu.stuNum, normalStu.stuName, normalStu.stuAge, normalStu.stuClass, normalStu.stuGrade);            normalStu.DoHomeWork();            Console.ReadKey();            &#x2F;**             * 普通学生：学号-20200410，姓名-小红，年龄-19，班级-1，成绩-80             * I&#39;m doing homework!             *&#x2F;        &#125;    &#125;    struct Student    &#123;        public string stuNum; &#x2F;&#x2F; 学号        public string stuName; &#x2F;&#x2F; 姓名        public int stuAge; &#x2F;&#x2F; 年龄        public int stuClass; &#x2F;&#x2F; 班级        public int stuGrade; &#x2F;&#x2F; 成绩        public Student(string stuNum, string stuName, int stuAge, int stuClass, int stuGrade) &#x2F;&#x2F; 结构的构造函数，用参数给结构中的成员赋值        &#123;            this.stuNum &#x3D; stuNum;            this.stuName &#x3D; stuName;            this.stuAge &#x3D; stuAge;            this.stuClass &#x3D; stuClass;            this.stuGrade &#x3D; stuGrade;        &#125;        public void DoHomeWork() &#x2F;&#x2F; 结构中的方法        &#123;            Console.WriteLine(&quot;I&#39;m doing homework!&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="结构与类的关系"><a href="#结构与类的关系" class="headerlink" title="结构与类的关系"></a>结构与类的关系</h5><p>类和结构实际上都是创建对象的模板，都可以包含构造函数、常数、字段、方法、属性、索引器和运算符等成员。</p><ul><li>结构是值类型，类是引用类型，在内存中结构是存储在栈上的值类型，类是存储在堆(heap)上的引用类型。</li><li>结构的构造函数和类的构造函数不同，结构不能包含显式的无参数构造函数，结构成员会自动初始化为它们的默认值。结构不能包含以下形式的初始值设定类：base（参数列表）。</li><li>对于结构中的实例字段成员，不能在声明时赋值初始化。</li><li>声明了结构类型后，可以使用new运算符创建构造对象，也可以不使用new关键字。如果不使用new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。</li><li>结构不支持继承，即一个结构不能从另一个结构或类继承，而且不能作为一个类的基类。</li></ul><h5 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h5><p>在大型项目、特殊部署时，可能需要把一个类、结构或接口放在几个文件中来处理。等到编译时，自动地把它们组合起来，成为一个完整的类，这是C# 分部类。</p><ul><li>类型特别大，不宜放在一个文件中实现。</li><li> 一个类型中的一部分代码为自动化工具生成的代码，不宜与自己编写的代码混合在一起。</li><li>需要多人合作编写一个类。</li></ul><p><strong>分部类是一个纯语言层的编译处理，不影响任何执行机制。<br>事实上C#编译器在编译的时候仍会将各个部分的局部类型合并成一个完整的类。C# 分部类是在class前面添加关键字partial来定义。</strong></p><p><strong>分部类中还可以声明分部方法，分部方法是将方法的定义和实现分隔开。在方法前面用partial关键字修饰的方法就是分部方法。</strong><br>例如，在一个文件中声明分部类Person的代码如下： </p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial class Person &#x2F;&#x2F; 分部类Person的部分代码&#123;public void DoWork()&#123;&#x2F;&#x2F; 定义方法，表示Person类的工作功能&#125;partial void Drink(); &#x2F;&#x2F; 定义分部方法，表示Person类的喝水功能&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在另一个文件中声明分部类Person</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial class Person &#x2F;&#x2F; 分部类Person的部分代码&#123;public void HaveDinner()&#123;&#x2F;&#x2F; 定义方法，表示Person类的吃晚饭功能&#125;partial void Drink()&#123;&#x2F;&#x2F; 实现分部方法代码&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分部方法隐式为private类型，不可使用public访问修饰符。分部方法不可有返回值。</p>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习笔记-继承相关笔记（读自C#从入门到精通 第2版）</title>
      <link href="/2020/04/10/c-xue-xi-bi-ji-ji-cheng-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/"/>
      <url>/2020/04/10/c-xue-xi-bi-ji-ji-cheng-xiang-guan-bi-ji-du-zi-c-cong-ru-men-dao-jing-tong-di-2-ban/</url>
      
        <content type="html"><![CDATA[<h5 id="继承的定义与使用"><a href="#继承的定义与使用" class="headerlink" title="继承的定义与使用"></a>继承的定义与使用</h5><p>继承是软件复用的一种形式。使用继承可以复用现有类的数据和行为，为其赋予新功能而创建出新类。复用能节省程序开发的时间，能重用经过实践检验和调试的高质量代码，提高系统的质量。</p><p>在现有类（称为直接基类、父类）上建立新类（称为派生类、子类）的处理过程称为继承。<br>派生类能自动获得基类的除了构造函数和析构函数以外的所有成员，可以在派生类中添加新的属性和方法扩展其功能。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法：&lt;访问修饰符&gt; class派生类名: 基类名&#123;&#x2F;&#x2F; 类的代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Person-cs（Person类）"><a href="#Person-cs（Person类）" class="headerlink" title="Person.cs（Person类）"></a>Person.cs（Person类）</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace InheritDemo&#123;    public class Person    &#123;        private string _id; &#x2F;&#x2F; 声明身份证号码字段 _id        public string Id &#x2F;&#x2F; 声明身份证号码属性ID        &#123;            get &#123; return _id; &#125; &#x2F;&#x2F; get访问器，获取身份证号码字段值            set &#123; _id &#x3D; value; &#125; &#x2F;&#x2F; set访问器，设置身份证号码字段值        &#125;        private string _name; &#x2F;&#x2F; 声明姓名字段        public string Name &#x2F;&#x2F; 声明姓名属性        &#123;            get &#123; return _name; &#125; &#x2F;&#x2F; get访问器，获取姓名字段值            set &#123; _name &#x3D; value; &#125; &#x2F;&#x2F; set访问器，设置身份证号码字段值        &#125;        private int _age; &#x2F;&#x2F; 声明年龄字段        public int Age &#x2F;&#x2F; 声明年龄属性        &#123;            get &#123; return _age; &#125;            set &#123; _age &#x3D; value; &#125;        &#125;        private string _gender; &#x2F;&#x2F; 声明性别字段        public string Gender &#x2F;&#x2F; 声明性别属性        &#123;            get &#123; return _gender; &#125;            set &#123; _gender &#x3D; value; &#125;        &#125;        public void Display() &#x2F;&#x2F; 基类的公有方法，用于输出Person对象的姓名、年龄与性别信息        &#123;            Console.WriteLine(&quot;&#123;0&#125;是&#123;1&#125;性，年龄为&#123;2&#125;&quot;, this._name, this._gender, this._age);        &#125;        public Person() &#x2F;&#x2F; 定义无参构造函数        &#123; &#125;        public Person(string name, int age, string gender) &#x2F;&#x2F; 定义有参构造函数        &#123;            _name &#x3D; name;            _age &#x3D; age;            _gender &#x3D; gender;        &#125;    &#125;    public class Student: Person&#x2F;&#x2F; 创建派生类，派生自Person类    &#123;        &#x2F;&#x2F; 定义派生类自己的属性        private string _class; &#x2F;&#x2F; 定义表示学生班级的字段_class        public string Class &#x2F;&#x2F; 定义设置和获取班级信息的属性Class        &#123;            get &#123; return _class; &#125;            set &#123; _class &#x3D; value; &#125;        &#125;        private string _department; &#x2F;&#x2F; 定义学生所属系的字段        public string Deparement &#x2F;&#x2F; 定义学生所属系的属性        &#123;            get &#123; return _department; &#125;            set &#123; _department &#x3D; value; &#125;        &#125;        private string _no; &#x2F;&#x2F; 定义学生学号        public string NO &#x2F;&#x2F; 定义学号的属性        &#123;            get &#123; return _no; &#125;            set &#123; _no &#x3D; value; &#125;        &#125;        public Student() &#x2F;&#x2F; 无参构造函数        &#123; &#125;        &#x2F;&#x2F; 定义派生类独有的方法Study，表示学生负有学习任务        public void Study()        &#123;            Console.WriteLine(&quot;好好学习，天天向上！&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Teacher-cs（Teacher类）"><a href="#Teacher-cs（Teacher类）" class="headerlink" title="Teacher.cs（Teacher类）"></a>Teacher.cs（Teacher类）</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace InheritDemo&#123;    class Teacher: Person    &#123;        private string _tid; &#x2F;&#x2F; 声明字段教师编号        public string Tid &#x2F;&#x2F; 定义教师编号属性        &#123;            get &#123; return _tid; &#125;            set &#123; _tid &#x3D; value; &#125;        &#125;        private string _course; &#x2F;&#x2F; 声明课程字段        public string Course &#x2F;&#x2F; 定义课程属性        &#123;            get &#123; return _course; &#125;            set &#123; _course &#x3D; value; &#125;        &#125;        &#x2F;&#x2F; 教师派生类的方法        public void Teaching()        &#123;            Console.WriteLine(&quot;正在上课中...&quot;);        &#125;    &#125;    class DoubleStudent: Student    &#123;        private string _sndBachelor; &#x2F;&#x2F; 声明第二学位名称字段        public string SndBachelor &#x2F;&#x2F; 声明第二学位属性        &#123;            get &#123; return _sndBachelor; &#125;            set &#123; _sndBachelor &#x3D; value; &#125;        &#125;        public DoubleStudent() &#x2F;&#x2F; 无参构造函数        &#123; &#125;        public void UsaBachelor() &#x2F;&#x2F; 定义方法        &#123;            Console.WriteLine(&quot;正在攻读xxx大学学位&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Program-cs"><a href="#Program-cs" class="headerlink" title="Program.cs"></a>Program.cs</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace InheritDemo&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;Person类：&quot;);            Person objPerson &#x3D; new Person(&quot;张三&quot;, 18, &quot;男&quot;);            objPerson.Display(); &#x2F;&#x2F; 调用Display显式对象信息     --&gt;     张三是男性，年龄为18            Console.WriteLine(&quot;Student类：&quot;);            Student objStudent &#x3D; new Student()            &#123;                Name &#x3D; &quot;李四&quot;,                Age &#x3D; 18,                Gender &#x3D; &quot;女&quot;            &#125;;            objStudent.Display(); &#x2F;&#x2F; 访问基类的Display方法     --&gt;     李四是女性，年龄为18            objStudent.Study(); &#x2F;&#x2F; 调用派生类方法      --&gt;     好好学习，天天向上！            Console.ReadKey();            Console.WriteLine(&quot;Teacher类&quot;);            Teacher objTeacher &#x3D; new Teacher()            &#123;                Name &#x3D; &quot;Mary&quot;,                Age &#x3D; 26,                Gender &#x3D; &quot;女&quot;            &#125;;            objTeacher.Display(); &#x2F;&#x2F; 访问基类的Display方法            objTeacher.Teaching(); &#x2F;&#x2F; 访问Teacher类的方法            Console.WriteLine(&quot;DoubleStudent类&quot;);            DoubleStudent objSpecial &#x3D; new DoubleStudent()            &#123;                Name &#x3D; &quot;Bliss&quot;,                Age &#x3D; 22,                Gender &#x3D; &quot;女&quot;            &#125;;            objSpecial.Display(); &#x2F;&#x2F; 访问Person类方法            objSpecial.Study(); &#x2F;&#x2F; 访问Student类方法            objSpecial.UsaBachelor(); &#x2F;&#x2F; 调用DoubleStudent类方法            Console.ReadKey();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h6><p>C#中的继承主要有以下3种特性：</p><ul><li>继承的可传递性<br>如果C从B中派生，B又从A中派生，那么C不仅继承了B中声明的成员，同样也继承了A中的成员。<br>如示例代码中DoubleStudent类的基类是Student，Student的基类是Person，因此DoubleStudent类可以继承Person类中的成员。<br>派生类是对基类的扩展，在派生类中可以添加新成员，但不能去除已经继承的成员。</li><li>继承的单一性<br>继承的单一性是指派生类只能从一个基类中继承，不能同时继承多个基类。C#不支持类的多重继承，也就是说儿子只能有一个亲生父亲，不能同时拥有多个亲生父亲。但可以通过接口实现多重继承。（具体后续学习研究）</li><li>继承中的访问修饰符</li></ul><table><thead><tr><th align="center">访问性修饰符</th><th align="center">类内部</th><th align="center">派生类</th></tr></thead><tbody><tr><td align="center">public（公有访问）</td><td align="center">访问不受限制</td><td align="center">不受限制</td></tr><tr><td align="center">protected（保护访问）</td><td align="center">访问仅限于包含类或从包含类派生的类型（本类成员和子类可以访问，实例不能访问）</td><td align="center">可以访问</td></tr><tr><td align="center">internal（内部访问）</td><td align="center">访问仅限于当前项目</td><td align="center">可以访问</td></tr><tr><td align="center">protected internal（内部保护访问）</td><td align="center">访问从包含类派生的当前项目或类型（仅限于本项目或子类）</td><td align="center">可以访问</td></tr><tr><td align="center">private（私有访问）</td><td align="center">访问仅限于包含类型（仅限于本类成员，子类、实例都不能访问）</td><td align="center">不可访问</td></tr></tbody></table><h5 id="this和base关键字"><a href="#this和base关键字" class="headerlink" title="this和base关键字"></a>this和base关键字</h5><p>基类中只有被public、protected、internal修饰的成员才可以被访问，这些成员包括任何基类的字段、属性、方法和索引器，但是基类的构造函数和析构函数是不能被继承的。如果要继承基类的构造函数，必须使用base关键字来实现。</p><p>C#中的base关键字代表基类，使用base关键字可以调用基类的构造函数、属性和方法。<br><strong>语法：派生类构造函数: base(参数列表)</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 给上述示例Student类添加一个有参构造函数public Student(string name, int age, string gender):base(name, age, gender) &#x2F;&#x2F; 构造函数&#123;&#x2F;&#x2F; 通过base(name, age, gender)调用基类的构造函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 使用base关键字调用基类方法语法base: 基类方法&#x2F;&#x2F; 示例:public Student(string name, int age, string gender) : base(name, age, gender) &#x2F;&#x2F; 调用基类的构造函数&#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相对于base来说，this关键字是引用类的当前实例。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public Person(string name, int age, string gender) &#x2F;&#x2F; 构造函数&#123;this._name &#x3D; name;this._age &#x3D; age;this._gender &#x3D; gender;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>派生类继承基类的属性和方法，从而使创建派生类变得简单，可实现代码的重用。</p><p><strong>基类对象可以引用派生类对象，也就是派生类对象可以赋值给基类对象变量。</strong><br>对这个特性可以这样理解：儿子继承于父亲，父亲也可以代表儿子处理事务，这就实现了基类对象引用派生类对象。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father()&#123;...&#125;class Son: Father&#123;...Public void CallDaddy() &#x2F;&#x2F; 派生类方法&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Son objSon &#x3D; new Son();Father objFather &#x3D; new Father();objFather &#x3D; objSon; &#x2F;&#x2F; 派生类对象objSon赋值给基类对象 objFather ((Son)objFather).CallDaddy(); &#x2F;&#x2F; 基类对象调用派生类的方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>父类对象引用子类实例时，注意要把父类型转为子类型，否则就会出错。</p>]]></content>
      
      
      <categories>
          
          <category> 读自C#从入门到精通 第2版 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
