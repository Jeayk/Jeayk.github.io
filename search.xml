<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法-7.2 散列表(中)</title>
      <link href="/2022/05/30/suan-fa-7-2-san-lie-biao-zhong/"/>
      <url>/2022/05/30/suan-fa-7-2-san-lie-biao-zhong/</url>
      
        <content type="html"><![CDATA[<p>散列表的查询效率并不能笼统地说成是 O(1)。它跟散列函数、装载因子、散列冲突等都有关系。如果散列函数设计得不好，或者装载因子过高，都可能导致散列冲突发生的概率升高，查询效率下降。</p><p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果使用的是基于链表的冲突解决方法，那这个时候，散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)。</p><p>如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直接点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到拒绝服务攻击（DoS）的目的。这也就是<strong>散列表碰撞攻击</strong>的基本原理。</p><p><span style="color: orange;">如何设计一个可以应对各种异常情况的工业级散列表，来避免在散列冲突的情况下，散列表性能的急剧下降，并且能抵抗散列碰撞攻击？</span></p><h4 id="如何设计散列函数"><a href="#如何设计散列函数" class="headerlink" title="如何设计散列函数"></a>如何设计散列函数</h4><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。</p><p><span style="color: red;">首先</span>，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能。</p><p><span style="color: red;">其次</span>，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p><p><span style="color: red;">实际工作中</span>，还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。</p><p><strong>散列函数的设计方法示例：</strong><br>第一个例子是学生运动会的例子，通过分析参赛编号的特征，把编号中的后两位作为散列值。还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，可以取手机号的后四位作为散列值。这种散列函数的设计方法，一般叫做“数据分析法”。</p><p>第二个例子是如何实现 Word 拼写检查功能。这里面的散列函数可以这样设计：将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单词 nice，转化出来的散列值就是下面这样：</p><pre class="line-numbers language-none"><code class="language-none">hash(&quot;nice&quot;)&#x3D;((&quot;n&quot; - &quot;a&quot;) * 26*26*26 + (&quot;i&quot; - &quot;a&quot;)*26*26 + (&quot;c&quot; - &quot;a&quot;)*26+ (&quot;e&quot;-&quot;a&quot;)) &#x2F; 78978<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等，只要了解就行，不需要全都掌握。</p><h4 id="装载因子过大怎么办？"><a href="#装载因子过大怎么办？" class="headerlink" title="装载因子过大怎么办？"></a>装载因子过大怎么办？</h4><p>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p><p>对于没有频繁插入和删除的静态数据集合来说，很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。</p><p>对于动态散列表来说，数据集合是频繁变动的，事先无法预估将要加入的数据个数，所以也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。这个时候，该如何处理呢？ —- <strong>动态扩容</strong></p><p>当装载因子过大时，跟数组、栈、队列的动态扩容一样，也可以对散列表进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。</p><p>针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以需要通过散列函数重新计算每个数据的存储位置。<br><img src="image-20220530212332841.png"></p><p>对于支持动态扩容的散列表，插入操作的时间复杂度是多少?</p><p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p><p>实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果对空间消耗非常敏感，可以在装载因子小于某个值之后，启动动态缩容。当然，如果更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p><p>当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当。如果太大，会导致冲突过多；如果太小，会导致内存浪费严重。</p><p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p><h4 id="如何避免低效的扩容"><a href="#如何避免低效的扩容" class="headerlink" title="如何避免低效的扩容"></a>如何避免低效的扩容</h4><p>大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，当装载因子已经到达阈值，需要先进行扩容，再插入数据。这个时候，插入数据就会变得很慢，甚至会无法接受。</p><p>举一个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表，很耗时。</p><p>如果业务代码直接服务于用户，尽管大部分情况下，插入一个数据的操作都很快，但是，极个别非常慢的插入操作，也会让用户崩溃。这个时候，“一次性”扩容的机制就不合适了。</p><p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，只申请新空间，但并不将老的数据搬移到新散列表中。</p><p>当有新数据要插入时，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。<br><img src="image-20220530212351296.png"><br>这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，先从新散列表中查找，如果没有找到，再去老的散列表中查找。</p><p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。</p><h4 id="如何选择冲突解决方法"><a href="#如何选择冲突解决方法" class="headerlink" title="如何选择冲突解决方法"></a>如何选择冲突解决方法</h4><h5 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1. 开放寻址法"></a>1. 开放寻址法</h5><p>开放寻址法的优点:<br>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。</p><p>开放寻址法的缺点：<br>用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p><p><span style="color: orange;">当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</span></p><h5 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2. 链表法"></a>2. 链表法</h5><p>首先，链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。</p><p>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p><p>链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</p><p>当然，如果存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小（4 个字节或者 8 个字节），那链表中指针的内存消耗在大对象面前就可以忽略了。</p><p>实际上，对链表法稍加改造，可以实现一个更加高效的散列表。那就是,将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。</p><p><span style="color: orange;">基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</span></p><h4 id="Java-中的-HashMap-分析"><a href="#Java-中的-HashMap-分析" class="headerlink" title="Java 中的 HashMap 分析"></a>Java 中的 HashMap 分析</h4><h5 id="1-初始大小"><a href="#1-初始大小" class="headerlink" title="1. 初始大小"></a>1. 初始大小</h5><p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能。</p><h5 id="2-装载因子和动态扩容"><a href="#2-装载因子和动态扩容" class="headerlink" title="2. 装载因子和动态扩容"></a>2. 装载因子和动态扩容</h5><p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p><h5 id="3-散列冲突解决方法"><a href="#3-散列冲突解决方法" class="headerlink" title="3. 散列冲突解决方法"></a>3. 散列冲突解决方法</h5><p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p><p>于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p><h5 id="4-散列函数"><a href="#4-散列函数" class="headerlink" title="4. 散列函数"></a>4. 散列函数</h5><p>散列函数的设计并不复杂，追求的是简单高效、分布均匀。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int hash(Object key) &#123;    int h &#x3D; key.hashCode()；    return (h ^ (h &gt;&gt;&gt; 16)) &amp; (capicity -1); &#x2F;&#x2F;capicity表示散列表的大小&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int hashCode() &#123;  int var1 &#x3D; this.hash;  if(var1 &#x3D;&#x3D; 0 &amp;&amp; this.value.length &gt; 0) &#123;    char[] var2 &#x3D; this.value;    for(int var3 &#x3D; 0; var3 &lt; this.value.length; ++var3) &#123;      var1 &#x3D; 31 * var1 + var2[var3];    &#125;    this.hash &#x3D; var1;  &#125;  return var1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何设计一个工业级的散列函数？"><a href="#如何设计一个工业级的散列函数？" class="headerlink" title="如何设计一个工业级的散列函数？"></a>如何设计一个工业级的散列函数？</h4><p>首先思考，<strong>何为一个工业级的散列表？工业级的散列表应该具有哪些特性？</strong></p><ul><li>支持快速地查询、插入、删除操作；</li><li>内存占用合理，不能浪费过多的内存空间；</li><li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</li></ul><p>如何实现这样一个散列表?</p><ul><li>设计一个合适的散列函数；</li><li>定义装载因子阈值，并且设计动态扩容策略；</li><li>选择合适的散列冲突解决方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-7.1 散列表(上)</title>
      <link href="/2022/05/11/suan-fa-7-1-san-lie-biao-shang/"/>
      <url>/2022/05/11/suan-fa-7-1-san-lie-biao-shang/</url>
      
        <content type="html"><![CDATA[<h4 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h4><p>散列表（Hash Table），平时也叫“哈希表”或者“Hash 表”。</p><p><strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p><p><span style="color: orange;">示例：</span><br>假如有 89 名选手参加学校运动会。为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码，比如051167，其中，前两位 05 表示年级，中间两位 11 表示班级，最后两位是选手的编号 1 到 89。</p><p>可以截取参赛编号的后两位作为数组下标，来存取选手信息数据。当通过参赛编号查询选手信息的时候，取参赛编号的后两位，作为数组下标，来读取数组中的数据，时间复杂度就是 O(1)。</p><p>这就是典型的<strong>散列思想</strong>。其中，参赛选手的编号叫做<strong>键</strong>（key）或者<strong>关键字</strong>，用它来标识一个选手。把参赛编号转化为数组下标的映射方法就叫作<strong>散列函数</strong>（或“Hash 函数”“哈希函数”），而散列函数计算得到的值就叫作<strong>散列值</strong>（或“Hash 值”“哈希值”）。<br><img src="image-20220511234736427.png"><br><span style="color: orange;">规律：</span><br>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当按照键值查询元素时，用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>散列函数在散列表中起着非常关键的作用，可以把散列函数定义成 **hash(key)**，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p><p>示例中的散列函数如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> key<span class="token punctuation">.</span>length    <span class="token comment">// 获取最后两位字符</span>    <span class="token keyword">const</span> lastTwo <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> lastTwo<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="color: red;">复杂化：</span><br>如果参赛选手的编号是随机生成的 6 位数字，又或者用的是 a 到 z 之间的字符串，该如何构造散列函数呢？</p><p><span style="color: orange;">三点散列函数设计的基本要求</span></p><ul><li>散列函数计算得到的散列值是一个非负整数</li><li>如果 key1 = key2，那 hash(key1) == hash(key2)</li><li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)<br>第三点理解：在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的MD5、SHA、CRC等哈希算法，也无法完全避免这种散列冲突。而且，因为数组的存储空间有限，也会加大散列冲突的概率。</li></ul><p>几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的，所以针对散列冲突问题，需要通过其他途径来解决。</p><h4 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h4><p>再好的散列函数也无法避免散列冲突。常用的散列冲突解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p><h5 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1.开放寻址法"></a>1.开放寻址法</h5><p><span style="color: orange;">核心思想：</span><br>如果出现了散列冲突，就重新探测一个空闲位置，将其插入。那如何重新探测新的位置呢？先了解一个比较简单的探测方法，<strong>线性探测</strong>（Linear Probing）。</p><p>当往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p><p>示例图如下：黄色的色块表示空闲位置，橙色的色块表示已经存储了数据。<br><img src="image-20220511234752121.png"><br>从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。先顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置；再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p><p>在散列表中查找元素的过程有点儿类似插入过程。通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。<br><img src="image-20220511234805001.png"><br>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。对于使用线性探测法解决冲突的散列表，删除操作稍微有些特别,不能单纯地把要删除的元素设置为空。</p><p><span style="color: red;">原因：</span>在查找的时候，一旦通过线性探测方法，找到一个空闲位置，就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。</p><p><span style="color: red;">如何解决：</span>可以将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。<br><img src="image-20220511234816339.png"><br><span style="color: red;">线性探测缺陷：</span>线性探测法其实存在很大问题。当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p><p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong>二次探测</strong>（Quadratic probing）和<strong>双重散列</strong>（Double hashing）。</p><p>所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……</p><p>所谓双重散列，意思就是不仅要使用一个散列函数，而是使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，会尽可能保证散列表中有一定比例的空闲槽位。用装载因子（load factor）来表示空位的多少。</p><p><span style="color: orange;">计算公式：</span></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">散列表的装载因子<span class="token operator">=</span>填入表中的元素个数<span class="token operator">/</span>散列表的长度<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h5 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2.链表法"></a>2.链表法</h5><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法要简单很多。如图所示，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素都放到相同槽位对应的链表中。<br><img src="image-20220511234831675.png"><br>当插入的时候，只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。那查找或删除操作的时间复杂度是多少呢？</p><p>实际上，这两个操作的时间复杂度跟链表的长度 k 成正比，也就是 O(k)。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>Word 文档中单词拼写检查功能是如何实现的？</p><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以可以用散列表来存储整个英文单词词典。</p><p>当用户输入某个英文单词时，拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，就可以轻松实现快速判断是否存在拼写错误。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-6. 跳表</title>
      <link href="/2022/05/10/suan-fa-6-tiao-biao/"/>
      <url>/2022/05/10/suan-fa-6-tiao-biao/</url>
      
        <content type="html"><![CDATA[<p>跳表是一种各方面性能都比较优秀的动态数据结构，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代<span style="color: orange;">红黑树</span>（Red-black tree）</p><h4 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h4><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。<br><img src="image-20220510013811931.png"><br>那怎么来提高查找效率呢？如下图所示，对链表建立一级“索引”，每两个结点提取一个结点到上一级，把抽出来的那一级叫做<strong>索引</strong>或<strong>索引层</strong>。 down 表示 down 指针，指向下一级结点。<br><img src="image-20220510013827853.png"><br>如果要查找某个结点，比如 16。可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点。</p><p><span style="color: red;">加一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。</span></p><p>跟前面建立第一级索引的方式相似，在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。<br><img src="image-20220510013837696.png"></p><p><span style="color: orange;">这种链表加多级索引的结构，就是跳表。</span></p><h4 id="用跳表查询到底有多快-时间复杂度"><a href="#用跳表查询到底有多快-时间复杂度" class="headerlink" title="用跳表查询到底有多快-时间复杂度"></a>用跳表查询到底有多快-时间复杂度</h4><p>如果链表里有 n 个结点，会有多少级索引？</p><p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，<strong>也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2k)。</strong></p><p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，可以得到 n/(2^h)=2，从而求得 h=log2n-1。<br><img src="image-20220510013849689.png"><br>如果包含原始链表这一层，整个跳表的高度就是 log2n。在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p><p>那这个 m 的值是多少呢？按照前面这种索引结构，每一级索引都最多只需要遍历 3 个结点，也就是说 m=3，为什么是 3 呢？</p><p>假设要查找的数据是 x，在第 k 级索引中，遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。<br><img src="image-20220510013859958.png"><br>m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，其实是基于单链表实现了二分查找。<strong>这种查询效率的提升，前提是建立了很多级索引</strong></p><h4 id="跳表是不是很浪费内存？-空间复杂度"><a href="#跳表是不是很浪费内存？-空间复杂度" class="headerlink" title="跳表是不是很浪费内存？-空间复杂度"></a>跳表是不是很浪费内存？-空间复杂度</h4><p>比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。</p><p>假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果把每层索引的结点数写出来，就是一个等比数列。<br><img src="image-20220510013909469.png"><br>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，需要额外再用接近 n 个结点的存储空间。</p><h5 id="如何降低索引占用的内存空间"><a href="#如何降低索引占用的内存空间" class="headerlink" title="如何降低索引占用的内存空间"></a>如何降低索引占用的内存空间</h5><p>前面都是每两个结点抽一个结点到上级索引，如果每三个结点或五个结点，抽一个结点到上级索引呢：<br><img src="image-20220510013918138.png"><br>从图中可以看出，第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。为了方便计算，假设最高一级的索引结点个数是 1。把每级索引的结点个数都写下来，也是一个等比数列。<br><img src="image-20220510013928273.png"></p><p>通过等比数列求和公式，总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p><p><span style="color: red;">实际上</span>，在软件开发中，不必太在意索引占用的额外空间。在讲数据结构和算法时，习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</p><h4 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h4><p>跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。</p><h5 id="如何在跳表中插入一个数据，以及它是如何做到-O-logn-的时间复杂度"><a href="#如何在跳表中插入一个数据，以及它是如何做到-O-logn-的时间复杂度" class="headerlink" title="如何在跳表中插入一个数据，以及它是如何做到 O(logn) 的时间复杂度"></a>如何在跳表中插入一个数据，以及它是如何做到 O(logn) 的时间复杂度</h5><p>在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是 O(1)。但是，这里为了保证原始链表中数据的有序性，需要先找到要插入的位置，这个查找操作就会比较耗时。</p><p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，查找某个结点的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。<br><img src="image-20220510013941113.png"><br><strong>删除操作</strong><br>如果这个结点在索引中也有出现，除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果用的是双向链表，就不需要考虑这个问题了。</p><h4 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h4><p>当不停地往跳表中插入数据时，如果不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。<br><img src="image-20220510013950666.png"><br>作为一种动态数据结构，需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p><p><strong>跳表是通过随机函数来维护“平衡性”。</strong></p><p>当往跳表中插入数据的时候，可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p><p>通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，就将这个结点添加到第一级到第 K 级这 K 级索引中。<br><img src="image-20220510014000397.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-5.2 几种二分查找的变形问题</title>
      <link href="/2022/05/06/suan-fa-5-2-ji-chong-er-fen-cha-zhao-de-bian-xing-wen-ti/"/>
      <url>/2022/05/06/suan-fa-5-2-ji-chong-er-fen-cha-zhao-de-bian-xing-wen-ti/</url>
      
        <content type="html"><![CDATA[<h4 id="四种常见的二分查找变形问题"><a href="#四种常见的二分查找变形问题" class="headerlink" title="四种常见的二分查找变形问题"></a>四种常见的二分查找变形问题</h4><ul><li>查找第一个值等于给定值的元素</li><li>查找最后一个值等于给定值的元素</li><li>查找第一个大于等于给定值的元素</li><li>查找最后一个小于等于给定值得元素</li></ul><h4 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h4><p>有序数据集合中存在重复的数据，希望找到第一个值等于给定值的数据。</p><p><span style="color: orange;">例子：</span><br>有序数组 [1, 3, 4, 5, 6, 8, 8, 8, 11, 18]，查找第一个等于 8 的数据，也就是下标是 5 的元素。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 查找第一个值等于给定值的元素</span><span class="token keyword">const</span> <span class="token function-variable function">bsearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">let</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// >> 位运算符 num >> n 表示为 num / 2ⁿ</span>        <span class="token keyword">const</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!==</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid            <span class="token keyword">else</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bsearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是要找的；如果 mid 不等于 0，但 arr[mid]的前一个元素 arr[mid-1]不等于 target，那也说明 arr[mid]就是要找的第一个值等于给定值的元素。</p><p>如果经过检查之后发现 arr[mid]前面的一个元素 arr[mid-1]也等于 target，那说明此时的 arr[mid]肯定不是要查找的第一个值等于给定值的元素，更新 high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。</p><h4 id="变体二：查找最后一个值等于给定值的元素"><a href="#变体二：查找最后一个值等于给定值的元素" class="headerlink" title="变体二：查找最后一个值等于给定值的元素"></a>变体二：查找最后一个值等于给定值的元素</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 查找最后一个值等于给定值的元素</span><span class="token keyword">const</span> <span class="token function-variable function">bsearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">let</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// >> 位运算符 num >> n 表示为 num / 2ⁿ</span>        <span class="token keyword">const</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">===</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!==</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid            <span class="token keyword">else</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bsearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 arr[mid]这个元素已经是数组中的最后一个元素了，那它肯定是要找的；如果 arr[mid]的后一个元素 arr[mid+1]不等于 target，那也说明 arr[mid]就是要找的最后一个值等于给定值的元素。</p><p>如果经过检查之后，发现 arr[mid]后面的一个元素 arr[mid+1]也等于 target，那说明当前的这个 arr[mid]并不是最后一个值等于给定值的元素，更新 low=mid+1，因为要找的元素肯定出现在[mid+1, high]之间。</p><h4 id="变体三：查找第一个大于等于给定值的元素"><a href="#变体三：查找第一个大于等于给定值的元素" class="headerlink" title="变体三：查找第一个大于等于给定值的元素"></a>变体三：查找第一个大于等于给定值的元素</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 查找第一个大于等于给定值的元素</span><span class="token keyword">const</span> <span class="token function-variable function">bsearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">let</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// >> 位运算符 num >> n 表示为 num / 2ⁿ</span>        <span class="token keyword">const</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid            <span class="token keyword">else</span> high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bsearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于 arr[mid]大于等于给定值 target 的情况，要先看下这个 arr[mid]是不是要找的第一个值大于等于给定值的元素。如果 arr[mid]前面已经没有元素，或者前面一个元素小于要查找的值 target，那 arr[mid]就是要找的元素。</p><p>如果 arr[mid-1]也大于等于要查找的值 target，那说明要查找的元素在[low, mid-1]之间，所以需要将 high 更新为 mid-1。</p><h4 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 查找最后一个小于等于给定值的元素</span><span class="token keyword">const</span> <span class="token function-variable function">bsearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">let</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// >> 位运算符 num >> n 表示为 num / 2ⁿ</span>        <span class="token keyword">const</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">===</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> mid            <span class="token keyword">else</span> low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bsearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="假设有-12-万条这样的-IP-区间与归属地的对应关系，如何快速定位出一个-IP-地址的归属地？"><a href="#假设有-12-万条这样的-IP-区间与归属地的对应关系，如何快速定位出一个-IP-地址的归属地？" class="headerlink" title="假设有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地？"></a><span style="color: orange;">假设有 12 万条这样的 IP 区间与归属地的对应关系，如何快速定位出一个 IP 地址的归属地？</span></h5><p>如果 IP 区间与归属地的对应关系不经常更新，可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。</p><p><span style="color: orange;">如何来排序呢？</span></p><p>IP 地址可以转化为 32 位的整型数。所以，可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。然后，这个问题就可以转化为第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。</p><p>当要查询某个 IP 归属地时，可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，就取出对应的归属地显示；如果不在，就返回未查找到。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-5. 1 二分查找</title>
      <link href="/2022/05/05/suan-fa-5-1-er-fen-cha-zhao/"/>
      <url>/2022/05/05/suan-fa-5-1-er-fen-cha-zhao/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找（Binary-Search）"><a href="#二分查找（Binary-Search）" class="headerlink" title="二分查找（Binary Search）"></a>二分查找（Binary Search）</h4><p><strong>例：</strong><br>假设有 10 个订单，订单金额分别是：8，11，19，23，27，33，45，55，67，98。是否存在金额等于 19 元的订单，如果存在，则返回订单数据，如果不存在则返回 null。</p><p><img src="image-20220505235236901.png"><br>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。<br><img src="image-20220505235251043.png"></p><p>这是一个等比数列，其中 n/2^k=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 n/2k=1，可以求得 k=log2n，所以时间复杂度就是 O(logn)。</p><p>二分查找是时间复杂度为 O(logn) 的算法之一，除此之外还有堆、二叉树的操作等等，它们的时间复杂度也是 O(logn)。O(logn) 这种对数时间复杂度是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效。</p><p>因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，大约是 42 亿。也就是说，如果在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。</p><p>用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高。指数时间复杂度的算法在大规模数据面前是无效的。</p><h4 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h4><p>最简单的情况就是<strong>有序数组中不存在重复元素</strong>，在其中用二分查找值等于给定值的数据。</p><h5 id="循环实现"><a href="#循环实现" class="headerlink" title="循环实现"></a>循环实现</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 二分查找 数组必须有序，不存在重复</span><span class="token comment">// 二分查找 数组必须有序，不存在重复</span><span class="token keyword">const</span> <span class="token function-variable function">biaryFind</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">let</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">+</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">===</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> mid        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">biaryFind</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">biaryFind</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 14</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">biaryFind</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="容易出错的-3-个地方"><a href="#容易出错的-3-个地方" class="headerlink" title="容易出错的 3 个地方"></a>容易出错的 3 个地方</h5><ul><li><strong>循环退出条件</strong>: <strong>是 low&lt;=high，而不是 low</strong></li><li><strong>mid的取值</strong>：实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)，因为相比除法运算来说，计算机处理位运算要快得多</li><li><strong>low 和 high 的更新</strong>：low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。</li></ul><h5 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">bSearch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">return</span> <span class="token function">bSearchInternally</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">bSearchInternally</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">,</span> target</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">></span> high<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">const</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">===</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> mid    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">bSearchInternally</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">bSearchInternally</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">56</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bSearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 6</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bSearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">102</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 14</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bSearch</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h4><h5 id="1-二分查找依赖的是顺序表结构，简单点说就是数组"><a href="#1-二分查找依赖的是顺序表结构，简单点说就是数组" class="headerlink" title="1. 二分查找依赖的是顺序表结构，简单点说就是数组"></a>1. 二分查找依赖的是顺序表结构，简单点说就是数组</h5><p>二分查找算法需要按照下标随机访问元素，如果换成其他数据结构，比如链表，数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)，用链表的话，二分查找的时间复杂就会变得很高。</p><h5 id="2-二分查找针对的是有序数据"><a href="#2-二分查找针对的是有序数据" class="headerlink" title="2. 二分查找针对的是有序数据"></a>2. 二分查找针对的是有序数据</h5><p>如果数据没有序，需要先排序。排序的时间复杂度最低是 O(nlogn)。所以，如果针对的是一组静态的数据，没有频繁地插入、删除，可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p><p><span style="color: red;">但是</span>，如果数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p><p>所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。</p><h5 id="3-数据量太小不适合二分查找。"><a href="#3-数据量太小不适合二分查找。" class="headerlink" title="3. 数据量太小不适合二分查找。"></a>3. 数据量太小不适合二分查找。</h5><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。</p><p><span style="color: red;">例外情况</span>：如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p><h5 id="4-数据量太大也不适合二分查找"><a href="#4-数据量太大也不适合二分查找" class="headerlink" title="4. 数据量太大也不适合二分查找"></a>4. 数据量太大也不适合二分查找</h5><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><p>注意“<span style="color: red;">连续</span>”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-4.4 排序优化</title>
      <link href="/2022/04/20/suan-fa-4-4-pai-xu-you-hua/"/>
      <url>/2022/04/20/suan-fa-4-4-pai-xu-you-hua/</url>
      
        <content type="html"><![CDATA[<h4 id="如何选择合适的排序算法"><a href="#如何选择合适的排序算法" class="headerlink" title="如何选择合适的排序算法"></a>如何选择合适的排序算法</h4><p>几种排序算法的比较：<br><img src="image-20220420223302619.png"></p><p>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p><p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n²) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p><p>时间复杂度是 O(nlogn) 的排序算法包括：归并排序、快速排序、堆排序…</p><p>使用归并排序的情况其实并不多，快排在最坏情况下的时间复杂度是 O(n²)，而归并排序可以做到平均情况、最坏情况下的时间复杂度都是 O(nlogn)，但是归并排序并不是原地排序算法，空间复杂度是 O(n)。例如要排序 100MB 的数据，除了数据本身占用的内存之外，排序算法还要额外再占用 100MB 的内存空间，空间耗费直接翻倍。</p><h4 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h4><p>为什么最坏情况下快速排序的时间复杂度是 O(n²) ？</p><p>如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n²)。<span style="color: orange;">这种 O(n²) 时间复杂度出现的主要原因还是因为分区点选得不够合理。</span></p><p>最理想的分区点是：<span style="color: orange;">被分区点分开的两个分区中，数据的数量差不多。</span></p><p><span style="color: red">两个比较常用、比较简单的分区算法：</span></p><h5 id="1-三数取中法"><a href="#1-三数取中法" class="headerlink" title="1. 三数取中法"></a>1. 三数取中法</h5><p>从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p><h5 id="2-随机法"><a href="#2-随机法" class="headerlink" title="2. 随机法"></a>2. 随机法</h5><p>每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n²) 的情况，出现的可能性不大。</p><p>快速排序是用递归来实现的，递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们种解决办法：第一种是限制递归深度。一旦递归过深，超过了事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p><h4 id="举例分析排序函数-qsort"><a href="#举例分析排序函数-qsort" class="headerlink" title="举例分析排序函数-qsort()"></a>举例分析排序函数-qsort()</h4><p><strong>qsort() 会优先使用归并排序来排序输入数据。</strong></p><p>因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，用空间换时间。</p><p>但如果数据量太大，如排序 100MB 的数据，再用归并排序就不合适了。所以，<strong>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。</strong></p><p>qsort() 用“三数取中法”选择快速排序算法的分区点。</p><p>递归太深会导致堆栈溢出的问题，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的。</p><p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序。因为：<strong>在小规模数据面前，O(n²) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</strong>分析如下：</p><p>算法的性能可以通过时间复杂度来分析，但是，这种复杂度分析是比较偏理论的，如果深究的话，实际上时间复杂度并不等于代码实际的运行时间。</p><p>时间复杂度代表的是一个增长趋势，如果画成增长曲线图，会发现 O(n²) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些。但是在大 O 复杂度表示法中，会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。</p><p>假设 k=1000，c=200，当对小规模数据（比如 n=100）排序时，n²的值实际上比 knlogn+c 还要小。</p><pre class="line-numbers language-none"><code class="language-none">knlogn+c &#x3D; 1000 * 100 * log100 + 200 远大于10000n^2 &#x3D; 100*100 &#x3D; 10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以，对于小规模数据的排序，O(n²) 的排序算法并不一定比 O(nlogn) 排序算法执行的时间长。对于小数据量的排序，选择比较简单、不需要递归的插入排序算法。</p><p>在 qsort() 插入排序的算法实现中，也利用了哨兵来简化代码，提高执行效率的技巧。虽然哨兵可能只是少做一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能的优化要做到极致。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-4.3 基数排序</title>
      <link href="/2022/04/14/suan-fa-4-3-ji-shu-pai-xu/"/>
      <url>/2022/04/14/suan-fa-4-3-ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h4><p>假设有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，有什么比较快速的排序方法呢？</p><ul><li>快排，时间复杂度可以做到 O(nlogn)；</li><li>手机号码有 11 位，范围太大，桶排序、计数排序不适合</li><li>基数排序…</li></ul><p><strong>思路</strong>：假设要比较两个手机号码 a，b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。</p><p>借助稳定排序算法，先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。</p><p>以字符串排序为例，基数排序过程分解图：<br><img src="image-20220414220629556.png"></p><p>按照每位来排序的排序算法要是稳定的，否则这个实现思路就是不正确的。因为如果是非稳定排序算法，那最后一次排序只会考虑最高位的大小顺序，完全不管其他位的大小关系，那么低位的排序就完全没有意义了。</p><p>根据每一位来排序，可以用桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p><p><span style="color: orange;">实际上，有时候要排序的数据并不都是等长的，对于这种不等长的数据，基数排序还适用吗？</span></p><p>可以把所有的单词补齐到相同长度，位数不够的可以在后面补“0”，因为根据ASCII 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><span style="color: orange;">基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</span> </p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-4.2复杂度O(n)的排序-计数排序</title>
      <link href="/2022/04/08/suan-fa-4-2-fu-za-du-o-n-de-pai-xu-ji-shu-pai-xu/"/>
      <url>/2022/04/08/suan-fa-4-2-fu-za-du-o-n-de-pai-xu-ji-shu-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p><span style="color: orange">示例：</span><br>假设有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8]中，它们分别是：2，5，3，0，2，3，0，3。</p><p>考生的成绩从 0 到 5 分，使用大小为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考生，而是对应的考生个数。只需要遍历一遍考生分数，就可以得到 C[6]的值。<br><img src="image-20220408011412988.png"></p><p>如图所示，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。</p><p><img src="image-20220408011432639.png"></p><p>如何快速计算出每个分数的考生在有序数组中对应的存储位置？</p><p>思路： 对 C[6]数组顺序求和，C[6]存储的数据就变成了下面这样子。C[k]里存储小于等于分数 k 的考生个数。</p><p><img src="image-20220408011446634.png"></p><p>从后到前依次扫描数组 A。比如，当扫描到 3 时，可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3]要减 1，变成 6。</p><p>以此类推，当扫描到第 2 个分数为 3 的考生的时候，就会把它放入数组 R 中的第 6 个元素的位置（也就是下标为 5 的位置）。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了。</p><p><img src="image-20220408011500355.png"></p><p><span style="color: orange">实现代码：</span></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 计数排序</span><span class="token keyword">const</span> <span class="token function-variable function">countingSort</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">const</span> max <span class="token operator">=</span> <span class="token function">findMaxVal</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">const</span> counts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>max <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment">// 计算每个元素的个数，放入到counts桶中</span>    <span class="token comment">// counts下标是元素，值是元素个数</span>    arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">element</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// if (!counts[element]) &#123;</span>        <span class="token comment">//     counts[element] = 0</span>        <span class="token comment">// &#125;</span>        counts<span class="token punctuation">[</span>element<span class="token punctuation">]</span><span class="token operator">++</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">// counts下标是元素，值是元素个数</span>    <span class="token comment">// 例如：arr: [6, 4, 3, 1], counts: [0, 1, 0, 1, 1, 0, 1]</span>    <span class="token comment">// i是元素，count是元素个数</span>    <span class="token keyword">let</span> sortedIndex <span class="token operator">=</span> <span class="token number">0</span>    counts<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            arr<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span> <span class="token operator">=</span> i            sortedIndex<span class="token operator">++</span>            count<span class="token operator">--</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">findMaxVal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span> max <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> max<span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token function">countingSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// [0, 2, 6, 8, 9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用另外一个数组来计数的实现方式进行排序，因此这种排序算法叫<strong>计数排序</strong>。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p><p><span style="color: orange">示例：</span>如果考生成绩精确到小数后一位，就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那就需要先对每个数据都加 1000，转化成非负整数。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-4.1复杂度O(n)的排序-桶排序</title>
      <link href="/2022/04/06/suan-fa-4-1-fu-za-du-o-n-de-pai-xu-tong-pai-xu/"/>
      <url>/2022/04/06/suan-fa-4-1-fu-za-du-o-n-de-pai-xu-tong-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h4><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。<br><img src="image-20220406215000617.png"></p><p><strong>桶排序的时间复杂度为什么是 O(n)？</strong></p><p>如果要排序的数据有 n 个，把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><p><strong>桶排序能否替代其他排序算法？</strong></p><p>不能，因为桶排序对要排序数据的要求是非常苛刻的。</p><p>首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p><p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p><h5 id="桶排序比较适合用在外部排序中"><a href="#桶排序比较适合用在外部排序中" class="headerlink" title="桶排序比较适合用在外部排序中"></a>桶排序比较适合用在外部排序中</h5><p>所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><hr><p><span style="color: orange;">示例：</span> 有 10GB 的订单数据，希望按订单金额（假设金额都是正整数）进行排序，但内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？如何借助桶排序的处理思想来解决这个问题。</p><p>可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后得到，订单金额最小是 1 元，最大是 10 万元。将所有订单根据金额划分到 100 个桶里，第一个桶存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。</p><p>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。</p><p>但是订单金额不一定是均匀分布，针对这些划分之后还是比较大的文件，可以继续划分，比如，订单金额在 1 元到 1000 元之间的比较多，就将这个区间继续划分为 10 个小区间，1 元到 100 元，101 元到 200 元，201 元到 300 元….901 元到 1000 元。如果划分之后，101 元到 200 元之间的订单还是太多，无法一次性读入内存，那就继续再划分，直到所有的文件都能读入内存为止。</p><hr><h5 id="桶排序代码"><a href="#桶排序代码" class="headerlink" title="桶排序代码"></a>桶排序代码</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/** * 思路：将数组中的数据，按桶进行划分，将相邻的数据划分在同一个桶里 * 每个桶用插入排序算法（或者快速排序）进行排序 * 最后整合每个桶中的数据 * */</span><span class="token keyword">const</span> <span class="token function-variable function">bucketSort</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> bucketSize <span class="token operator">=</span> <span class="token number">5</span></span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr    <span class="token keyword">const</span> buckets <span class="token operator">=</span> <span class="token function">createBuckets</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> bucketSize<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token function">sortBuckets</span><span class="token punctuation">(</span>buckets<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">createBuckets</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> bucketSize</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> minVal <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> maxVal <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment">// 遍历数组，找到数组最小值与数组最大值</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            minVal <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> maxVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            maxVal <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 根据最小值、最大值、桶的大小，计算得到的桶的个数</span>    <span class="token keyword">const</span> bucketCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxVal <span class="token operator">-</span> minVal<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment">// 建立一个二维数组，将桶放入buckets中</span>    <span class="token keyword">const</span> buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 计算每一个值应该放在哪一个桶中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> bucketIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minVal<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span>        buckets<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> buckets<span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">sortBuckets</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">buckets</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> sortedArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> buckets<span class="token punctuation">.</span>length    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">insertSort</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            sortedArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> sortedArr<span class="token punctuation">&#125;</span><span class="token comment">// 插入排序</span><span class="token keyword">const</span> <span class="token function-variable function">insertSort</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> value <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j<span class="token operator">--</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    i<span class="token operator">++</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'排序前： '</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'排序后：'</span><span class="token punctuation">,</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-3.2 复杂度O(nlogn)的排序-快速排序</title>
      <link href="/2022/04/01/suan-fa-3-2-fu-za-du-o-nlogn-de-pai-xu-kuai-su-pai-xu/"/>
      <url>/2022/04/01/suan-fa-3-2-fu-za-du-o-nlogn-de-pai-xu-kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="排序算法（Quicksort）"><a href="#排序算法（Quicksort）" class="headerlink" title="排序算法（Quicksort）"></a>排序算法（Quicksort）</h4><p>快速排序习惯性简称为快排，快排利用的也是分治思想。</p><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>如果要排序数组中下标从 p 到 r 之间的一组数据，选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p><p>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。<br><img src="image-20220401011302238.png"></p><p>根据分治、递归的处理思想，可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 递推公式：quick_sort(p…r) &#x3D; quick_sort(p…q-1) + quick_sort(q+1… r)&#x2F;&#x2F; 终止条件：p &gt;&#x3D; r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>递推公式转化成递归伪代码</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 快速排序，A是数组，n是数组大小</span><span class="token function">quick_sort</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">quick_sort_c</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 快速排序递归函数，p, r为下标</span><span class="token function">quick_sort_c</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> r</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">const</span> q <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token comment">// 获取分区点</span>    <span class="token function">quick_sort_c</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token function">quick_sort_c</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>partition() 分区函数是随机选择一个元素作为 pivot（一般情况下，可以选择 p 到 r 区间的最后一个元素），然后对 A[p…r]分区，函数返回 pivot 的下标。</p><p>如果不考虑空间消耗的话，partition() 分区函数可以写得非常简单。申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p….r]。<br><img src="image-20220401011318215.png"><br>按照这种思路实现的话，partition() 函数需要很多额外的内存空间，所以快排就不是原地排序算法了。如果希望快排是原地排序算法，那它的空间复杂度得是 O(1)，那 partition() 分区函数就不能占用太多额外的内存空间，就需要在 A[p…r]的原地完成分区操作。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 原地分区操作伪代码</span><span class="token function">partition</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> r</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> pivot <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>    <span class="token keyword">let</span> i <span class="token operator">=</span> p    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> p<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            swap <span class="token constant">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">with</span> <span class="token constant">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token comment">/** swap 为交换A[i]与A[j]，即：            const temp = A[i]            A[i] = A[j]            A[j] = temp            */</span>            i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    swap <span class="token constant">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">with</span> <span class="token constant">A</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span>    <span class="token keyword">return</span> i<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>图解：</strong><br><img src="image-20220401011338454.png"></p><p><strong>完整代码实现：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 交换</span><span class="token keyword">const</span> <span class="token function-variable function">swap</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">&#125;</span><span class="token comment">// 获取 pivot 交换完后的index</span><span class="token keyword">const</span> <span class="token function-variable function">partition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> pivotVal <span class="token operator">=</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span>    <span class="token keyword">let</span> startIndex <span class="token operator">=</span> left    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivotVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> startIndex<span class="token punctuation">)</span>            startIndex<span class="token operator">++</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> startIndex<span class="token punctuation">,</span> right<span class="token punctuation">)</span>    <span class="token keyword">return</span> startIndex<span class="token punctuation">&#125;</span><span class="token comment">// 快排</span><span class="token keyword">const</span> <span class="token function-variable function">quickSort</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> pivot <span class="token operator">=</span> right        <span class="token keyword">let</span> partitionIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> left <span class="token operator">?</span> left <span class="token operator">:</span> partitionIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> right <span class="token operator">?</span> right <span class="token operator">:</span> partitionIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> testArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    testArr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    i<span class="token operator">++</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'unsort: '</span><span class="token punctuation">,</span> testArr<span class="token punctuation">)</span><span class="token comment">/** unsort:  [    14, 57, 69, 21, 10,    18, 31, 20, 86, 78 ] * */</span><span class="token function">quickSort</span><span class="token punctuation">(</span>testArr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sort: '</span><span class="token punctuation">,</span> testArr<span class="token punctuation">)</span><span class="token comment">/**sort:  [    10, 14, 18, 20, 21,    31, 57, 69, 78, 86] * */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p><h5 id="快排与归并的区别"><a href="#快排与归并的区别" class="headerlink" title="快排与归并的区别"></a>快排与归并的区别</h5><p><img src="image-20220401011352962.png"></p><ul><li><p>归并排序的处理过程是由下到上的，先处理子问题，然后再合并;</p><p>而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。</p></li><li><p>归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法，因为合并函数无法在原地执行。</p><p>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题。</p></li></ul><h5 id="快排性能分析"><a href="#快排性能分析" class="headerlink" title="快排性能分析"></a>快排性能分析</h5><p>快排是一种原地、不稳定的排序算法。快排也是用递归来实现的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)。</p><pre class="line-numbers language-none"><code class="language-none">T(1) &#x3D; C；   &#x2F;&#x2F; n&#x3D;1时，只需要常量级的执行时间，所以表示为C。T(n) &#x3D; 2*T(n&#x2F;2) + n； n&gt;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>公式成立的前提是每次分区操作，选择的 pivot 都很合适，正好能将大区间对等地一分为二。但实际上这种情况是很难实现的。</p><p>总的来说，T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。</p><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。正因为此，它也没有快排应用广泛。</p><p>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n2) 的概率非常小，可以通过合理地选择 pivot 来避免这种情况。</p><h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>快排的思想获取数组第K大的数据</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 快排的思想查找第K大的数字</span><span class="token keyword">const</span> <span class="token function-variable function">kThNum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    k <span class="token operator">=</span> n <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span>    <span class="token comment">// 获取分区点</span>    <span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token function">parttition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">!==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            p <span class="token operator">=</span> <span class="token function">parttition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            p <span class="token operator">=</span> <span class="token function">parttition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> arr<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">parttition</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> i <span class="token operator">=</span> start    <span class="token keyword">let</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>end<span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> start<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>            i <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> end<span class="token punctuation">)</span>    <span class="token keyword">return</span> i<span class="token punctuation">&#125;</span><span class="token keyword">const</span> <span class="token function-variable function">swap</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> j<span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">const</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">&#125;</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">kThNum</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-3.1 复杂度O(nlogn)的排序-归并排序</title>
      <link href="/2022/03/31/suan-fa-3-1-fu-za-du-o-nlogn-de-pai-xu-gui-bing-pai-xu/"/>
      <url>/2022/03/31/suan-fa-3-1-fu-za-du-o-nlogn-de-pai-xu-gui-bing-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><p><img src="image-20220331003948693.png"></p><p>归并排序使用的是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧。</strong></p><p><strong>用递归代码来实现归并排序</strong></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 递推公式递推公式：merge_sort(p…r) &#x3D; merge(merge_sort(p…q), merge_sort(q+1…r))终止条件：p &gt;&#x3D; r 不用再继续分解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 伪代码理解</span><span class="token comment">// 归并排序算法，A为数组，n为数组大小</span><span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">.</span>length    <span class="token function">merge_sort_c</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">//递归调用函数</span><span class="token function">merge_sort_c</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> r</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 递归终止条件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">></span> r<span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token comment">// 取p -> r的中间位置q</span>    <span class="token keyword">const</span> q <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>    <span class="token comment">// 分治递归</span>    <span class="token function">merge_sort_c</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span>    <span class="token function">merge_sort_c</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span>    <span class="token comment">// 将A[p...q]和A[q+1...r]合并为A[p...r]</span>    <span class="token function">merge</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>p<span class="token operator">...</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">[</span>p<span class="token operator">...</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>merge(A[p…r], A[p…q], A[q+1…r]) 函数的作用是将已经有序的 A[p…q]和 A[q+1….r]合并成一个有序的数组，并且放入 A[p….r]。</p><p><strong>实现过程：</strong><br>申请一个临时数组 tmp，大小与 A[p…r]相同。用两个游标 i 和 j，分别指向 A[p…q]和 A[q+1…r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;=A[j]，就把 A[i]放入到临时数组 tmp，并且 i 后移一位，否则将 A[j]放入到数组 tmp，j 后移一位。继续上述比较过程，直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾，这个时候，临时数组中存储的就是两个子数组合并之后的结果了。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r]中。</p><p><img src="image-20220331004008283.png"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 归并排序</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">[</span>p<span class="token operator">...</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">[</span>p<span class="token operator">...</span>q<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">[</span>q<span class="token operator">+</span><span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> i <span class="token operator">=</span> p，j <span class="token operator">=</span> q <span class="token operator">+</span> <span class="token number">1</span>，k <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 初始化变量i, j, k</span>    <span class="token keyword">const</span> tmp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">array</span><span class="token punctuation">[</span><span class="token number">0.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>r<span class="token operator">-</span>p<span class="token punctuation">]</span> <span class="token comment">// 申请一个大小跟A[p...r]一样的临时数组</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> q <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token constant">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token comment">// i++等于i:=i+1</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>      <span class="token comment">// 判断哪个子数组中有剩余的数据</span>    <span class="token keyword">let</span> start <span class="token operator">=</span> i，end  q    <span class="token keyword">if</span> <span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        start <span class="token operator">=</span> j        end<span class="token operator">=</span>r    <span class="token punctuation">&#125;</span>      <span class="token comment">// 将剩余的数据拷贝到临时数组tmp</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;=</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        tmp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">A</span><span class="token punctuation">[</span>start<span class="token operator">++</span><span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span>      <span class="token comment">// 将tmp中的数组拷贝回A[p...r]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token operator">-</span>p<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token constant">A</span><span class="token punctuation">[</span>p<span class="token operator">+</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>完整js实现代码</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 归并排序</span><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 当任意数组分解到只有一个值时返回</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> arr    <span class="token comment">// 获取中间值</span>    <span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment">// 分割数组</span>    <span class="token keyword">const</span> left <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span>    <span class="token keyword">const</span> right <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span>    <span class="token comment">// 递归 分解 合并</span>    <span class="token keyword">return</span> <span class="token function">mergeArr</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">mergeArr</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">let</span> leftIndex <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">let</span> rightIndex <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">const</span> leftLength <span class="token operator">=</span> left<span class="token punctuation">.</span>length    <span class="token keyword">const</span> rightLength <span class="token operator">=</span> right<span class="token punctuation">.</span>length    <span class="token comment">// 判断两个数组中元素的大小，依次插入数组</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftLength <span class="token operator">></span> leftIndex <span class="token operator">&amp;&amp;</span> rightLength <span class="token operator">></span> rightIndex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span>leftIndex<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span>rightIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">[</span>leftIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            leftIndex<span class="token operator">++</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            temp<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">[</span>rightIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            rightIndex<span class="token operator">++</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 合并 剩余数组</span>    <span class="token keyword">return</span> temp<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>leftIndex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>rightIndex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    i<span class="token operator">++</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// [190, 288, 440, 512,521, 602, 680, 692,910, 983]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>归并排序是稳定的排序算法</p><p>  归并排序稳不稳定关键要看 两个有序子数组合并成一个有序数组的merge() 函数。在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素，可以先把 A[p…q]中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p></li><li><p>归并排序的时间复杂度<br>定义求解问题 a 的时间是 T(a)，求解问题 b、c 的时间分别是 T(b) 和 T( c)，可以得到这样的递推关系式：</p>  <pre class="line-numbers language-none"><code class="language-none">T(a) &#x3D; T(b) + T(c) + K<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间。</p><p>  <strong>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式。</strong></p><p>  假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。同时，merge() 函数合并两个有序子数组的时间复杂度是 O(n)。所以，套用前面的公式，归并排序的时间复杂度的计算公式就是：</p>  <pre class="line-numbers language-none"><code class="language-none">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。T(n) &#x3D; 2*T(n&#x2F;2) + n； n&gt;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  分治计算：</p>  <pre class="line-numbers language-none"><code class="language-none">T(n) &#x3D; 2*T(n&#x2F;2) + n     &#x3D; 2*(2*T(n&#x2F;4) + n&#x2F;2) + n &#x3D; 4*T(n&#x2F;4) + 2*n     &#x3D; 4*(2*T(n&#x2F;8) + n&#x2F;4) + 2*n &#x3D; 8*T(n&#x2F;8) + 3*n     &#x3D; 8*(2*T(n&#x2F;16) + n&#x2F;8) + 3*n &#x3D; 16*T(n&#x2F;16) + 4*n     ......     &#x3D; 2^k * T(n&#x2F;2^k) + k * n     ......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  可得 <code>T(n) = 2^kT(n/2^k)+kn</code>。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，可得 k=log2n 。将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并排序的时间复杂度是 O(nlogn)。</p><p>  所以，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 **O(nlogn)**。</p></li><li><p>归并排序的空间复杂度<br>  因为归并排序的合并函数，在合并两个有序数组为一个有序数组时，需要借助额外的存储空间，所以归并排序不是原地排序算法。</p><p>  递归代码的空间复杂度并不能像时间复杂度那样累加，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 **O(n)**。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-2.3 选择排序</title>
      <link href="/2022/03/30/suan-fa-2-3-xuan-ze-pai-xu/"/>
      <url>/2022/03/30/suan-fa-2-3-xuan-ze-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h4><p>选择排序算法的实现思路有点类似插入排序，也分<strong>已排序区间</strong>和<strong>未排序区间</strong>。但是选择排序每次会从<strong>未排序区间</strong>中找到==最小的元素==，将其放到<strong>已排序区间</strong>的==末尾==。</p><p><img src="image-20220330001458974.png"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token comment">// 需要注意这里的边界，因为需要在内存进行 i + 1后的循环，所以外层需要 n - 1</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> minIndex <span class="token operator">=</span> i        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                minIndex <span class="token operator">=</span> j <span class="token comment">// 找到整个数组的最小值</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">const</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span>        arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp    <span class="token punctuation">&#125;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>选择排序是原地排序算法</p><p>选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n²)。</p></li><li><p>选择排序不是稳定的排序算法</p><p>选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p><p>例： 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><img src="image-20220330001511776.png"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-2.2 插入排序</title>
      <link href="/2022/03/28/suan-fa-2-2-cha-ru-pai-xu/"/>
      <url>/2022/03/28/suan-fa-2-2-cha-ru-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h4><p>一个有序的数组，往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，只要遍历数组，找到数据应该插入的位置将其插入即可。<br><img src="image-20220328003136102.png"></p><p>这是一个动态排序的过程，即动态地往有序集合中添加数据，可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。</p><h5 id="插入排序思路"><a href="#插入排序思路" class="headerlink" title="插入排序思路"></a>插入排序思路</h5><p>首先，将数组中的数据分为两个区间，<strong>已排序区间</strong>和<strong>未排序区间</strong>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>例：要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p><p><img src="image-20220328003247592.png"></p><p>插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p><p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p><p><strong>例</strong>：满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。<br><img src="image-20220328003259259.png"></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 插入排序</span><span class="token keyword">function</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> value <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment">// 查找插入的位置</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token comment">// 数据移动</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">break</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value <span class="token comment">// 插入数据</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>插入排序是原地排序算法</p><p>插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。</p></li><li><p>插入排序是稳定的排序算</p><p>在插入排序中，对于值相同的元素，可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p></li><li><p>插入排序的时间复杂度</p><p>如果要排序的数据已经是有序的，并不需要搬移任何数据。如果从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为 O(n)。注意，这里是<strong>从尾到头遍历已经有序的数据</strong>。</p><p>如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n2)。</p><p>对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 O(n²)。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎？</p><p>冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。</p><p>但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。</p></li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 冒泡排序中数据的交换操作：</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 交换</span>   int tmp <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>   a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>   a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>   flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 插入排序中数据的移动操作：</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> value<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  a<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 数据移动</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-2.1 冒泡排序</title>
      <link href="/2022/03/24/suan-fa-2-1-mou-pao-pai-xu/"/>
      <url>/2022/03/24/suan-fa-2-1-mou-pao-pai-xu/</url>
      
        <content type="html"><![CDATA[<h4 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h4><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// arr [4, 5, 6, 3, 2, 1]</span><span class="token comment">// 第一次冒泡</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span>    <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">1</span>   <span class="token number">6</span>                        <span class="token operator">^</span>a<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>    <span class="token number">2</span>   <span class="token number">2</span>   <span class="token number">2</span>   <span class="token number">2</span>   <span class="token number">6</span>   <span class="token number">1</span>                    <span class="token operator">^</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token number">3</span>   <span class="token number">3</span>   <span class="token number">3</span>   <span class="token number">6</span>   <span class="token number">2</span>   <span class="token number">2</span>                <span class="token operator">^</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>    <span class="token number">6</span>   <span class="token number">6</span>   <span class="token number">6</span>   <span class="token number">3</span>   <span class="token number">3</span>   <span class="token number">3</span>            <span class="token operator">^</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token number">5</span>   <span class="token number">5</span>   <span class="token number">5</span>   <span class="token number">5</span>   <span class="token number">5</span>   <span class="token number">5</span>        <span class="token operator">^</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token number">4</span>   <span class="token number">4</span>   <span class="token number">4</span>   <span class="token number">4</span>   <span class="token number">4</span>   <span class="token number">4</span>        初  一  二  三  四  五<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20220324005430049.png"><br>经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，只要进行 6 次这样的冒泡操作就行了。<br><img src="image-20220324005446599.png"></p><ul><li><strong>优化</strong>：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// arr [3, 4, 5, 1, 2, 6]</span>冒泡次数        冒泡后结果              是否有数据交换初始状态        <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>         <span class="token operator">-</span>第一次冒泡      <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>          有第二次冒泡      <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>          有第三次冒泡      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>          有第四次冒泡      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span>          无，结束排序操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">/** * @params 冒泡排序代码 * @params arr 数组  */</span><span class="token keyword">function</span> <span class="token function">bubbleSort</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 提前退出冒牌排序的标志位</span>        <span class="token keyword">let</span> flag <span class="token operator">=</span> <span class="token boolean">false</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">const</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp                flag <span class="token operator">=</span> <span class="token boolean">true</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">break</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>冒泡排序是原地排序算法</p><p>  冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</p></li><li><p>冒泡排序是稳定的排序算法</p><p>  在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p></li><li><p>冒泡排序的时间复杂度</p><p>  最好情况的时间复杂度是O(n)<br>  最坏情况的时间复杂度是O(n²)</p></li></ul><p><img src="image-20220324005459491.png"></p><p><strong>平均时间复杂度如何分析？</strong><br>可通过 “<strong>有序度</strong>” 与 “<strong>逆序度</strong>” 两个概念分析。</p><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示即为：</p><pre class="line-numbers language-none"><code class="language-none">有序元素对：a[i] &lt;&#x3D; a[j], 如果i &lt; j。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="image-20220324005511700.png"><br>同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 ++==n*(n-1)/2==++，也就是 15。这种完全有序的数组的有序度叫作满有序度。</p><p>逆序度的定义正好跟有序度相反（默认从小到大为有序）。</p><pre class="line-numbers language-none"><code class="language-none">逆序元素对：a[i] &gt; a[j], 如果i &lt; j。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>关于这三个概念，可以得到一个公式：**==逆序度 = 满有序度 - 有序度==**。排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。</p><p>例：数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15。<br><img src="image-20220324005525166.png"></p><p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为<em><em>逆序度，也就是n</em>(n-1)/2–初始有序度</em>*。此例中就是 15–3=12，要进行 12 次交换操作。</p><p>对于包含 n 个数据的数组进行冒泡排序，最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。</p><p>即平均情况下，需要 n*(n-1)/4 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 O(n²)，所以平均情况下的时间复杂度就是 O(n²)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-2-0-排序</title>
      <link href="/2022/03/23/suan-fa-2-0-pai-xu/"/>
      <url>/2022/03/23/suan-fa-2-0-pai-xu/</url>
      
        <content type="html"><![CDATA[<h3 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h3><h4 id="一、排序算法的执行效率"><a href="#一、排序算法的执行效率" class="headerlink" title="一、排序算法的执行效率"></a><span style="color: orange;">一、排序算法的执行效率</span></h4><h5 id="1-最好情况、最坏情况、平均情况时间复杂度"><a href="#1-最好情况、最坏情况、平均情况时间复杂度" class="headerlink" title="1. 最好情况、最坏情况、平均情况时间复杂度"></a>1. 最好情况、最坏情况、平均情况时间复杂度</h5><p>有些排序算法会区分最好情况、最坏情况、平均情况下的时间复杂度;对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，需要知道排序算法在不同数据下的性能表现。</p><h5 id="2-时间复杂度的系数、常数-、低阶"><a href="#2-时间复杂度的系数、常数-、低阶" class="headerlink" title="2. 时间复杂度的系数、常数 、低阶"></a>2. 时间复杂度的系数、常数 、低阶</h5><p>时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，就要把系数、常数、低阶也考虑进来。</p><h5 id="3-比较次数和交换（或移动）次数"><a href="#3-比较次数和交换（或移动）次数" class="headerlink" title="3. 比较次数和交换（或移动）次数"></a>3. 比较次数和交换（或移动）次数</h5><h4 id="二、排序算法的内存消耗"><a href="#二、排序算法的内存消耗" class="headerlink" title="二、排序算法的内存消耗"></a><span style="color: orange;">二、排序算法的内存消耗</span></h4><p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p><h4 id="三、排序算法的稳定性"><a href="#三、排序算法的稳定性" class="headerlink" title="三、排序算法的稳定性"></a><span style="color: orange;">三、排序算法的稳定性</span></h4><p>仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><p>比如将数据 2, 3, 6, 5, 3 按排序后就是 2, 3, 3, 5, 6 。</p><p>这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那就把这种排序算法叫作<strong>稳定的排序算法</strong>；如果前后顺序发生变化，那对应的排序算法就叫作<strong>不稳定的排序算法</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法-1. 递归</title>
      <link href="/2022/03/22/suan-fa-1-di-gui/"/>
      <url>/2022/03/22/suan-fa-1-di-gui/</url>
      
        <content type="html"><![CDATA[<p><strong>示例</strong><br>假如有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走 n 个台阶有多少种走法？</p><hr><p><strong>解析：</strong>：可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。递推公式为：：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再来看下终止条件，当有一个台阶时，不需要再继续递归，就只有一种走法。所以 f(1)=1。</p><p>n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。</p><p>所以，递归终止条件就是 f(1)=1，f(2)=2。可通过n = 3 或 n = 4 几个较小的数验证。</p><p>总的递归伪代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>转为代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span>    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h4 id="从上述问题可知，递归需要满足三个条件"><a href="#从上述问题可知，递归需要满足三个条件" class="headerlink" title="从上述问题可知，递归需要满足三个条件"></a>从上述问题可知，递归需要满足三个条件</h4><h5 id="1-一个问题的解可以分解为几个子问题的解"><a href="#1-一个问题的解可以分解为几个子问题的解" class="headerlink" title="1. 一个问题的解可以分解为几个子问题的解"></a>1. 一个问题的解可以分解为几个子问题的解</h5><h5 id="2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2-这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h5><h5 id="3-存在递归终止条件"><a href="#3-存在递归终止条件" class="headerlink" title="3. 存在递归终止条件"></a>3. 存在递归终止条件</h5><p>把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。</p><p><span style="color: orange;">总之：写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</span></p><h4 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h4><h5 id="为什么递归代码容易造成堆栈溢出？"><a href="#为什么递归代码容易造成堆栈溢出？" class="headerlink" title="为什么递归代码容易造成堆栈溢出？"></a>为什么递归代码容易造成堆栈溢出？</h5><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有<strong>堆栈溢出</strong>的风险。</p><h5 id="如何避免出现堆栈溢出？"><a href="#如何避免出现堆栈溢出？" class="headerlink" title="如何避免出现堆栈溢出？"></a>如何避免出现堆栈溢出？</h5><p>可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，就不继续往下再递归了，直接返回报错。</p><p><strong>走台阶的例子（假设最大深度1000）：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 全局变量depth表示递归的深度</span><span class="token keyword">let</span> depth <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token operator">++</span>depth    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> Error    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span>    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p><h4 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h4><p>除此之外，使用递归时还会出现重复计算的问题。还是走台阶递归代码的例子，如果把整个递归过程分解一下的话，那就是这样的：</p><p><img src="image-20220322225917045.png"></p><p>从图中，可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。</p><p>为了避免重复计算，可以通过一个数据结构（比如哈希表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Map，key是n，value是f(n)</span><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>  map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> ret<span class="token punctuation">)</span>  <span class="token keyword">return</span> ret<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>除了堆栈溢出、重复计算这两个问题之外，递归也有其他方面的一些问题。</p><p>在<strong>时间效率</strong>上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。</p><p>在<strong>空间复杂度</strong>上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销。</p><h4 id="如何将递归代码改写为非递归代码？"><a href="#如何将递归代码改写为非递归代码？" class="headerlink" title="如何将递归代码改写为非递归代码？"></a>如何将递归代码改写为非递归代码？</h4><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，要根据实际情况来选择是否需要用递归的方式来实现。</p><p><strong>走台阶例子非递归的实现方式：</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span>    <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pre <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> prepre <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        ret <span class="token operator">=</span> pre <span class="token operator">+</span> prepre        prepre <span class="token operator">=</span> pre        pre <span class="token operator">=</span> ret    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>笼统地说，所有的递归代码都可以改为这种<strong>迭代循环</strong>的非递归写法。因为递归本身就是借助栈来实现的，只不过使用的栈是系统或者虚拟机本身提供的。如果手动在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p><p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-4.1 循环队列、阻塞队列与并发队列</title>
      <link href="/2022/03/21/shu-ju-jie-gou-4-1-xun-huan-dui-lie-zu-sai-dui-lie-yu-bing-fa-dui-lie/"/>
      <url>/2022/03/21/shu-ju-jie-gou-4-1-xun-huan-dui-lie-zu-sai-dui-lie-yu-bing-fa-dui-lie/</url>
      
        <content type="html"><![CDATA[<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>循环队列长得像一个环，原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。<br><img src="image-20220321232919750.png"></p><p><strong>如何确定好队空和队满的判定条件</strong></p><p>队列为空的判断条件仍然是 head == tail。</p><p><img src="image-20220321232943737.png"><br>如图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。</p><p>当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间。</p><p><strong>基于数组实现</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">CirularQueue</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">capacity</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 数组: items，数组大小: n</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token comment">// head表示队头下标，tail表示队尾下标</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 入队</span>  <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 队满</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 出队</span>  <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果head === tail，表示队列为空</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">;</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CirularQueue</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 入队</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1: '</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// CirularQueue &#123; items: [ 1, &lt;2 empty items> ], n: 3, head: 0, tail: 1 &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2: '</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// CirularQueue &#123; items: [ 1, 2, &lt;1 empty item> ], n: 3, head: 0, tail: 2 &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3: '</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token comment">// 出队</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// CirularQueue &#123; items: [ 1, 2, &lt;1 empty item> ], n: 3, head: 1, tail: 2 &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// CirularQueue &#123; items: [ 1, 2, &lt;1 empty item> ], n: 3, head: 2, tail: 2 &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>基于链表实现</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>element <span class="token operator">=</span> element    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">CircularQueue</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 入队</span>  <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token comment">// head.next 指向 head 形成环</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> flag <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail      <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token comment">// tail.next 指向的位置不存储数据，tail.next.next 指向 head 形成环</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next      <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 出队</span>  <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>element      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">null</span>      <span class="token keyword">return</span> value    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>element      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next      <span class="token keyword">return</span> value    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token number">0</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'----获取队列元素----'</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>res <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      res <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CircularQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 插入元素</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment">// 获取元素</span>a<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1 2 3 -1</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// a -1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h3><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。<br><img src="image-20220321233001382.png"><br>可以类比为“生产者 - 消费者模型”，这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p><p>而且不仅如此，基于阻塞队列，还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如多配置几个“消费者”，来应对一个“生产者”。<br><img src="image-20220321233016079.png"></p><p>在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题，那如何实现一个线程安全的队列呢？</p><p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p><h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>线程池没有空闲线程时，新的任务请求线程资源时，线程池该如何处理？各种处理策略又是如何实现的呢？</p><p>一般有两种处理策略。第一种是非阻塞的处理方式，直接拒绝任务请求；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。那如何存储排队的请求呢？</p><p>为了公平地处理每个排队的请求，先进者先服务，所以队列这种数据结构很适合来存储排队请求。队列有基于链表和基于数组这两种实现方式。这两种实现方式对于排队请求的区别如下：</p><ul><li>基于链表的实现方式，可以实现一个支持无限排队的无界队列（unbounded queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的。</li><li>基于数组实现的有界队列（bounded queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，设置一个合理的队列大小，也是非常有讲究的。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</li></ul><p>另外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，<strong>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-4. 队列</title>
      <link href="/2022/03/16/shu-ju-jie-gou-4-dui-lie/"/>
      <url>/2022/03/16/shu-ju-jie-gou-4-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>先进者先出，后进者后出。一种操作受限的线性表数据结构。</p><p><strong>与栈操作类似，队列包含两种操作：出队-从队列头部取一个元素；入队-从队列尾部插入一个元素。</strong></p><p>队列的应用非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p><h3 id="顺序队列与链式队列"><a href="#顺序队列与链式队列" class="headerlink" title="顺序队列与链式队列"></a>顺序队列与链式队列</h3><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><h4 id="基于数组实现"><a href="#基于数组实现" class="headerlink" title="基于数组实现"></a>基于数组实现</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">ArrayQueue</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 申请一个大小为capacity的数组</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">capacity</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 数组: items, 数组大小: n</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token comment">// head表示队头下标，tail表示队尾下标</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 入队</span>  <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果tail === n 且 head === 0表示队列已满</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment">// 数据搬移</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        items<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">]</span> <span class="token operator">=</span> items<span class="token punctuation">[</span>i<span class="token punctuation">]</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">-=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>    <span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 出队</span>  <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果head === tail 表示队列为空</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 只是将head指针后移，并未移除数组元素</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 测试</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayQueue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayQueue &#123; items: [ 1 ], n: 1, head: 0, tail: 1 &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayQueue &#123; items: [ 1 ], n: 1, head: 0, tail: 1 &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayQueue &#123; items: [ 1 ], n: 1, head: 1, tail: 1 &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// null</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayQueue &#123; items: [ 1 ], n: 1, head: 1, tail: 1 &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayQueue &#123; items: [ 3 ], n: 1, head: 0, tail: 1 &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayQueue &#123; items: [ 3 ], n: 1, head: 0, tail: 1 &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="基于链表实现"><a href="#基于链表实现" class="headerlink" title="基于链表实现"></a>基于链表实现</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>element <span class="token operator">=</span> element<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">QueueBasedOnLinkedList</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 入队</span>  <span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>tail <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>tail<span class="token punctuation">.</span>next    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 出队</span>  <span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>element<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">return</span> value    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 测试</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">QueueBasedOnLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * QueueBasedOnLinkedList &#123; *  head: Node &#123; element: 1, next: null &#125;, *  tail: Node &#123; element: 1, next: null &#125; * &#125; * */</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * QueueBasedOnLinkedList &#123; *  head: Node &#123; element: 1, next: Node &#123; element: 2, next: null &#125; &#125;, *  tail: Node &#123; element: 2, next: null &#125; * &#125; * */</span>a<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * QueueBasedOnLinkedList &#123; *  head: Node &#123; element: 1, next: Node &#123; element: 2, next: [Node] &#125; &#125;, *  tail: Node &#123; element: 3, next: null &#125; * &#125; * */</span><span class="token comment">// 获取元素</span><span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'-------获取dequeue元素------'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>res <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  res <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">dequeue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 1 * 2 * 3 * -1 * */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-3. 栈</title>
      <link href="/2022/03/15/shu-ju-jie-gou-3-zhan/"/>
      <url>/2022/03/15/shu-ju-jie-gou-3-zhan/</url>
      
        <content type="html"><![CDATA[<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>栈是一种“操作受限”的线性表，只允许在一端插入和删除数据，后进者先出，先进者后出。</p><p><strong>使用情况</strong>：当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性。</p><h4 id="如何实现一个栈"><a href="#如何实现一个栈" class="headerlink" title="如何实现一个栈"></a>如何实现一个栈</h4><h5 id="顺序栈-基于数组实现"><a href="#顺序栈-基于数组实现" class="headerlink" title="顺序栈-基于数组实现"></a>顺序栈-基于数组实现</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">ArrayStack</span><span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 数组: items, 元素个数: count, 数组大小: n</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items <span class="token operator">=</span> <span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 数组</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 元素个数</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n <span class="token comment">// 数组长度</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 入栈操作</span>  <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果定义了数组长度，数组空间不够直接返回false</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">.</span>n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将item放到count位置，count++</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>    <span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 出栈操作</span>  <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 栈为空，直接返回null</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token keyword">null</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span>    <span class="token keyword">const</span> tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>items<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">--</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 测试</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayStack</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayStack &#123; items: [1], count: 1, n: 3 &#125;</span>a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayStack &#123; items: [1, 2], count: 2, n: 3 &#125;</span>a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayStack &#123; items: [1, 2, 3], count: 3, n: 3 &#125;</span>a<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayStack &#123; items: [1, 2], count: 2, n: 3 &#125;</span>a<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayStack &#123; items: [1], count: 1, n: 3 &#125;</span>a<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ArrayStack &#123; items: [], count: 0, n: 3 &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="链式栈-基于链表实现"><a href="#链式栈-基于链表实现" class="headerlink" title="链式栈-基于链表实现"></a>链式栈-基于链表实现</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>element <span class="token operator">=</span> element<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">StackBasedLinkedList</span>  <span class="token punctuation">&#123;</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 入栈操作</span>  <span class="token function">push</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>top <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>top <span class="token operator">=</span> node    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      node<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>top<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>top <span class="token operator">=</span> node    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">// 出栈操作</span>  <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>top <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>top<span class="token punctuation">.</span>element<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>top <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>top<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token keyword">return</span> value    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 测试</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackBasedLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * StackBasedLinkedList &#123; *  top: Node &#123; *   element: 1, *   next: null *  &#125; * &#125; * */</span>b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * StackBasedLinkedList &#123; *  top: Node &#123; *   element: 2, *   next: Node &#123; *    element: 1, *    next: null *   &#125; *  &#125; * &#125; * */</span>b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * StackBasedLinkedList &#123; *  top: Node &#123; *   element: 3, *   next: Node &#123; *    element: 2, *    next: [Node] *   &#125; *  &#125; * &#125; * */</span>b<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * StackBasedLinkedList &#123; *  top: Node &#123; *   element: 2, *   next: Node &#123; *    element: 1, *    next: null *   &#125; *  &#125; * &#125; * */</span>b<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * StackBasedLinkedList &#123; *  top: Node &#123; *   element: 1, *   next: null *  &#125; * &#125; * */</span>b<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// StackBasedLinkedList &#123; top: null &#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// -1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-2. 链表</title>
      <link href="/2022/03/14/shu-ju-jie-gou-2-lian-biao/"/>
      <url>/2022/03/14/shu-ju-jie-gou-2-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>相较于数组，链表不需要一块连续的内存空间，通过<strong>指针</strong>将一组<span style="color: orange">零散的内存块</span>串联起来使用。<br><img src="image-20220314221812789.png"></p><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p>链表通过指针将一组零散的内存块串联在一起。内存块称为链表的 <span style="color: orange">结点</span> ，串起所有结点的指针称为 <strong>后继指针 next</strong>。<br><img src="image-20220314221826305.png"></p><p>第一个结点叫作 <strong>头结点</strong>，最后一个结点叫作 <strong>尾结点</strong>。</p><ul><li>头结点用来记录链表的基地址，通过它可以遍历得到整条链表。</li><li>尾结点指针不是指向下一个结点，而是指向一个空地址 <strong>NULL</strong>，表示这是链表上最后一个结点。</li></ul><h5 id="链表的插入与删除操作"><a href="#链表的插入与删除操作" class="headerlink" title="链表的插入与删除操作"></a>链表的插入与删除操作</h5><p>只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。<br><img src="image-20220314221839506.png"><br>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。  </p><p>可以把链表想象成一个队伍，队伍中的每个人都只知道自己后面的人是谁，所以当我们希望知道排在第 k 位的人是谁的时候，我们就需要从第一个人开始，一个一个地往下数。所以，链表随机访问的性能没有数组好，需要 O(n) 的时间复杂度。  </p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><span style="color: orange">循环链表是一种特殊的单链表</span>，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点，像一个环一样首尾相连，所以叫作 <strong>循环链表</strong>。<br><img src="image-20220314221853411.png"><br>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。  </p><h4 id="双向列表"><a href="#双向列表" class="headerlink" title="双向列表"></a>双向列表</h4><p>单向链表只有一个方向，结点只有一个后继指针 <strong>next</strong> 指向后面的结点。 </p><p>双向链表支持两个方向，每个结点不止有一个后继指针 <strong>next</strong> 指向后面的结点，还有一个前驱指针 <strong>prev</strong> 指向前面的结点。</p><p><img src="image-20220314221906242.png"></p><p>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历。</p><p><span style="color: red;">空间换时间的设计思想</span><br>当内存空间充足的时候，如果追求代码的执行速度，可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，就要反过来用时间换空间的设计思路。</p><p><span style="color: red;">例：</span>缓存实际上就是利用了空间换时间的设计思想。如果把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p><p><span style="color: orange;">对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。</span></p><h5 id="双向链表-循环链表-双向循环链表"><a href="#双向链表-循环链表-双向循环链表" class="headerlink" title="双向链表 + 循环链表 = 双向循环链表"></a>双向链表 + 循环链表 = 双向循环链表</h5><p><img src="image-20220314221917465.png"></p><h4 id="如何实现LRU淘汰算法"><a href="#如何实现LRU淘汰算法" class="headerlink" title="如何实现LRU淘汰算法"></a>如何实现LRU淘汰算法</h4><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p><p><span style="color: orange;">实现方法：</span></p><ul><li>维护一个单链表，越早使用的数据在链表的越后面，越新使用的数据在链表的最前面</li><li>当有新的数据被使用，从头到尾访问链表。<ul><li>如果数据存在链表中，即在链表中删除该数据，再将该数据添加在链表的最前面</li><li>如果数据不在链表中，当链表内存未满，则直接将数据插在链表头；如果链表内存已满，则删除最后一条数据，再将新的数据结点插入到链表头部。</li></ul></li></ul><h4 id="写好链表代码的几个关键"><a href="#写好链表代码的几个关键" class="headerlink" title="写好链表代码的几个关键"></a>写好链表代码的几个关键</h4><h5 id="1-理解指针或引用的含义"><a href="#1-理解指针或引用的含义" class="headerlink" title="1. 理解指针或引用的含义"></a>1. 理解指针或引用的含义</h5><p><span style="color: green;">将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</span></p><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">p—<span class="token operator">></span>next <span class="token operator">=</span> q<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示p节点的后继指针存储了q节点的内存地址。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">p—<span class="token operator">></span>next <span class="token operator">=</span> p—<span class="token operator">></span>next—<span class="token operator">></span>next<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>表示p节点的后继指针存储了p节点的下下个节点的内存地址。</p><h5 id="2-警惕指针丢失和内存泄漏（单链表）"><a href="#2-警惕指针丢失和内存泄漏（单链表）" class="headerlink" title="2.警惕指针丢失和内存泄漏（单链表）"></a>2.警惕指针丢失和内存泄漏（单链表）</h5><p><span style="color: red;">插入节点: </span><br>在节点a和节点b之间插入节点x，b是a的下一节点，p指针指向节点a，则造成指针丢失和内存泄漏的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">p—<span class="token operator">></span>next <span class="token operator">=</span> xx—<span class="token operator">></span>next <span class="token operator">=</span> p—<span class="token operator">></span>next<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>显然这会导致x节点的后继指针指向自身。<br>正确的写法是2句代码交换顺序，即：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">x—<span class="token operator">></span>next <span class="token operator">=</span> p—<span class="token operator">></span>nextp—<span class="token operator">></span>next <span class="token operator">=</span> x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><span style="color: red;">删除节点: </span><br>在节点a和节点b之间删除节点b，b是a的下一节点,p指针指向节点a：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">p—<span class="token operator">></span>next <span class="token operator">=</span> p—<span class="token operator">></span>next—<span class="token operator">></span>next<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3-利用“哨兵”简化实现难度"><a href="#3-利用“哨兵”简化实现难度" class="headerlink" title="3. 利用“哨兵”简化实现难度"></a>3. 利用“哨兵”简化实现难度</h5><ul><li>什么是“哨兵”？<br>链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。</li><li>未引入“哨兵”的情况    <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 在p节点后插入一个节点</span>new_node—<span class="token operator">></span>next <span class="token operator">=</span> p—<span class="token operator">></span>nextp—<span class="token operator">></span>next <span class="token operator">=</span> new_node    <span class="token comment">// 向空链表中插入一个节点</span><span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> head <span class="token operator">=</span> new_node<span class="token punctuation">&#125;</span><span class="token comment">// 删除节点p的后继节点</span>p—<span class="token operator">></span>next <span class="token operator">=</span> p—<span class="token operator">></span>next—<span class="token operator">></span>next<span class="token punctuation">;</span><span class="token comment">// 若是删除链表的最有一个节点（链表中只剩下这个节点）</span><span class="token keyword">if</span><span class="token punctuation">(</span>head—<span class="token operator">></span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    head <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>  针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。</li><li>引入“哨兵”的情况<br>“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。<h5 id="4-重点留意边界条件处理"><a href="#4-重点留意边界条件处理" class="headerlink" title="4. 重点留意边界条件处理"></a>4. 重点留意边界条件处理</h5>经常用来检查链表是否正确的边界4个边界条件：</li><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个节点时，代码是否能正常工作？</li><li>如果链表只包含两个节点时，代码是否能正常工作？</li><li>代码逻辑在处理头尾节点时是否能正常工作？</li></ul><h5 id="5-举例画图，辅助思考"><a href="#5-举例画图，辅助思考" class="headerlink" title="5. 举例画图，辅助思考"></a>5. 举例画图，辅助思考</h5><p>核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。</p><h5 id="6-多写多练，没有捷径"><a href="#6-多写多练，没有捷径" class="headerlink" title="6. 多写多练，没有捷径"></a>6. 多写多练，没有捷径</h5><p>5个常见的链表操作：</p><ul><li>单链表反转</li><li>链表中环的检测</li><li>两个有序链表合并</li><li>删除链表倒数第n个节点</li><li>求链表的中间节点</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-1. 数组</title>
      <link href="/2022/03/11/shu-ju-jie-gou-1-shu-zu/"/>
      <url>/2022/03/11/shu-ju-jie-gou-1-shu-zu/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数组（Array）是一种<strong>线性表数据结构</strong>，它用一组<span style="color: orange">连续的内存空间</span>,来存储一组<span style="color: orange">具有相同类型</span>的数据。 </p><h4 id="如何实现随机访问？"><a href="#如何实现随机访问？" class="headerlink" title="如何实现随机访问？"></a>如何实现随机访问？</h4><ul><li>线性表<br><strong>线性表：数据只有前后关系</strong><br>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈等都是线性表结构。</li></ul><p><img src="image-20220311010714056.png"></p><p><strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><p><img src="image-20220311010842310.png"></p><ul><li>连续的内存空间和相同类型的数据<br>因为这两个限制，它才有了“<strong>随机访问</strong>”的特性。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http-4. 域名里的门道</title>
      <link href="/2022/03/10/http-4-yu-ming-li-de-men-dao/"/>
      <url>/2022/03/10/http-4-yu-ming-li-de-men-dao/</url>
      
        <content type="html"><![CDATA[<h3 id="域名的形式"><a href="#域名的形式" class="headerlink" title="域名的形式"></a>域名的形式</h3><p>域名是一个有层次的结构，是一串用“.”分隔的多个单词，最右边的被称为“顶级域名”，然后是“二级域名”，层级关系向左依次降低。</p><p>最左边的是主机名，通常用来表明主机的用途，比如“www”表示提供万维网服务、“mail”表示提供邮件服务，不过这也不是绝对的，名字的关键是要让我们容易记忆。</p><p>如域名“time.geekbang.org”，这里的“org”就是顶级域名，“geekbang”是二级域名，“time”则是主机名。使用这个域名，DNS 就会把它转换成相应的 IP 地址，你就可以访问极客时间的网站了。</p><p>域名不仅能够代替 IP 地址，还有许多其他的用途。在 Apache、Nginx 这样的 Web 服务器里，域名可以用来标识虚拟主机，决定由哪个虚拟主机来对外提供服务，比如在 Nginx 里就会使用“server_name”指令：</p><pre class="line-numbers language-none"><code class="language-none">server &#123; listen 80; #监听80端口 server_name time.geekbang.org; #主机名是time.geekbang.org ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>域名本质上还是个名字空间系统，使用多级域名就可以划分出不同的国家、地区、组织、公司、部门，每个域名都是独一无二的，可以作为一种身份的标识。</p><h3 id="域名的解析"><a href="#域名的解析" class="headerlink" title="域名的解析"></a>域名的解析</h3><p>类似IP 地址必须转换成 MAC 地址才能访问主机，域名必须转换成 IP 地址，这个过程就是“<strong>域名解析</strong>”。</p><p>DNS 是互联网的重要基础设施，必须要保证域名解析稳定可靠、快速高效。</p><p>DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：</p><ul><li>根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；</li><li>顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；</li><li>权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 <a href="http://www.apple.com/">www.apple.com</a> 的 IP 地址。</li></ul><p>例如访问<a href="http://www.apple.com，需要进行下面的三次查询：">www.apple.com，需要进行下面的三次查询：</a></p><ul><li>访问根域名服务器，它会告诉你“com”顶级域名服务器的地址；</li><li>访问“com”顶级域名服务器，它再告诉你“apple.com”域名服务器的地址；</li><li>最后访问“apple.com”域名服务器，就得到了“<a href="http://www.apple.com”的地址./">www.apple.com”的地址。</a></li></ul><p>虽然核心的 DNS 系统遍布全球，服务能力很强也很稳定，但如果全世界的网民都往这个系统里挤，即使不挤瘫痪了，访问速度也会很慢。</p><p>所以在核心 DNS 系统之外，还有两种手段用来减轻域名解析的压力，并且能够更快地获取结果，基本思路就是“<strong>缓存</strong>”。</p><p><strong>首先</strong>，许多大公司、网络运行商都会建立自己的 DNS 服务器，作为用户 DNS 查询的代理，代替用户访问核心 DNS 系统。这些“野生”服务器被称为“非权威域名服务器”，可以缓存之前的查询结果，如果已经有了记录，就无需再向根服务器发起查询，直接返回对应的 IP 地址。例如Google 的“8.8.8.8”，Microsoft 的“4.2.2.1”等等。</p><p><strong>其次</strong>，操作系统里也会对 DNS 解析结果做缓存，如果你之前访问过“<a href="http://www.apple.com”,那么下一次在浏览器里再输入这个网址的时候就不会再跑到/">www.apple.com”，那么下一次在浏览器里再输入这个网址的时候就不会再跑到</a> DNS 那里去问了，直接在操作系统里就可以拿到 IP 地址。</p><p><strong>另外</strong>，操作系统里还有一个特殊的“主机映射”文件，通常是一个可编辑的文本，在 Linux 里是“/etc/hosts”，在 Windows 里是“C:\WINDOWS\system32\drivers\etc\hosts”，如果操作系统在缓存里找不到 DNS 记录，就会找这个文件。</p><p>有了上面的“野生”DNS 服务器、操作系统缓存和 hosts 文件后，很多域名解析的工作就都不用“跋山涉水”了，直接在本地或本机就能解决，不仅方便了用户，也减轻了各级 DNS 服务器的压力，效率就大大提升了。</p><p>在 Nginx 里有这么一条配置指令“resolver”，它就是用来配置 DNS 服务器的，如果没有它，那么 Nginx 就无法查询域名对应的 IP，也就无法反向代理到外部的网站。</p><pre class="line-numbers language-none"><code class="language-none">resolver 8.8.8.8 valid&#x3D;30s; #指定Google的DNS，缓存30秒<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="域名的“新玩法”"><a href="#域名的“新玩法”" class="headerlink" title="域名的“新玩法”"></a>域名的“新玩法”</h3><ul><li>“<strong>重定向</strong>”。因为域名代替了 IP 地址，所以可以让对外服务的域名不变，而主机的 IP 地址任意变动。当主机有情况需要下线、迁移时，可以更改 DNS 记录，让域名指向其他的机器。</li><li>域名是一个名字空间，所以可以使用 bind9 等开源软件搭建一个在<strong>内部使用的 DNS，作为名字服务器</strong>。这样我们开发的各种内部服务就都用域名来标记，比如数据库服务都用域名“mysql.inner.app”，商品服务都用“goods.inner.app”，发起网络通信时也就不必再使用写死的 IP 地址了，可以直接用域名，而且这种方式也兼具了第一种“玩法”的优势。</li><li>基于域名实现的负载均衡。  <ul><li>域名解析可以返回多个 IP 地址，所以一个域名可以对应多台主机，客户端收到多个 IP 地址后，就可以自己使用轮询算法依次向服务器发起请求，实现负载均衡。</li><li>域名解析可以配置内部的策略，返回离客户端最近的主机，或者返回当前服务质量最好的主机，这样在 DNS 端把请求分发到不同的服务器，实现负载均衡。</li></ul></li></ul><h5 style="color: red;">恶意的DNS玩法</h5>- “**域名屏蔽**”，对域名直接不解析，返回错误，让你无法拿到 IP 地址，也就无法访问网站；- “**域名劫持**”，也叫“域名污染”，你要访问 A 网站，但 DNS 给了你 B 网站。### 小结- 域名使用字符串来代替 IP 地址，方便用户记忆，本质上一个名字空间系统；- DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一个“超级大管家”；- DNS 是一个树状的分布式查询系统，但为了提高查询效率，外围有多级的缓存；- 使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网。---- 解释一下“www. 不存在.com”的 DNS 解析过程。    - 在本地DNS缓存中查找有无www.不存在.com的域名的ip    - 如果没有，则在操作系统缓存中查找    - 如果没有，则在本地host文件中查询有无对应的固定记录    - 如果没有，则在本地网卡分配的 dns server ip来进行解析（即非官方ip）。本身它也会对查找的域名解析结果进行缓存，如果它没有缓存或者缓存失效，则先去顶级域名服务器“com”去查找“不存在.com”的域名服务器ip，结果发现不存在，于是直接返回告诉浏览器域名解析错误，当然这两次查找过程是基于udp协议    <pre><code>&lt;p style=&quot;color: orange&quot;&gt;（浏览器缓存-&gt;操作系统缓存-&gt;hosts-&gt;dns）&lt;/p&gt;</code></pre><ul><li>如果因为某些原因，DNS 失效或者出错了，会出现什么后果？<br>无法访问此网站，找不到<a href="http://www.xxx.com的服务器ip地址/">www.XXX.com的服务器IP地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http-3. 四层与七层是什么？</title>
      <link href="/2022/03/09/http-3-si-ceng-yu-qi-ceng-shi-shi-me/"/>
      <url>/2022/03/09/http-3-si-ceng-yu-qi-ceng-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<p>TCP/IP 协议，是 HTTP 协议的下层协议，负责具体的数据传输工作。并且TCP/IP 协议是一个“有层次的协议栈”。</p><p>工作中常听到的“<strong>四层负载均衡</strong>”“<strong>七层负载均衡</strong>”，“<strong>二层转发</strong>”“<strong>三层路由</strong>”具体是什么意思？可以从HTTP应用的角度，理清这些概念。  </p><hr><h3 id="TCP-IP-网络分层模型"><a href="#TCP-IP-网络分层模型" class="headerlink" title="TCP/IP 网络分层模型"></a>TCP/IP 网络分层模型</h3><p>TCP/IP 设计者提出了“分层”的概念，把复杂的网络通信划分出多个层次，再给每一个层次分配不同的职责，层次内只专心做自己的事情就好，用“分而治之”的思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信的难题。</p><pre class="line-numbers language-none"><code class="language-none">application layer &#x2F; HTTPtransport layer &#x2F; UDPinternet layer &#x2F; IPlink layer &#x2F; MAC<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>TCP/IP 协议总共有四层，就像搭积木一样，每一层需要下层的支撑，同时又支撑着上层，任何一层被抽掉都可能会导致整个协议栈坍塌。它的层次顺序是“从下往上”数的，所以第一层就是最下面的一层。</p><p>第一层叫“<strong>链接层</strong>”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。</p><p>第二层叫“<strong>网际层</strong>”或者“<strong>网络互连层</strong>”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。</p><p>第三层叫“<strong>传输层</strong>”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。</p><p>TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。</p><p>协议栈的第四层叫“<strong>应用层</strong>”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有的 HTTP。</p><p>MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。</p><h3 id="OSI-网络分层模型"><a href="#OSI-网络分层模型" class="headerlink" title="OSI 网络分层模型"></a>OSI 网络分层模型</h3><p>第二个网络分层模型：<strong>OSI</strong>，全称是“<strong>开放式系统互联通信参考模型</strong>”（Open System Interconnection Reference Model）。</p><p>由国际标准组织（ISO）设计的网络分层模型，OSI 模型分成了七层，部分层次与 TCP/IP 很像，从下到上分别是：</p><pre class="line-numbers language-none"><code class="language-none">application layerpresetation layersession layertransport layernetwork layerdata link layerphysical layer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；</li><li>第二层：数据链路层，它基本相当于 TCP/IP 的链接层；</li><li>第三层：网络层，相当于 TCP/IP 里的网际层；</li><li>第四层：传输层，相当于 TCP/IP 里的传输层；</li><li>第五层：会话层，维护网络中的连接状态，即保持会话和同步；</li><li>第六层：表示层，把数据转换为合适、可理解的语法和语义；</li><li>第七层：应用层，面向具体的应用传输数据。</li></ul><p>TCP/IP 等协议已经在许多网络上实际运行，再推翻重来是不可能的。所以，OSI 分层模型在发布的时候就明确地表明是一个“参考”，不是强制标准。</p><h5 id="OSI-模型优点"><a href="#OSI-模型优点" class="headerlink" title="OSI 模型优点"></a>OSI 模型优点</h5><ul><li>对比一下就可以看出，TCP/IP 是一个纯软件的栈，没有网络应有的最根基的电缆、网卡等物理设备的位置。而 OSI 则补足了这个缺失，在理论层面上描述网络更加完整。</li><li>OSI 为每一层标记了明确了编号，最底层是一层，最上层是七层，而 TCP/IP 的层次从来只有名字而没有编号。显然，在交流的时候说“七层”要比“应用层”更简单快捷，特别是英文，对比一下“Layer seven”与“application layer”。<h3 id="两个分层模型的映射关系"><a href="#两个分层模型的映射关系" class="headerlink" title="两个分层模型的映射关系"></a>两个分层模型的映射关系</h3><pre class="line-numbers language-none"><code class="language-none">application layerpresentation layer ----&gt; application layer &#x2F; HTTPsession layertransport layer ----&gt; transport layer &#x2F; TCP &#x2F; UDPnetwork layer ----&gt; internet layer &#x2F; IPdata link layer ----&gt; link layer &#x2F; MACphysical layer ----&gt; 无<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>第一层：物理层，TCP/IP 里无对应；</li><li>第二层：数据链路层，对应 TCP/IP 的链接层；</li><li>第三层：网络层，对应 TCP/IP 的网际层；</li><li>第四层：传输层，对应 TCP/IP 的传输层；</li><li>第五、六、七层：统一对应到 TCP/IP 的应用层。</li></ul><p>OSI 的分层模型在四层以上分的太细，而 TCP/IP 实际应用时的会话管理、编码转换、压缩等和具体应用经常联系的很紧密，很难分开。例如，HTTP 协议就同时包含了连接管理和数据格式定义。</p><p>所谓的“四层负载均衡”就是指工作在传输层上，基于 TCP/IP 协议的特性，例如 IP 地址、端口号等实现对后端服务器的负载均衡。</p><p>所谓的“七层负载均衡”就是指工作在应用层上，看到的是 HTTP 协议，解析 HTTP 报文里的 URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器。</p><h3 id="TCP-IP-协议栈的工作方式"><a href="#TCP-IP-协议栈的工作方式" class="headerlink" title="TCP/IP 协议栈的工作方式"></a>TCP/IP 协议栈的工作方式</h3><p>把 HTTP 利用 TCP/IP 协议栈传输数据想象成一个发快递的过程。</p><p>假设你想把一件毛绒玩具送给朋友，但你要先拿个塑料袋套一下，这件玩具就相当于 <strong>HTTP 协议里要传输的内容</strong>，比如 HTML，然后** HTTP 协议为它加一个 HTTP 专用附加数据**。</p><p>你把玩具交给快递小哥，为了保护货物，他又加了层包装再贴了个标签，相当于在 <strong>TCP 层给数据再次打包，加上了 TCP 头</strong>。</p><p>接着快递小哥下楼，把包裹放进了三轮车里，运到集散点，然后再装进更大的卡车里，相当于<strong>在 IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头</strong>。</p><p>经过运输，包裹到达目的地，要卸货再放进另一位快递员的三轮车，就是<strong>在 IP 层、MAC 层传输后拆包</strong>。</p><p>快递员到了你朋友的家门口，撕掉标签，<strong>去除了 TCP 层的头</strong>，你朋友再拆掉塑料袋包装，也就是 <strong>HTTP 头</strong>，最后就拿到了玩具，也就是真正的 <strong>HTML 页面</strong>。</p><p>这个比喻里省略了很多 TCP/IP 协议里的细节，比如<strong>建连、路由、数据切分与重组、错误检查</strong>等，但核心的数据传输过程是差不多的。</p><p>HTTP 协议的传输过程就是这样通过协议栈逐层向下，每一层都添加本层的专有数据，层层打包，然后通过下层发送出去。</p><p>接收数据则是相反的操作，从下往上穿过协议栈，逐层拆包，每层去掉本层的专有头，上层就会拿到自己的数据。</p><p>但下层的传输过程对于上层是完全“透明”的，上层也不需要关心下层的具体实现细节，所以就 HTTP 层次来看，它不管下层是不是 TCP/IP 协议，看到的只是一个可靠的传输链路，只要把数据加上自己的头，对方就能原样收到。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>TCP/IP 分为四层，核心是二层的 IP 和三层的 TCP，HTTP 在第四层；</li><li>OSI 分为七层，基本对应 TCP/IP，TCP 在第四层，HTTP 在第七层；OSI 可以映射到 TCP/IP，但这期间一、五、六层消失了；</li><li>日常交流的时候我们通常使用 OSI 模型，用四层、七层等术语；</li><li>HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。</li></ul><p>辨别四层和七层比较好的（但不是绝对的）小窍门，“<strong>两个凡是</strong>”：<p style="color: Orange;">凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。</p></p><hr><ul><li><p>“二层转发”“三层路由”的理解？</p><ul><li>二层转发：设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播</li><li>三层路由：设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关</li></ul></li><li><p>DNS 协议位于哪一层呢？<br>网络请求的第一步是域名解析，所以工作在应用层</p></li><li><p>CDN 工作在哪一层？<br>应用层</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http-2. 与HTTP相关的概念与协议</title>
      <link href="/2022/03/07/http-2-yu-http-xiang-guan-de-gai-nian-yu-xie-yi/"/>
      <url>/2022/03/07/http-2-yu-http-xiang-guan-de-gai-nian-yu-xie-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><hr><h4 id="网络世界"><a href="#网络世界" class="headerlink" title="网络世界"></a>网络世界</h4><p>互联网是由许许多多个规模略小的网络连接而成的，这些“小网络”可能是只有几百台电脑的局域网，可能是有几万、几十万台电脑的广域网，可能是用电缆、光纤构成的固定网络，也可能是用基站、热点构成的移动网络。</p><p>互联网的正式名称是<br>Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。</p><p>互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。</p><h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><p>浏览器的正式名字叫“Web Browser”，是检索、查看互联网上网页资源的应用程序， Web，实际上指的就是“World Wide Web”，也就是万维网。</p><p>浏览器本质上是一个 HTTP 协议中的请求方，使用 HTTP 协议获取网络上的各种资源。</p><p>在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。</p><h4 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h4><p>浏览器是 HTTP 里的请求方，在协议另一端的应答方（响应方）即为服务器，Web Server。</p><p>Web 服务器是 HTTP 协议里响应请求的主体，通常也把控着绝大多数的网络资源。Web 服务器通常包含<strong>硬件和软件</strong>两层含义。</p><ul><li>硬件 - 物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。</li><li>软件 - 提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。常见的 Web服务器有：<ul><li>Apache - 老牌的服务器，特点是功能完善，资料丰富，学习门槛低</li><li>Nginx - Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展，高流量的网站的不二之选。</li><li>此外，还有 Windows 上的 IIS、Java 的 Jetty/Tomcat 等，因为性能不是很高，所以在互联网上应用得较少。<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4>浏览器和服务器是 HTTP 协议的两个端点，浏览器通常不会直接连到服务器，中间会经过“重重关卡”，其中的一个重要角色就叫做 CDN。</li></ul></li></ul><p><strong>CDN</strong>，全称是“<strong>Content Delivery Network</strong>” - “<strong>内容分发网络</strong>”。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。</p><p>CDN的作用：</p><ul><li>缓存源站的数据，让浏览器的请求不用“千里迢迢”地到达源站服务器，直接在“半路”就可以获取响应。如果 CDN 的调度算法很优秀，更可以找到离用户最近的节点，大幅度缩短响应时间。</li><li>CDN 也是现在互联网中的一项重要基础设施，除了基本的网络加速外，还提供负载均衡、安全防护、边缘计算、跨运营商网络等功能，能够成倍地“放大”源站服务器的服务能力，很多云服务商都把 CDN 作为产品的一部分</li></ul><h4 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h4><p>浏览器是一种用户代理，代替我们访问互联网。但是HTTP协议并没有规定用户代理的角色是真正的人类，也可以是机器人，即“爬虫”（Crawler），实际上是一种可以自动访问 Web 资源的应用程序。</p><ul><li><strong>爬虫的来源</strong><br>绝大多数是由各大搜索引擎“放”出来的，抓取网页存入庞大的数据库，再建立关键字索引，这样我们才能够在搜索引擎中快速地搜索到互联网角落里的页面</li><li>弊端<br>会过度消耗网络资源，占用服务器和带宽，影响网站对真实数据的分析，甚至导致敏感信息泄漏。所以，又出现了“反爬虫”技术，通过各种手段来限制爬虫。其中一项就是“君子协定”robots.txt，约定哪些该爬，哪些不该爬。无论是“爬虫”还是“反爬虫”，用到的基本技术都是两个，一个是 HTTP，另一个就是 HTML。<h4 id="HTML-WebService-WAF"><a href="#HTML-WebService-WAF" class="headerlink" title="HTML/WebService/WAF"></a>HTML/WebService/WAF</h4></li></ul><p><strong>HTML</strong> 是 HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。</p><p><strong>Web Service</strong>，名字与 Web Server 很像，但却是一个完全不同的东西。Web Service 是一种由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。因为采用了 HTTP 协议传输数据，所以在 Web Service 架构里服务器和客户端可以采用不同的操作系统或编程语言开发。例如服务器端用 Linux+Java，客户端用 Windows+C#，具有跨平台跨语言的优点。</p><p><strong>WAF</strong> 意思是“网络应用防火墙”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。</p><h4 id="相关概念小结"><a href="#相关概念小结" class="headerlink" title="相关概念小结"></a>相关概念小结</h4><ul><li>互联网上绝大部分资源都使用 HTTP 协议传输；</li><li>浏览器是 HTTP 协议里的请求方，即 User Agent；</li><li>服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；</li><li>CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；</li><li>爬虫是另一类 User Agent，是自动访问网络资源的程序。</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><hr><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>TCP/IP 协议是一系列网络通信协议的统称，其中最核心的两个协议是 TCP 和 IP，其他的还有 UDP、ICMP、ARP 等等，共同构成了一个复杂但有层次的协议栈。  </p><p>这个协议栈有四层，最上层是“应用层”，最下层是“链接层”，TCP 和 IP 则在中间：<strong>TCP 属于“传输层”，IP 属于“网际层”</strong>。  </p><p><strong>IP 协议</strong>(Internet Protocol)主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。IP 协议使用“IP 地址”的概念来定位互联网上的每一台计算机。  </p><p>现在使用的 IP 协议大多数是 v4 版，地址是四个用“.”分隔的数字，例如“192.168.0.1”，总共有 2^32，大约 42 亿个可以分配的地址。由于地址分配不够的问题，就又出现了 v6 版，使用 8 组“:”分隔的数字作为地址，有 2^128 个。</p><p><strong>TCP 协议</strong>(Transmission Control Protocol) - “传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。</p><p>“可靠”是指保证数据不丢失，“字节流”是指保证数据完整，所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，就像是读写在一个密闭的管道里“流动”的字节。</p><p>HTTP 是一个”传输协议”，但它不关心<strong>寻址、路由、数据完整性</strong>等传输细节，而要求这些工作都由下层来处理。因为互联网上最流行的是 TCP/IP 协议，而它刚好满足 HTTP 的要求，所以互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“<strong>HTTP over TCP/IP</strong>”。</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS（Domain Name System） - “域名系统”，即有意义的名字来作为 IP 地址的等价替代。</p><p>在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。</p><p>域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。顶级域名，如“com”、“edu”，“cn”“uk”等</p><p>但想要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。</p><p>目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。</p><h4 id="URI-URL"><a href="#URI-URL" class="headerlink" title="URI/URL"></a>URI/URL</h4><p>DNS 和 IP 地址只是标记了互联网上的主机，URI（Uniform Resource Identifier）- 统一资源标识符，使用它就能够唯一地标记互联网上资源。</p><p>URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 以nginx为例http:&#x2F;&#x2F;nginx.org&#x2F;en&#x2F;download.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>URI 主要有三个基本的部分构成：</p><ul><li>协议名：即访问该资源应当使用的协议，在这里是“https”；</li><li>主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.or”；</li><li>路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4></li></ul><p><strong>HTTPS</strong>，全称是“HTTP over SSL/TLS”，也就是运行在 SSL/TLS 协议上的 HTTP。</p><p><strong>SSL/TLS</strong>是一个负责加密通信的安全协议，建立在 TCP/IP 之上，所以也是个可靠的传输协议，可以被用作 HTTP 的下层。</p><p>SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。</p><p>代理有很多的种类，常见的有：</p><ul><li><p>匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器；</p></li><li><p>透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端；</p></li><li><p>正向代理：靠近客户端，代表客户端向服务器发送请求；</p></li><li><p>反向代理：靠近服务器端，代表服务器响应客户端的请求；</p><p style="color: red">CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。</p>代理在传输过程中插入了一个“中间层”，可以在这个环节做很多事情，比如:  </li><li><p>负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；– 内容缓存：暂存上下行的数据，减轻后端的压力；</p></li><li><p>安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；</p></li><li><p>数据处理：提供压缩、加密等额外的功能。</p><h4 id="协议相关小结"><a href="#协议相关小结" class="headerlink" title="协议相关小结"></a>协议相关小结</h4></li><li><p>TCP/IP 是网络世界最常用的协议，HTTP 通常运行在 TCP/IP 提供的可靠传输基础上；</p></li><li><p>DNS 域名是 IP 地址的等价替代，需要用域名解析实现到 IP 地址的映射；</p></li><li><p>URI 是用来标记互联网上资源的一个名字，由“协议名 + 主机名 + 路径”构成，俗称 URL；</p></li><li><p>HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；</p></li><li><p>代理是 HTTP 传输过程中的“中转站”，可以实现缓存加速、负载均衡等功能。</p></li></ul><hr><ul><li><strong>CDN 在对待浏览器和爬虫时会有差异吗</strong><br>CDN在对待浏览器和爬虫时没有差异，因为如果没有验证码或者其他验证方式区分的话，浏览器和爬虫都被视为User Agent（客户代理）</li><li><strong>怎么理解 WebService 与 Web Server</strong><br>WebService是服务端，Web Server是服务器</li><li><strong>DNS与URI的关系</strong><br>DNS 是将域名解析出真实IP地址的系统<br>URI 是统一资源标识符，标定了客户端需要访问的资源所处的位置，如果URI中的主机名使用域名，则需要使用DNS来讲域名解析为IP。</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http-1. HTTP是什么？HTTP不是什么？</title>
      <link href="/2022/02/19/http-1-http-shi-shi-me-http-bu-shi-shi-me/"/>
      <url>/2022/02/19/http-1-http-shi-shi-me-http-bu-shi-shi-me/</url>
      
        <content type="html"><![CDATA[<h4 id="初始"><a href="#初始" class="headerlink" title="初始"></a>初始</h4><p>HTTP 是超文本传输协议，也就是 HyperText Transfer Protocol。 </p><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><ul><li>超文本传输协议：<strong>“超文本”</strong> + <strong>“传输”</strong> +  <strong>“协议”</strong></li></ul><h6 id="首先，HTTP-是一个协议。"><a href="#首先，HTTP-是一个协议。" class="headerlink" title="首先，HTTP 是一个协议。"></a>首先，HTTP 是一个协议。</h6><p> 第一点，协议必须要有两个或多个参与者，也就是“协”（<strong>参与者协调</strong>）</p><p> 第二点，协议是对参与者的一种行为约定和规范，也就是“议”（<strong>沟通约定 责-权-利</strong>）</p><ul><li>第一层含义：HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li></ul><h6 id="第二部分：“传输”"><a href="#第二部分：“传输”" class="headerlink" title="第二部分：“传输”"></a>第二部分：“传输”</h6><p>HTTP 是一个“传输协议”，所谓的“传输”（Transfer）其实很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点搬到 A 点，即“A&lt;===&gt;B”。</p><p><strong>第一点，HTTP 协议是一个“双向协议”。</strong></p><p> 有两个最基本的参与者 A 和 B，从 A 开始到 B 结束，数据在 A 和 B 之间 <strong>双向流动</strong> 而不是单向流动。通常把先发起传输动作的 A 叫做 <strong>请求方</strong>，把后接到传输的 B 叫做 <strong>应答方</strong> 或者 <strong>响应方</strong>。</p><p><strong>第二点，数据虽然是在 A 和 B 之间传输，但并没有限制只有 A 和 B 这两个角色，允许中间有“中转”或者“接力”。</strong></p><p>传输方式从“A&lt;===&gt;B”，变成了“A&lt;=&gt;X&lt;=&gt;Y&lt;=&gt;Z&lt;=&gt;B”，A 到 B<br>的传输过程中可以存在任意多个“中间人”，而这些中间人也都遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意的额外功能，例如安全认证、数据压缩、编码转换等等，优化整个传输过程。</p><ul><li>第二层含义：HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范</li></ul><h6 id="第三部分：“超文本”。"><a href="#第三部分：“超文本”。" class="headerlink" title="第三部分：“超文本”。"></a>第三部分：“超文本”。</h6><p>所谓“<strong>文本</strong>”（Text），就表示 HTTP 传输的不是 TCP/UDP 这些底层协议里被切分的杂乱无章的二进制包（datagram），而是完整的、有意义的数据，可以被浏览器、服务器这样的上层应用程序处理。<br>所谓“<strong>超文本</strong>”，就是“超越了普通文本的文本”，它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。</p><h5 id="总结：-HTTP-是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。"><a href="#总结：-HTTP-是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。" class="headerlink" title="#### - 总结： HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。"></a>#### - 总结： <p style="color: red">HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</P></h5><h5 id="不是什么"><a href="#不是什么" class="headerlink" title="不是什么"></a>不是什么</h5><ul><li>HTTP 不是互联网<br>互联网（Internet）是遍布于全球的许多网络互相连接而形成的一个巨大的国际网络，在它上面存放着各式各样的资源，也对应着各式各样的协议，例如超文本资源使用 HTTP，普通文件使用 FTP，电子邮件使用 SMTP 和 POP3 等。</li><li>HTTP 不是编程语言<br>编程语言是人与计算机沟通交流所使用的语言，而 HTTP 是计算机与计算机沟通交流的语言，我们无法使用 HTTP 来编程，但可以反过来，用编程语言去实现 HTTP，告诉计算机如何用 HTTP 来与外界通信。</li><li>HTTP 不是 HTML<br>HTML 是超文本的载体，是一种标记语言，使用各种标签描述文字、图片、超链接等资源，并且可以嵌入 CSS、JavaScript 等技术实现复杂的动态效果。</li><li>HTTP 不是一个孤立的协议<br>HTTP 跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5></li><li>HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。</li><li>HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。</li><li>HTTP 传输的是文字、图片、音频、视频等超文本数据。</li><li>HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP理解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行机制-2. JavaScript如何实现异步编程</title>
      <link href="/2022/02/16/zhi-xing-ji-zhi-2-javascript-ru-he-shi-xian-yi-bu-bian-cheng/"/>
      <url>/2022/02/16/zhi-xing-ji-zhi-2-javascript-ru-he-shi-xian-yi-bu-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="JS-异步编程的六种方案"><a href="#JS-异步编程的六种方案" class="headerlink" title="JS 异步编程的六种方案"></a>JS 异步编程的六种方案</h2><p>Javascript语言的执行环境是”<strong>单线程</strong>“。也就是指一次只能完成一件任务。如果有多个任务，就必须排队，前面一个任务完成，再执行后面一个任务。</p><p>这种模式虽然实现起来比较简单，执行环境相对单纯，但是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</p><p>为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步和异步。</p><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><hr><p>异步就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有”堵塞“效应。</p><p>“异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。</p><h4 id="一、回调函数（Callback）"><a href="#一、回调函数（Callback）" class="headerlink" title="一、回调函数（Callback）"></a>一、回调函数（Callback）</h4><hr><p>回调函数是异步操作最基本的方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 处理逻辑</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>但是回调函数有一个致命的弱点，就是容易写出<strong>回调地狱（Callback hell）</strong>。假设多个请求存在依赖性，你可能就会写出如下代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 处理逻辑</span>    <span class="token function">ajax</span><span class="token punctuation">(</span>url1<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 处理逻辑</span>        <span class="token function">ajax</span><span class="token punctuation">(</span>url2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 处理逻辑</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。此外它不能使用 try catch 捕获错误，不能直接 return。</p><h4 id="二、事件监听"><a href="#二、事件监听" class="headerlink" title="二、事件监听"></a>二、事件监听</h4><hr><p>事件监听中，异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">f1<span class="token punctuation">.</span><span class="token function">addEventListent</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">,</span> f2<span class="token punctuation">)</span><span class="token comment">// 加延时</span><span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>        f1<span class="token punctuation">.</span><span class="token function">trigger</span><span class="token punctuation">(</span><span class="token string">'done'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>f1.trigger(‘done’)表示，执行完成后，立即触发done事件，从而开始执行f2。</p><p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p><h4 id="三、发布订阅"><a href="#三、发布订阅" class="headerlink" title="三、发布订阅"></a>三、发布订阅</h4><hr><p>某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> eventEmitter <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 缓存列表</span>    list<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">// 订阅</span>    <span class="token function">on</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token comment">// 如果对象中没有对应的 event 值，则表明没有订阅过，给 event 创建缓存列表</span>        <span class="token comment">// 如果对象中有对应的 event 值，则把 fn 添加到对应的 event 的缓存列表</span>        <span class="token keyword">let</span> _event <span class="token operator">=</span> <span class="token punctuation">(</span>_this<span class="token punctuation">.</span>list<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>_this<span class="token punctuation">.</span>list<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        _event<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>        <span class="token keyword">return</span> _this    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">// 监听依次</span>    <span class="token function">once</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 先绑定，调用后删除</span>        <span class="token keyword">let</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token keyword">function</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            _this<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> on<span class="token punctuation">)</span>            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>_this<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>        on<span class="token punctuation">.</span>fn <span class="token operator">=</span> fn        _this<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> on<span class="token punctuation">)</span>        <span class="token keyword">return</span> _this    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">// 取消订阅</span>    <span class="token function">off</span><span class="token punctuation">(</span><span class="token parameter">event<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token keyword">let</span> fns <span class="token operator">=</span> _this<span class="token punctuation">.</span>list<span class="token punctuation">[</span>event<span class="token punctuation">]</span>        <span class="token comment">// 如果缓存列表中没有对应的fn，返回false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fns<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 如果没有传 fn 的话，则将 event 值对应缓存列表中的 fn 都清空</span>            fns <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>fns<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 若有 fn，遍历缓存列表，查询与传入的 fn 相同的值，找到即删除</span>            <span class="token keyword">const</span> n <span class="token operator">=</span> fns<span class="token punctuation">.</span>length            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>fns<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> fn <span class="token operator">||</span> fns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fn <span class="token operator">===</span> fn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    fns<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token keyword">break</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> _this    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token comment">// 发布</span>    <span class="token function">emit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>        <span class="token comment">// 第一个参数是对应的 event 值，直接用数组的 shift 方法取出</span>        <span class="token keyword">let</span> event <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>        <span class="token keyword">let</span> fns <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>event<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token comment">// 如果缓存列表没有 fn 则返回 false</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fns <span class="token operator">||</span> <span class="token operator">!</span>fns<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// 遍历 event 值对应的缓存列表，依次执行 fn</span>        fns<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>_this<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> _this    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">user1</span><span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'用户 1 订阅了： '</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">user2</span><span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'用户 2 订阅了： '</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">user3</span><span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'用户 3 订阅了： '</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">user4</span><span class="token punctuation">(</span><span class="token parameter">content</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'用户 4 订阅了： '</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 订阅</span>eventEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'article1'</span><span class="token punctuation">,</span> user1<span class="token punctuation">)</span>eventEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'article1'</span><span class="token punctuation">,</span> user2<span class="token punctuation">)</span>eventEmitter<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'article1'</span><span class="token punctuation">,</span> user3<span class="token punctuation">)</span><span class="token comment">// 取消user2方法的订阅</span>eventEmitter<span class="token punctuation">.</span><span class="token function">off</span><span class="token punctuation">(</span><span class="token string">'article1'</span><span class="token punctuation">,</span> user2<span class="token punctuation">)</span>eventEmitter<span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">'article2'</span><span class="token punctuation">,</span> user4<span class="token punctuation">)</span><span class="token comment">// 发布</span>eventEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'article1'</span><span class="token punctuation">,</span> <span class="token string">'JS 发布-订阅模式'</span><span class="token punctuation">)</span>eventEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'article1'</span><span class="token punctuation">,</span> <span class="token string">'JS 发布-订阅模式'</span><span class="token punctuation">)</span>eventEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'article2'</span><span class="token punctuation">,</span> <span class="token string">'JS 观察者模式'</span><span class="token punctuation">)</span>eventEmitter<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'article2'</span><span class="token punctuation">,</span> <span class="token string">'JS 观察者模式'</span><span class="token punctuation">)</span><span class="token comment">// eventEmitter.on('article1', user3).emit('article1', 'test111')</span><span class="token comment">/** * 用户 1 订阅了：  JS 发布-订阅模式 * 用户 3 订阅了：  JS 发布-订阅模式 * 用户 1 订阅了：  JS 发布-订阅模式 * 用户 3 订阅了：  JS 发布-订阅模式 * 用户 4 订阅了：  JS 观察者模式 * */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 style="color: red">发布-订阅模式与观察者模式的区别</h5>- **观察者模式**  观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。- **发布订阅模式**  订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。<p style="color: red;">差异</p><ul><li>在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</li><li>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</li><li>观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。</li><li>观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式</li></ul><h4 id="四-Promise-A"><a href="#四-Promise-A" class="headerlink" title="四. Promise/A+"></a>四. Promise/A+</h4><hr><h5 id="1-Promise-的三种状态"><a href="#1-Promise-的三种状态" class="headerlink" title="1. Promise 的三种状态"></a>1. Promise 的三种状态</h5><ul><li>Pending - Promise 对象实例创建时候的初始状态</li><li>Fulfilled - 可以理解为成功的状态</li><li>Rejected - 可以理解为失败的状态</li></ul><p><strong>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态</strong>。比如说一旦状态变为 resolved 后，就不能再次改变为Fulfilled</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'reject'</span><span class="token punctuation">)</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'success'</span><span class="token punctuation">)</span> <span class="token comment">// 无效代码不执行</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    <span class="token parameter">value</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vale<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token parameter">reason</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token comment">// reject</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token comment">// 控制台结果</span>rejectPromise <span class="token punctuation">&#123;</span><span class="token operator">&lt;</span>fulfilled<span class="token operator">></span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Prototype<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> Promise<span class="token punctuation">[</span><span class="token punctuation">[</span>PromiseState<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">"fulfilled"</span><span class="token punctuation">[</span><span class="token punctuation">[</span>PromiseResult<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>构造 Promise 的时候，构造函数内部的代码是立即执行的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new Promise'</span><span class="token punctuation">)</span>    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'success'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'end'</span><span class="token punctuation">)</span><span class="token comment">// 控制台结果</span><span class="token keyword">new</span> <span class="token class-name">Promise</span>end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-Promis的链式调用"><a href="#2-Promis的链式调用" class="headerlink" title="2. Promis的链式调用"></a>2. Promis的链式调用</h5><ul><li>每次调用返回的都是一个新的 Promise 实例（这就是 then 可用链式调用的原因）</li><li>如果 then 中返回的是一个结果的话，会把这个结果传递下一次 then 中的成功回调</li><li>如果 then 中出现异常，会走下一个 then 的失败回调</li><li>在 then 中使用了 return，那么 return 的值会被 Promise.reslove() 包装，如下示例1、2</li><li>then 中可以不传递参数，如果不传递会透到下一个 then（示例3）</li><li>catch 会捕获到没有捕获的异常<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 示例1</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">2</span> <span class="token comment">// 包装成 Promise.reslove(2)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 运行结果</span><span class="token number">1</span><span class="token number">2</span>Promise <span class="token punctuation">&#123;</span><span class="token operator">&lt;</span>fulfilled<span class="token operator">></span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Prototype<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> Promise<span class="token punctuation">[</span><span class="token punctuation">[</span>PromiseState<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">"fulfilled"</span><span class="token punctuation">[</span><span class="token punctuation">[</span>PromiseResult<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 示例2</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'My Error'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">)</span>    <span class="token comment">// 运行结果</span><span class="token number">2</span>Promise <span class="token punctuation">&#123;</span><span class="token operator">&lt;</span>fulfilled<span class="token operator">></span><span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Prototype<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> Promise<span class="token punctuation">[</span><span class="token punctuation">[</span>PromiseState<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">"fulfilled"</span><span class="token punctuation">[</span><span class="token punctuation">[</span>PromiseResult<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 示例3</span><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token string">'./name.txt'</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error here'</span><span class="token punctuation">)</span> <span class="token comment">// then 中出现异常，会走下一个 then 的失败回调</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token comment">// 由于下一个 then 没有失败回调，就会继续往下找，如果都没有，就会被 catch 捕获到</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'data'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span> <span class="token comment">// then error</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token comment">// 运行结果</span>then Error<span class="token operator">:</span> error here<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>Promise 不仅能够捕获错误，而且也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">ajax</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">ajax</span><span class="token punctuation">(</span>url1<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">ajax</span><span class="token punctuation">(</span>url2<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><span style="color: red;">缺点：</span>无法取消 Promise，错误需要通过回调函数捕获等。<h4 id="五-生成器Generators-yield"><a href="#五-生成器Generators-yield" class="headerlink" title="五. 生成器Generators / yield"></a>五. 生成器Generators / yield</h4></li></ul><hr><p><strong>Generator</strong> 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。</p><ul><li><p>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p></li><li><p><strong>Generator 函数除了状态机，还是一个遍历器对象生成函数</strong>。</p></li><li><p><strong>可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果</strong>。</p></li><li><p>yield表达式本身没有返回值，或者说总是返回undefined。<strong>next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</strong>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">Generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">yield</span> <span class="token string">'hello'</span>    <span class="token keyword">yield</span> <span class="token string">'world'</span>    <span class="token keyword">return</span> <span class="token string">'ending'</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> hw <span class="token operator">=</span> <span class="token function">Generator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>hw<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 运行结果</span><span class="token punctuation">&#123;</span> value<span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span> value<span class="token operator">:</span> <span class="token string">'world'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">false</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span> value<span class="token operator">:</span> <span class="token string">'ending'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span> value<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码一共调用了四次next方法。</p></li><li><p>第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。next方法返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。</p></li><li><p>第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。next方法返回的对象的value属性就是当前yield表达式的值world，done属性的值false，表示遍历还没有结束。</p></li><li><p>第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。</p></li><li><p>第四次调用，此时 Generator 函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。</p></li></ul><p><span style="color: red; ">总结：</span>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield表达式后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p><p><strong>yield 表达式</strong><br>由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</p><ul><li>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li><li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</li><li>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li><li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li></ul><p><span style="color: red; ">注意：</span>yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p><p>**循环中使用 yield ***</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">const</span> <span class="token function-variable function">flat</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> a<span class="token punctuation">.</span>length    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> item <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> item <span class="token operator">!==</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token function">flat</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">yield</span> item        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> f <span class="token keyword">of</span> <span class="token function">flat</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 运行结果</span><span class="token number">1</span><span class="token number">2</span><span class="token number">3</span><span class="token number">4</span><span class="token number">5</span><span class="token number">6</span><span class="token comment">// for ... of中 yield 不暂停的原因</span><span class="token keyword">function</span> <span class="token function">forOf</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> it <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>value<span class="token punctuation">,</span> done<span class="token punctuation">&#125;</span> <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span> <span class="token keyword">break</span>        <span class="token function">fn</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token function">forOf</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// yield* flat(item)，* 的作用</span>委托，将符合要求的元素委托给 flat，然后返回整个迭代过程中产生的所有返回值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><span style="color: red; ">总结：</span>：迭代器的元素只能被使用一次，for…of 会消费掉传进去的迭代器。</p><h4 id="六-async-await"><a href="#六-async-await" class="headerlink" title="六. async/await"></a>六. async/await</h4><p><strong>1. async/await 简介</strong></p><ul><li>async/await 是基于 Promise 实现的，它不能用于普通的回调函数</li><li>async/await 与 Promise 一样，是非阻塞的</li><li>async/await 是异步代码看起来像同步代码</li></ul><p><strong>一个函数如果加上 async/await，那么该函数就会返回一个 Promise</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'hello'</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 运行结果</span>Promise <span class="token punctuation">&#123;</span> <span class="token string">'hello'</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">//1.txt文件</span><span class="token number">2.</span>txt<span class="token comment">//2.txt文件</span><span class="token number">3.</span>txt<span class="token comment">//3.txt文件</span>end<span class="token comment">// 读取文件</span><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token parameter">file</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>            <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">readResult</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">read</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span> <span class="token comment">// await 后面跟的是一个 Promise 实例</span>        <span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">read</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>        <span class="token keyword">let</span> p3 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">read</span><span class="token punctuation">(</span>p2<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p1: '</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p2: '</span><span class="token punctuation">,</span> p2<span class="token punctuation">)</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'p3: '</span><span class="token punctuation">,</span> p3<span class="token punctuation">)</span>        <span class="token keyword">return</span> p3    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'err: '</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">readResult</span><span class="token punctuation">(</span><span class="token string">'1.txt'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token comment">// async 函数返回的也是个 Promise</span>    <span class="token parameter">data</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'data: '</span><span class="token punctuation">,</span> data<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token parameter">err</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">// 返回结果</span>p1<span class="token operator">:</span> <span class="token number">2.</span>txtp2<span class="token operator">:</span> <span class="token number">3.</span>txtp3<span class="token operator">:</span> enddata<span class="token operator">:</span> end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.Async/Await并发请求</strong><br>如果请求两个文件，毫无关系，可以通过并发请求</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token keyword">function</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token parameter">file</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>file<span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> err            <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">readAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">read1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">read2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 同步执行</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">read1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> first <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token string">'1.txt'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'first: '</span><span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">read2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> second <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token string">'2.txt'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'second: '</span><span class="token punctuation">,</span> second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">readAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 运行结果</span>first<span class="token operator">:</span>  firstsecond<span class="token operator">:</span>  second<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>JS 异步编程进化史：callback -&gt; promise -&gt; generator -&gt; async + await</p></li><li><p>async/await 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p></li><li><p>async/await可以说是异步终极解决方案了。</p><p> (1) async/await函数相对于Promise，优势体现在：</p><ul><li>处理 then  的调用链，能够更清晰准确的写出代码</li><li>优雅地解决回调地狱问题</li></ul><p> <span style="color: red">async/await函数也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低，代码没有依赖性的话，完全可以使用 Promise.all 的方式。</span></p><p> (2) async/await 函数对 Generator 的改进</p><ul><li>内置执行器。Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。也就是说，async 函数的执行，与普通函数一模一样，只要一行。</li><li>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作。</li><li>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行机制-1. 为何try里面放return，finally还会执行</title>
      <link href="/2022/02/15/zhi-xing-ji-zhi-1-wei-he-try-li-mian-fang-return-finally-huan-hui-zhi-xing/"/>
      <url>/2022/02/15/zhi-xing-ji-zhi-1-wei-he-try-li-mian-fang-return-finally-huan-hui-zhi-xing/</url>
      
        <content type="html"><![CDATA[<p><strong>如果try {}语句中有return，这种情况下finally语句还会执行吗？</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">try</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'begin throw error'</span><span class="token punctuation">)</span>    <span class="token keyword">throw</span> <span class="token string">'this is an error'</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'after throw error? '</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'e: '</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// begin throw error</span><span class="token comment">// e: this is a error</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>throw之后进入catch，after未执行<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>   <span class="token keyword">try</span><span class="token punctuation">&#123;</span>     <span class="token keyword">return</span> <span class="token number">0</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">//TODO</span>       <span class="token keyword">return</span> <span class="token number">1</span>   <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// a</span><span class="token comment">// 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>先执行finally 在执行try里面的return<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">try</span><span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token string">'this is an error'</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'e: '</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token number">1</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// e: this is a error</span><span class="token comment">// a </span><span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>先执行return之前的语句，再执行finally，最后执行return<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">try</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token string">'finally end'</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// a</span><span class="token comment">// 'finally end'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>finally覆盖了try中的return</li></ul><p><span style="color: #0269c8">Java官方文档</span>是这么描述的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">The finally block always executes when the <span class="token keyword">try</span> block exits<span class="token punctuation">.</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>描述词用的<span style="color: red; ">always</span>，即<strong>在try执行完成之后，finally是一定会执行的</strong>。这种特性可以让程序员避免在<span style="color: red; ">try</span>语句中使用了<span style="color: red; ">return</span>, <span style="color: red; ">continue</span>或者 <span style="color: red; ">break</span>关键字而忽略了关闭相关资源的操作。把清理相关资源放到<span style="color: red; ">finally</span>语句块中一直是最佳实践。</p><p>用到finally关闭资源的时候，应该尽量避免在finally语句块中出现运行时错误，可以适当添加判断语句以增加程序健壮性：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>out <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Closing PrintWriter'</span><span class="token punctuation">)</span>        out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// 不要在finally语句中直接调用方法close()</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'PrintWriter not open'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>try中有return, 会先将值暂存，无论finally语句中对该值做什么处理，最终返回的都是try语句中的暂存值。</li><li>当try与finally语句中均有return语句，会忽略try中return。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 执行机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包8. 模块化解决的实际问题</title>
      <link href="/2022/02/12/zuo-yong-yu-yu-bi-bao-8-mo-kuai-hua-jie-jue-de-shi-ji-wen-ti/"/>
      <url>/2022/02/12/zuo-yong-yu-yu-bi-bao-8-mo-kuai-hua-jie-jue-de-shi-ji-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="Module模式"><a href="#Module模式" class="headerlink" title="Module模式"></a>Module模式</h3><p>在模块化规范形成之前，JS开发者使用<strong>Module</strong>设计模式来解决JS全局作用域的污染问题。Module模式最初被定义为一种在传统软件工程中为类提供私有和公有封装的方法。在JavaScript中，Module模式使用**匿名函数自调用 (闭包)**来封装，通过自定义暴露行为来区分私有成员和公有成员。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> myModule <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">window</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> moduleName <span class="token operator">=</span> <span class="token string">'module'</span>  <span class="token comment">// private</span>    <span class="token comment">// public</span>    <span class="token keyword">function</span> <span class="token function">setModuleName</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      moduleName <span class="token operator">=</span> name    <span class="token punctuation">&#125;</span>    <span class="token comment">// public</span>    <span class="token keyword">function</span> <span class="token function">getModuleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> moduleName    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> setModuleName<span class="token punctuation">,</span> getModuleName <span class="token punctuation">&#125;</span>  <span class="token comment">// 暴露行为</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p><strong>CommonJS</strong>主要用<strong>在Node开发</strong>上，每个文件就是一个模块，没个文件都有自己的一个作用域。通过<strong>module.exports暴露public成员</strong>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 文件名：x.js</span><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>module<span class="token punctuation">.</span>exports<span class="token punctuation">.</span>add <span class="token operator">=</span> add<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，CommonJS通过require()引入模块依赖，require函数可以引入<strong>Node的内置模块、自定义模块和npm等第三方模块</strong>。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 文件名：main.js</span><span class="token keyword">let</span> xm <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./x.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xm<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xm<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 2</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xm<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 定义AMD规范的模块</span><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">return</span> 模块<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>区别于CommonJS，AMD规范的被依赖模块是异步加载的，而定义的模块是被当作回调函数来执行的，依赖于require.js模块管理工具库。当然，AMD规范不是采用匿名函数自调用的方式来封装，我们依然可以利用闭包的原理来实现模块的私有成员和公有成员：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'module1'</span><span class="token punctuation">,</span> <span class="token string">'module2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">m1<span class="token punctuation">,</span> m2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    x <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> add <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。AMD 推崇依赖前置，CMD 推崇依赖就近。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">//  同步加载模块</span>  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 异步加载一个模块，在加载完成时，执行回调</span>  require<span class="token punctuation">.</span><span class="token function">async</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对外暴露成员</span>  exports<span class="token punctuation">.</span><span class="token function-variable function">doSomething</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用模块</span>seajs<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CMD集成了CommonJS和AMD的特点，支持同步和异步加载模块。CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。因此，在CMD中require函数同步加载模块时没有HTTP请求过程。</p><h3 id="ES6-module"><a href="#ES6-module" class="headerlink" title="ES6 module"></a>ES6 module</h3><p>S6的模块化已经不是规范了，而是JS语言的特性。随着ES6的推出，AMD和CMD也随之成为了历史。ES6模块与模块化规范相比，有两大特点：</p><ul><li>模块化规范输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>模块化规范是运行时加载，ES6 模块是编译时输出接口。</li></ul><p>模块化规范输出的是一个对象，该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，ES6 module 是一个多对象输出，多对象加载的模型。从原理上来说，模块化规范是匿名函数自调用的封装，而ES6 module则是用匿名函数自调用去调用输出的成员。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域与闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包-7. 如何处理循环的异步操作</title>
      <link href="/2022/02/09/zuo-yong-yu-yu-bi-bao-7-ru-he-chu-li-xun-huan-de-yi-bu-cao-zuo/"/>
      <url>/2022/02/09/zuo-yong-yu-yu-bi-bao-7-ru-he-chu-li-xun-huan-de-yi-bu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h4 id="异步循环"><a href="#异步循环" class="headerlink" title="异步循环"></a>异步循环</h4><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> functon <span class="token function">processArr</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> <span class="token function">fn</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 报错，array.forEach 里的匿名函数是同步的，不能在同步方法里使用await</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>解决方法：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 匿名函数定义为异步，forEach 方法就相当于异步的了，不会等待遍历完所有的 item</span><span class="token keyword">function</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">delLog</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 等待一个返回promise的函数</span>    <span class="token keyword">await</span> <span class="token function">del</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// del函数执行后的日志项</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">processArr</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    array<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> <span class="token function">delLog</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Done!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">processArr</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment">/** * 输出： * Done! * Primise &#123;&lt;fulfilled>: undefined&#125; * 1 * 2 * 3 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="异步循环等待在操作"><a href="#异步循环等待在操作" class="headerlink" title="异步循环等待在操作"></a>异步循环等待在操作</h4><ul><li>串行遍历<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">processArr</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> <span class="token function">delLog</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 等待循环再执行后续操作</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Done!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 输出： * Primise &#123;&lt;pending>&#125; * 1 * 2 * 3 * Done! */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>并行遍历<br>  对于大数组不建议使用，并行任务会加重CPU和内存负荷<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">processArr</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// map array to promises</span>    <span class="token keyword">const</span> promises <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>delLog<span class="token punctuation">)</span>    <span class="token comment">// await until all promises are resolved</span>    <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Done!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">/** * 输出： * Primise &#123;&lt;pending>&#125; * 1 * 2 * 3 * Done! */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="all-in-一次性做完所有异步"><a href="#all-in-一次性做完所有异步" class="headerlink" title="all in 一次性做完所有异步"></a>all in 一次性做完所有异步</h4><ul><li>利用 Promise.all<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">function</span> <span class="token function">doAsync</span><span class="token punctuation">(</span><span class="token parameter">time<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"promise all in"</span><span class="token punctuation">)</span>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">doAsync</span><span class="token punctuation">(</span>item <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>item<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-promise</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"promise all in"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>利用async/await + 立即执行函数<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"async/await all in"</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token keyword">await</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">doAsync</span><span class="token punctuation">(</span>item <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>item<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-async/await</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"async/await all in"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="One-by-one-一次只做一个异步操作"><a href="#One-by-one-一次只做一个异步操作" class="headerlink" title="One by one 一次只做一个异步操作"></a>One by one 一次只做一个异步操作</h4></li><li>利用Array.reduce<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 数据处理比较麻烦</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"promise one by one"</span><span class="token punctuation">)</span>arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">accumulator<span class="token punctuation">,</span> currentValue<span class="token punctuation">,</span> currentIndex</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> accumulator<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>arr<span class="token punctuation">[</span>currentIndex<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-Array.reduce</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>currentIndex <span class="token operator">===</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">doAsync</span><span class="token punctuation">(</span>currentValue <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"promise one by one"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token function">doAsync</span><span class="token punctuation">(</span>currentValue <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token function">doAsync</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>async/await<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">"async/await one by one"</span><span class="token punctuation">)</span><span class="token keyword">for</span>  <span class="token punctuation">(</span><span class="token keyword">let</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">await</span> <span class="token function">doAsync</span><span class="token punctuation">(</span>item <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span>item<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">-async/await</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">"async/await one by one"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域与闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包-6. 堆栈溢出和内存泄漏的原理与解决方案</title>
      <link href="/2022/02/07/zuo-yong-yu-yu-bi-bao-6-dui-zhan-yi-chu-he-nei-cun-xie-lou-de-yuan-li-yu-jie-jue-fang-an/"/>
      <url>/2022/02/07/zuo-yong-yu-yu-bi-bao-6-dui-zhan-yi-chu-he-nei-cun-xie-lou-de-yuan-li-yu-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h5 id="原理理解"><a href="#原理理解" class="headerlink" title="原理理解"></a>原理理解</h5><p><strong>内存溢出 out of memory</strong>，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p><p><strong>内存泄露 memory leak</strong>，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p><p><em>memory leak</em> 会最终会导致 <em>out of memory</em>！</p><p>内存溢出就是你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。 </p><p>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出！比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出. </p><h5 id="内存泄漏种类"><a href="#内存泄漏种类" class="headerlink" title="内存泄漏种类"></a>内存泄漏种类</h5><p>以发生的方式来分类，内存泄漏可以分为4类： </p><ul><li>常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。 </li><li>偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。 </li><li>一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。 </li><li>隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。 </li></ul><p>从用户使用程序的角度来看，内存泄漏本身不会产生什么危害，作为一般的用户，根本感觉不到内存泄漏的存在。真正有危害的是内存泄漏的堆积，这会最终消耗尽系统所有的内存。从这个角度来说，一次性内存泄漏并没有什么危害，因为它不会堆积，而隐式内存泄漏危害性则非常大，因为较之于常发性和偶发性内存泄漏它更难被检测到 </p><h5 id="内存溢出的原因以及解决方法："><a href="#内存溢出的原因以及解决方法：" class="headerlink" title="内存溢出的原因以及解决方法："></a>内存溢出的原因以及解决方法：</h5><p>常见的有以下几种：</p><ul><li>内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li><li>集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；</li><li>代码中存在死循环或循环产生过多重复的对象实体；</li><li>使用的第三方软件中的BUG；</li><li>启动参数内存值设定的过小</li></ul><p>内存溢出的解决方案：</p><ul><li>第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</li><li>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</li><li>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。重点排查以下几点：</li></ul><ol><li>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</li><li>检查代码中是否有死循环或递归调用。</li><li>检查是否有大循环重复产生新对象实体。</li><li>检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</li></ol><ul><li>第四步，使用内存查看工具动态查看内存使用情况。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域与闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包-5. 闭包的原理与作用</title>
      <link href="/2022/02/03/zuo-yong-yu-yu-bi-bao-5-bi-bao-de-yuan-li-yu-zuo-yong/"/>
      <url>/2022/02/03/zuo-yong-yu-yu-bi-bao-5-bi-bao-de-yuan-li-yu-zuo-yong/</url>
      
        <content type="html"><![CDATA[<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>闭包就是能够读取其他函数内部变量的函数，可理解为在一个函数中包含另一个函数。</p><p>在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</p><p>所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。<br>在某些业务场景中，我们需要获取到函数内部的局部变量，解决方法即为，在函数内部再定义一个函数,示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">999</span><span class="token punctuation">;</span>    　　<span class="token keyword">function</span> <span class="token function">f2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>　　    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token punctuation">&#125;</span>　　　　<span class="token keyword">return</span> f2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 999</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例代码中，f2可沿作用域链访问f1的作用域，f1返回了f2，即可在外部获取f1的局部变量。f2函数，即为闭包。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>可以读取函数内部的变量</li><li>让这些变量的值始终保持在内存中</li></ul><p>示例：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function-variable function">nAdd</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        n<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">function</span> <span class="token function">f2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> f2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">res</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0</span><span class="token function">nAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">res</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中，res实际上是闭包f2函数，第一次运行为0，第二次为1。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。</p><p>f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>另一个值得注意的地方，就是<code>nAdd=function () &#123;n++&#125;</code>这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域与闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包-4. this的原理以及几种不同使用场景的取值</title>
      <link href="/2022/02/02/zuo-yong-yu-yu-bi-bao-4-this-de-yuan-li-yi-ji-ji-chong-bu-tong-shi-yong-chang-jing-de-qu-zhi/"/>
      <url>/2022/02/02/zuo-yong-yu-yu-bi-bao-4-this-de-yuan-li-yi-ji-ji-chong-bu-tong-shi-yong-chang-jing-de-qu-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="this原理"><a href="#this原理" class="headerlink" title="this原理"></a>this原理</h3><h5 id="一、问题由来"><a href="#一、问题由来" class="headerlink" title="一、问题由来"></a>一、问题由来</h5><p>下列代码中，虽然obj.foo和foo指向同一个函数，但是执行结果可能不一样。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>  bar<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种差异的原因，就在于函数体内部使用了<strong>this</strong>关键字，<strong>this</strong>指的是函数运行时所在的环境。对于obj.foo()来说，foo运行在obj环境，所以<strong>this</strong>指向obj；对于foo()来说，foo运行在全局环境，所以<strong>this</strong>指向全局环境。</p><h5 id="二、原理解析"><a href="#二、原理解析" class="headerlink" title="二、原理解析"></a>二、原理解析</h5><h6 id="1-内存的数据结构"><a href="#1-内存的数据结构" class="headerlink" title="1. 内存的数据结构"></a>1. 内存的数据结构</h6><p>JavaScript 语言之所以有this的设计，跟内存里面的数据结构有关系。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>foo<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上面的代码将一个对象赋值给变量obj。JavaScript 引擎会先在内存里面，生成一个对象<code>&#123; foo: 5 &#125;</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。其中，<code>&#123;foo: 5&#125;</code>存储在堆内存中，obj存储在栈内存中。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span>  <span class="token punctuation">(</span><span class="token punctuation">&#123;</span>foo<span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以理解为，变量<code>obj</code>只是一个地址，指向堆内存中的<code>&#123;foo: 5&#125;</code>，如果要获取<code>obj.foo</code>，js引擎会先从<code>obj</code>拿到内存地址，再从该地址读取原始对象<code>&#123;foo: 5&#125;</code>,返回它的<code>foo</code>属性。  </p><p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的foo属性，实际上是以下面的形式保存的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">obj <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>                        <span class="token punctuation">[</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">5</span>                        <span class="token punctuation">[</span><span class="token punctuation">[</span>wirtable<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">[</span><span class="token punctuation">[</span>enumerable<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">[</span><span class="token punctuation">[</span>configurable<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>                    <span class="token punctuation">)</span>                    即：<span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">5</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span>writable<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span>enumerable<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span>configurable<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h6><p>当属性的值是一个函数时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给foo属性的value属性。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> foo <span class="token operator">--</span><span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>                        <span class="token punctuation">[</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> 函数的地址   <span class="token operator">&lt;</span><span class="token operator">--</span><span class="token operator">-</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>                        <span class="token punctuation">[</span><span class="token punctuation">[</span>wirtable<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">[</span><span class="token punctuation">[</span>enumerable<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>                        <span class="token punctuation">[</span><span class="token punctuation">[</span>configurable<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token boolean">true</span>                    <span class="token punctuation">)</span>即：<span class="token punctuation">&#123;</span>  foo<span class="token operator">:</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span><span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">:</span> 函数的地址    <span class="token operator">...</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于函数是一个单独的值，因此存在第一个示例中不同的执行上下文，从而运行结果不同。</p><h6 id="3-环境变量"><a href="#3-环境变量" class="headerlink" title="3. 环境变量"></a>3. 环境变量</h6><p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上述代码中，变量x由运行环境提供。  </p><p>由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，<strong>它的设计目的就是在函数体内部，指代函数当前的运行环境。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面代码中，函数体里面的this.x就是指当前运行环境的x。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  f<span class="token operator">:</span> f<span class="token punctuation">,</span>  x<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 单独执行</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span><span class="token comment">// obj 环境执行</span>obj<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 如果没有this的情况</span><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  f<span class="token operator">:</span> f<span class="token punctuation">,</span>  x<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 单独执行</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span><span class="token comment">// obj 环境执行</span>obj<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="this的几种使用场景"><a href="#this的几种使用场景" class="headerlink" title="this的几种使用场景"></a>this的几种使用场景</h3><p>在函数中 this 到底取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。  </p><p>因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。  </p><h5 id="关于-this-的取值，大体上可以分为以下七种情况："><a href="#关于-this-的取值，大体上可以分为以下七种情况：" class="headerlink" title="关于 this 的取值，大体上可以分为以下七种情况："></a>关于 this 的取值，大体上可以分为以下七种情况：</h5><h6 id="一、全局-amp-调用普通函数"><a href="#一、全局-amp-调用普通函数" class="headerlink" title="一、全局 &amp; 调用普通函数"></a>一、全局 &amp; 调用普通函数</h6><p>在全局环境中，this 永远指向 window。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="二、构造函数"><a href="#二、构造函数" class="headerlink" title="二、构造函数"></a>二、构造函数</h6><p>所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Foo &#123;x: 10&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。</p><p>但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况一，这时候 Foo() 就变成普通函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="三、对象方法"><a href="#三、对象方法" class="headerlink" title="三、对象方法"></a>三、对象方法</h6><p>如果函数作为对象的方法时，方法中的 this 指向该对象。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;x: 10, foo: f&#125;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：若是在对象方法中定义函数，那么情况就不同了。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">function</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>        <span class="token punctuation">&#125;</span>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>理解</strong>：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。</p><p>在这里，如果想要调用上层作用域中的变量 obj.x，可以定义一个变量缓存外部 this 变量。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> vm <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">function</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;x: 10&#125;</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span>        <span class="token punctuation">&#125;</span>        <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果 foo 函数不作为对象方法被调用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    <span class="token function-variable function">foo</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn <span class="token operator">=</span> obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。</p><h6 id="四、构造函数-prototype-属性"><a href="#四、构造函数-prototype-属性" class="headerlink" title="四、构造函数 prototype 属性"></a>四、构造函数 prototype 属性</h6><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getX</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Foo &#123;x: 10&#125;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。</p><h6 id="五、函数用-call、apply或者-bind-调用"><a href="#五、函数用-call、apply或者-bind-调用" class="headerlink" title="五、函数用 call、apply或者 bind 调用"></a>五、函数用 call、apply或者 bind 调用</h6><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;x: 10&#125;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 10</span><span class="token punctuation">&#125;</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。</p><h6 id="六、DOM-event-this"><a href="#六、DOM-event-this" class="headerlink" title="六、DOM event this"></a>六、DOM event this</h6><p>在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Listener</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Listener &#123;&#125;</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 这里的 this 指向 Listener 这个对象。不是强调的是这里的 this</span><span class="token punctuation">&#125;</span><span class="token class-name">Listener</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;div id="foo">&lt;/div></span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理解： 就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>    <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token function">foo</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可以用通过 bind 切换上下文:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Listener</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token operator">/</span> <span class="token comment">// Listener &#123;&#125;</span>    document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span><span class="token class-name">Listener</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">handleClick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Listener &#123;&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前六种情况其实可以总结为： this 指向调用该方法的对象。</p><h6 id="七、箭头函数"><a href="#七、箭头函数" class="headerlink" title="七、箭头函数"></a>七、箭头函数</h6><p>箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域与闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包-3. js执行上下文栈</title>
      <link href="/2022/02/01/zuo-yong-yu-yu-bi-bao-3-js-zhi-xing-shang-xia-wen-zhan/"/>
      <url>/2022/02/01/zuo-yong-yu-yu-bi-bao-3-js-zhi-xing-shang-xia-wen-zhan/</url>
      
        <content type="html"><![CDATA[<h5 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h5><p>JavaScript 的可执行代码(executable code)的类型:</p><ul><li>全局代码</li><li>函数代码</li><li>eval代码</li></ul><p>当执行到一个函数的时候，就会进行准备工作，即”<strong>执行上下文(execution context)</strong>“。</p><h5 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h5><p>JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。</p><p>为了模拟执行上下文栈的行为，定义执行上下文栈是一个数组：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">ECStack <span class="token operator">=</span> <span class="token punctuation">[</span>    globalContext<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>例如下列代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">fun3</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fun3'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">fun2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">fun1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。上述代码流程可理解为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 伪代码</span><span class="token comment">// fun1()</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>fun1<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// fun1中竟然调用了fun2，还要创建fun2的执行上下文</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>fun2<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 擦，fun2还调用了fun3！</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>fun3<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// fun3执行完毕</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// fun2执行完毕</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// fun1执行完毕</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">checkscope</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> scope<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"global scope"</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">checkscope</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token string">"local scope"</span><span class="token punctuation">;</span>    <span class="token keyword">function</span> <span class="token function">f</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> scope<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> f<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">checkscope</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>两段代码执行的结果一样，但是执行上下文栈的变化不一样。  </p><p>流程理解为：<br>第一段代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>checkscope<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>f<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第二段代码：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>checkscope<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>f<span class="token operator">></span> functionContext<span class="token punctuation">)</span><span class="token punctuation">;</span>ECStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域与闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包-2. js作用域与作用域链</title>
      <link href="/2022/01/31/zuo-yong-yu-yu-bi-bao-2-js-zuo-yong-yu-yu-zuo-yong-yu-lian/"/>
      <url>/2022/01/31/zuo-yong-yu-yu-bi-bao-2-js-zuo-yong-yu-yu-zuo-yong-yu-lian/</url>
      
        <content type="html"><![CDATA[<h4 id="作用域-scope"><a href="#作用域-scope" class="headerlink" title="作用域(scope)"></a>作用域(scope)</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul><li>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。作用域决定了代码区块中变量和其他资源的可见性。  </li><li>作用域就是一个独立的地盘，让变量不会外泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。<h5 id="全局作用域与函数作用域"><a href="#全局作用域与函数作用域" class="headerlink" title="全局作用域与函数作用域"></a>全局作用域与函数作用域</h5><h6 id="1-全局作用域"><a href="#1-全局作用域" class="headerlink" title="1. 全局作用域"></a>1. 全局作用域</h6>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</li><li>最外层函数 和在最外层函数外面定义的变量拥有全局作用域<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> outVariable <span class="token operator">=</span> <span class="token string">"我是最外层变量"</span><span class="token punctuation">;</span> <span class="token comment">//最外层变量</span><span class="token comment">// 最外层函数</span><span class="token keyword">function</span> <span class="token function">outFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">const</span> inVariable <span class="token operator">=</span> <span class="token string">"内层变量"</span><span class="token punctuation">;</span>    <span class="token comment">// 内层函数</span>    <span class="token keyword">function</span> <span class="token function">innerFun</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inVariable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">innerFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>outVariable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 我是最外层变量</span><span class="token function">outFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 内层变量</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inVariable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inVariable is not defined</span><span class="token function">innerFun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// innerFun is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>所有末定义直接赋值的变量自动声明为拥有全局作用域<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    variable <span class="token operator">=</span> <span class="token string">"未定义直接赋值的变量"</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> inVariable2 <span class="token operator">=</span> <span class="token string">"内层变量2"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// variable is not defined</span><span class="token function">outFun2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 要先执行这个函数，否则根本不知道里面是啥</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 未定义直接赋值的变量</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>inVariable2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// inVariable2 is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>所有window对象的属性拥有全局作用域<br>一般情况下，window对象的内置属性都拥有全局作用域，例如: window.name、window.location、window.top等</li></ul><p>全局作用域弊端：污染全局命名空间, 容易引起命名冲突。<br>因此，jQuery、Zepto 等库的源码，都会放在<code>javascript (function () &#123;....&#125;)() </code>中。</p><h6 id="2-函数作用域"><a href="#2-函数作用域" class="headerlink" title="2. 函数作用域"></a>2. 函数作用域</h6><p>函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。</p><p>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。  </p><p><font style="color: red;"> 注意： </font>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。在块语句中定义的变量将保留在它们已经存在的作用域中。<font style="color: red;"> 但是 </font>，let与const声明的块级作用域中例外。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 'if' 条件语句块不会创建一个新的作用域</span>    <span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'jay'</span><span class="token punctuation">;</span> <span class="token comment">// name 依然在全局作用域中</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jay</span><span class="token comment">// let 与 const 块级作用域下</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> age <span class="token operator">=</span> <span class="token string">'20'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// age is not defined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><h5 id="1-自由变量"><a href="#1-自由变量" class="headerlink" title="1. 自由变量"></a>1. 自由变量</h5><p>如下代码中，console.log(a)要得到a变量，但是在当前的作用域中没有定义a（可对比一下b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">200</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 这里的a在这里就是一个自由变量</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-作用域链"><a href="#2-作用域链" class="headerlink" title="2. 作用域链"></a>2. 作用域链</h5><p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token keyword">function</span> <span class="token constant">F1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">200</span>    <span class="token keyword">function</span> <span class="token constant">F2</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">300</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 自由变量，顺作用域链向父作用域找</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// 自由变量，顺作用域链向父作用域找</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">// 本作用域的变量</span>    <span class="token punctuation">&#125;</span>    <span class="token constant">F2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token constant">F1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-自由变量的取值"><a href="#3-自由变量的取值" class="headerlink" title="3. 自由变量的取值"></a>3. 自由变量的取值</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">show</span> <span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 10，而不是20</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token function">show</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取，无论fn函数将在哪里调用。<br>要到<strong>创建</strong>这个函数的作用域中取值,即 <strong>静态作用域</strong> 。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">20</span>  <span class="token keyword">function</span> <span class="token function">bar</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token comment">// 30</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> bar<span class="token punctuation">&#125;</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了,所以最后的结果是30</p><h4 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h4><p>JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段。</p><h6 id="解释阶段："><a href="#解释阶段：" class="headerlink" title="解释阶段："></a>解释阶段：</h6><ul><li>词法分析</li><li>语法分析</li><li>作用域规则确定</li></ul><h6 id="执行阶段："><a href="#执行阶段：" class="headerlink" title="执行阶段："></a>执行阶段：</h6><ul><li>创建执行上下文</li><li>执行函数代码</li><li>垃圾回收</li></ul><p>JavaScript解释阶段便会确定作用域规则，因此<strong>作用域在函数定义时就已经确定</strong>了，而不是在函数调用时确定，但是<strong>执行上下文是函数执行之前创建</strong>的。执行上下文最明显的就是this的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p><p>作用域和执行上下文之间最大的<strong>区别</strong>是： 执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。</p><p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域与闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包-1. 理解词法作用域和动态作用域</title>
      <link href="/2022/01/28/zuo-yong-yu-yu-bi-bao-1-li-jie-ci-fa-zuo-yong-yu-he-dong-tai-zuo-yong-yu/"/>
      <url>/2022/01/28/zuo-yong-yu-yu-bi-bao-1-li-jie-ci-fa-zuo-yong-yu-he-dong-tai-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作用域是指代码中定义变量的区域。<br>作用域规定了当前执行代码对变量的访问权限。<br>javascript采用词法作用域（lexical scoping），也就是静态作用域。</p><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul><li>词法作用域（静态作用域）：函数的作用域在函数定义时就已经决定了。  </li><li>动态作用域：函数的作用域在函数调用的时候才决定。    </li></ul><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>js为静态作用域，执行过程为：<br>执行foo函数，先从内部查找变量value是否定义，如果没有，转向作用域链父级寻找，最后返回执行结果，也就是value = 1。</li><li>假设JavaScript采用动态作用域，执行过程为：<br>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，如果还没有，就从调用函数的作用域链父级查找。<h6 id="动态作用域示例"><a href="#动态作用域示例" class="headerlink" title="动态作用域示例"></a>动态作用域示例</h6>bash语言即为动态作用域。下列代码存为test.bash文件，进入目录执行bash test.bash命令，打印的值为 2<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">value<span class="token operator">=</span><span class="token number">1</span><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    echo $value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">bar</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    local value<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    foo<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作用域与闭包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链-6. 伪代码理解new操作符</title>
      <link href="/2022/01/28/yuan-xing-yu-yuan-xing-lian-6-wei-dai-ma-li-jie-new-cao-zuo-fu/"/>
      <url>/2022/01/28/yuan-xing-yu-yuan-xing-lian-6-wei-dai-ma-li-jie-new-cao-zuo-fu/</url>
      
        <content type="html"><![CDATA[<h5 id="伪代码理解-new-操作符"><a href="#伪代码理解-new-操作符" class="headerlink" title="伪代码理解 new 操作符"></a>伪代码理解 new 操作符</h5><p>以英雄联盟提莫的蘑菇为例，训练模式技能无CD固定等级固定装备情况下，以蘑菇为对象，具有以下几点属性：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> 蘑菇 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    id<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// 用于区分,</span>    type<span class="token operator">:</span> 蘑菇，    血量<span class="token operator">:</span> <span class="token number">3</span>，    时间<span class="token operator">:</span> <span class="token number">10</span>，    伤害：<span class="token number">200</span>，    <span class="token function-variable function">种植</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 种植操作 */</span> <span class="token punctuation">&#125;</span>    <span class="token function-variable function">爆炸</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 爆炸操作 */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>提莫<span class="token punctuation">.</span><span class="token constant">R</span><span class="token punctuation">(</span>蘑菇<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="种一百蘑菇"><a href="#种一百蘑菇" class="headerlink" title="种一百蘑菇"></a>种一百蘑菇</h5><p>循环一百次：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> 蘑菇们 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> 蘑菇 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        id<span class="token operator">:</span> i<span class="token punctuation">,</span> <span class="token comment">// 用于区分,</span>        type<span class="token operator">:</span> 蘑菇，        血量<span class="token operator">:</span> <span class="token number">3</span>，        时间<span class="token operator">:</span> <span class="token number">10</span>，        伤害：<span class="token number">200</span>，        <span class="token function-variable function">种植</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 种植操作 */</span> <span class="token punctuation">&#125;</span>        <span class="token function-variable function">爆炸</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 爆炸操作 */</span> <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    蘑菇们<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>蘑菇<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>提莫<span class="token punctuation">.</span><span class="token constant">R</span><span class="token punctuation">(</span>蘑菇们<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font style='color: red;'>代码优化思考：</font><br>蘑菇的属性中，只有id是不一样的，其他的属性for循环浪费内存</p><p>从原型角度出发处理，先创建一个蘑菇原型，然后蘑菇的__proto__ 指向蘑菇原型</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> 蘑菇原型 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    type<span class="token operator">:</span> 蘑菇，    血量<span class="token operator">:</span> <span class="token number">3</span>，    时间<span class="token operator">:</span> <span class="token number">10</span>，    伤害：<span class="token number">200</span>，    <span class="token function-variable function">种植</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 种植操作 */</span> <span class="token punctuation">&#125;</span>    <span class="token function-variable function">爆炸</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 爆炸操作 */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> 蘑菇们 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> 蘑菇 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>        id<span class="token operator">:</span> i    <span class="token punctuation">&#125;</span>    蘑菇<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> 蘑菇原型<span class="token punctuation">;</span>    蘑菇们<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>蘑菇<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>提莫<span class="token punctuation">.</span><span class="token constant">R</span><span class="token punctuation">(</span>蘑菇们<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>继续优化，函数化思想：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">蘑菇</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 创建临时对象</span>    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> 蘑菇<span class="token punctuation">.</span>原型<span class="token punctuation">;</span>    obj<span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>蘑菇<span class="token punctuation">.</span>原型 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    type<span class="token operator">:</span> 蘑菇，    血量<span class="token operator">:</span> <span class="token number">3</span>，    时间<span class="token operator">:</span> <span class="token number">10</span>，    伤害：<span class="token number">200</span>，    <span class="token function-variable function">种植</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 种植操作 */</span> <span class="token punctuation">&#125;</span>    <span class="token function-variable function">爆炸</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 爆炸操作 */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> 蘑菇们 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    蘑菇们<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">蘑菇</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>提莫<span class="token punctuation">.</span><span class="token constant">R</span><span class="token punctuation">(</span>蘑菇们<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>new关键字让上述方法继续优化：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">蘑菇</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 创建临时对象       -->     new 帮忙创建临时对象    </span>    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> 蘑菇<span class="token punctuation">.</span>原型<span class="token punctuation">;</span> <span class="token comment">//       -->     new 帮忙绑定原型</span>    obj<span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>    <span class="token keyword">return</span> obj<span class="token punctuation">;</span> <span class="token comment">//                      -->     new 帮忙 return</span><span class="token punctuation">&#125;</span>蘑菇<span class="token punctuation">.</span>原型 <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token comment">//                        -->     原型统一叫 prototype</span>    type<span class="token operator">:</span> 蘑菇，    血量<span class="token operator">:</span> <span class="token number">3</span>，    时间<span class="token operator">:</span> <span class="token number">10</span>，    伤害：<span class="token number">200</span>，    <span class="token function-variable function">种植</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 种植操作 */</span> <span class="token punctuation">&#125;</span>    <span class="token function-variable function">爆炸</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 爆炸操作 */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只要你在「蘑菇」前面使用 new 关键字，那么可以少做四件事情：</p><ul><li>不用创建临时对象，因为 new 会帮你做（你使用「this」就可以访问到临时对象）</li><li>不用绑定原型，因为 new 会帮你做（new 为了知道原型在哪，所以指定原型的名字为 prototype）；</li><li>不用 return 临时对象，因为 new 会帮你做；</li><li>不要给原型想名字了，因为 new 指定名字为 prototype。</li></ul><h5 id="new-实现"><a href="#new-实现" class="headerlink" title="new 实现"></a>new 实现</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">蘑菇</span> <span class="token punctuation">(</span><span class="token parameter">id</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">蘑菇</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    type<span class="token operator">:</span> 蘑菇，    血量<span class="token operator">:</span> <span class="token number">3</span>，    时间<span class="token operator">:</span> <span class="token number">10</span>，    伤害：<span class="token number">200</span>，    <span class="token function-variable function">种植</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 种植操作 */</span> <span class="token punctuation">&#125;</span>    <span class="token function-variable function">爆炸</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 爆炸操作 */</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> 蘑菇们 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    蘑菇们<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">蘑菇</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>提莫<span class="token punctuation">.</span><span class="token constant">R</span><span class="token punctuation">(</span>蘑菇们<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="注意-constructor-属性"><a href="#注意-constructor-属性" class="headerlink" title="注意 constructor 属性"></a>注意 constructor 属性</h5><p>函数的prototype属性会默认生成constructor属性，指向构造函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">蘑菇</span><span class="token punctuation">.</span>prototype <span class="token comment">// &#123;constructor: ƒ&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所以写法优化为：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token class-name">蘑菇</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>type <span class="token operator">=</span> 蘑菇<span class="token punctuation">;</span><span class="token class-name">蘑菇</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>血量 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token class-name">蘑菇</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>时间 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token class-name">蘑菇</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>伤害 <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span><span class="token class-name">蘑菇</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">种植</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 种植操作 */</span> <span class="token punctuation">&#125;</span><span class="token class-name">蘑菇</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">爆炸</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">/* 爆炸操作 */</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型与原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链-5.理解es6class构造以及继承的底层实现原理</title>
      <link href="/2022/01/28/yuan-xing-yu-yuan-xing-lian-5-li-jie-es6class-gou-zao-yi-ji-ji-cheng-de-di-ceng-shi-xian-yuan-li/"/>
      <url>/2022/01/28/yuan-xing-yu-yuan-xing-lian-5-li-jie-es6class-gou-zao-yi-ji-ji-cheng-de-di-ceng-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="ES5创建类"><a href="#ES5创建类" class="headerlink" title="ES5创建类"></a>ES5创建类</h5><p>ES5中创建类的实例，以及如何禁止用户把类当作普通函数执行（ new target）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// console.log(new.target);</span>    <span class="token comment">// ES6增加的语法，如果是通过new执行的，返回的结果是当前创建的类；</span>    <span class="token comment">// 如果是当作普通函执行（Person()），返回的是undefined</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">new</span><span class="token punctuation">.</span>target <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SyntaxError</span><span class="token punctuation">(</span><span class="token string">'当前Person不能作为一个普通函数执行'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>            <span class="token comment">// new执行的时候，this是当前类的实例，this.xxx=xxx是给当前实例增加的私有属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 原型上存放的是公有的属性和方法：给创建的实例使用</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>    <span class="token function-variable function">say</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, i am </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> years old</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 把Person当作一个普通的对象，给对象设置的私有属性</span>Person<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello, study hard please!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jay'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>p1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// my name is jay, i am 20 years old</span>p1<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p1.study is not a function 私有属性不会继承</span>Person<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello, study hard please!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ES6中创建类"><a href="#ES6中创建类" class="headerlink" title="ES6中创建类"></a>ES6中创建类</h5><p>class的内部是通过Object.definePropterty来定义的，把公共方法定义在原型链上。把静态方法定义再类上</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'jay'</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 给实例设置的私有属性</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 直接在大括号中编写的方法都设置在类的原型上，ES6默认把constructor的问题解决了，此时原型上的constructor指向的就是Person</span>    <span class="token function">say</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, i am </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> years old</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 把Person当作普通对象设置属性和方法，只需要在设置的方法前加static即可</span>    <span class="token keyword">static</span> <span class="token function">study</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello, study hard please!'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'renee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// my name is jay, i am 20 years old</span>p1<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 p1.study is not a function</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// 'jay'</span>p1<span class="token punctuation">.</span>age<span class="token punctuation">;</span> <span class="token comment">// 20</span><span class="token comment">// Person(); </span><span class="token comment">// 报错 ES6中使用class创建的类，天生自带new.target的验证，不允许把创建的类当作普通函数执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><p>Object.create:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'parent'</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">smoking</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'smoking'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 继承公有属性 Object.create是如何实现的</span><span class="token keyword">function</span> <span class="token function">create</span> <span class="token punctuation">(</span><span class="token parameter">Pproto</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token function-variable function">Fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 创建一个空函数 没有私有属性和公用属性</span>    <span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Pproto<span class="token punctuation">;</span> <span class="token comment">// 将父类的公有属性放在这个函数上</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 产生的实例就只有公有属性了</span><span class="token punctuation">&#125;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>constructor<span class="token operator">:</span> <span class="token punctuation">&#123;</span>value<span class="token operator">:</span> Child<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>extends继承:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arg<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sum</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 创建了Child类，并且让Child类继承了Person类</span>    <span class="token comment">// 1.把Person中的私有属性继承过来设置给了子类实例的私有属性</span>    <span class="token comment">// 2.让子类实例的原型链上能够找到Person父类的原型（这样子类的实例就可以调用父类原型上的方法了）</span>        <span class="token comment">// constructor () &#123;&#125; // 报错</span>    <span class="token comment">// ----------------</span>    <span class="token comment">// 我们可以不写constructor，浏览器会默认创建它，而且默认就把父类私有的属性继承过来了（而且把传给子类的参数值也传递给父类了）</span>    <span class="token comment">// constructor (...arg) &#123;</span>        <span class="token comment">// arg：传递给子类的参数（数组），[剩余运算符]</span>        <span class="token comment">// super(...arg)</span>        <span class="token comment">// [扩展运算符] 把arg中每一项值展开，分别传递给父类方法super(10，20，30) </span>    <span class="token comment">// &#125; </span>    <span class="token comment">// ----------------</span>    <span class="token comment">// 很多时候我们不仅要继承父类私有的，还需要给子类增加一些额外私有的，此时就必须写constructor，但是一定要在constructor中第一行写上super，否则会报错</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token comment">// super must be first</span>        <span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> z<span class="token punctuation">]</span> <span class="token operator">=</span> arg<span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'arg: '</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z    <span class="token punctuation">&#125;</span>         <span class="token comment">// constructor (x,y,z) &#123;</span>    <span class="token comment">//    super() // Person.prototype.constructor.call(this)</span>    <span class="token comment">//    this.z = z;</span>    <span class="token comment">// &#125; </span>        <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'我是公有方法'</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">static</span> <span class="token function">fn1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'我是私有方法'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token comment">// arg: [10, 20, 30];</span>c<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '我是公有方法'</span>c<span class="token punctuation">.</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c.fn1 is not a function</span>c<span class="token punctuation">.</span>z<span class="token punctuation">;</span> <span class="token comment">// 30</span>c<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ES6继承的实现原理"><a href="#ES6继承的实现原理" class="headerlink" title="ES6继承的实现原理"></a>ES6继承的实现原理</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 负责将原型的方法和静态方法定义在构造函数上的</span><span class="token keyword">function</span> <span class="token function">defineProperties</span> <span class="token punctuation">(</span><span class="token parameter">constructor<span class="token punctuation">,</span> properties</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> properties<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>            <span class="token operator">...</span>properties<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>            enumerable<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>            writeable<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>            configurable<span class="token operator">:</span><span class="token boolean">true</span>        <span class="token punctuation">&#125;</span>        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>constructor<span class="token punctuation">,</span> properties<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 对不同的属性做处理 如果是原型上的方法挂载Class.prototype 如果是静态方法放在 Class上</span><span class="token keyword">function</span> <span class="token function">_createClass</span> <span class="token punctuation">(</span><span class="token parameter">con<span class="token punctuation">,</span>protoProperty<span class="token punctuation">,</span> staticProperty</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>protoProperty<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">defineProperties</span><span class="token punctuation">(</span>con<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> protoProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>staticProperty<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">defineProperties</span><span class="token punctuation">(</span>con<span class="token punctuation">,</span> staticProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 父类</span><span class="token keyword">var</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 类的调用检测</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'zfpx'</span>        <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>a<span class="token operator">:</span><span class="token number">100</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 用来描述这个类的原型方法和静态方法</span>    <span class="token function">_createClass</span><span class="token punctuation">(</span>Parent<span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token comment">// 第一个数组表示的是公共方法的描述 descirptor</span>        <span class="token punctuation">&#123;</span>key<span class="token operator">:</span> <span class="token string">'getName'</span><span class="token punctuation">,</span> <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">1000</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span> <span class="token comment">//描述静态的方法</span>        <span class="token punctuation">&#123;</span>key<span class="token operator">:</span> <span class="token string">'fn'</span><span class="token punctuation">,</span> <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> Parent<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 类的调用检测</span><span class="token keyword">function</span> <span class="token function">_classCallCheck</span> <span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> constructor</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//检查当前类  有没有new出来的，不是new出来的this属于window</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">constructor</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">'without new'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 继承共有方法和静态方法</span><span class="token keyword">function</span> <span class="token function">_inherits</span> <span class="token punctuation">(</span><span class="token parameter">subClass<span class="token punctuation">,</span> superClass</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 子类继承父类的公有方法</span>    subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>        constructor<span class="token operator">:</span> <span class="token punctuation">&#123;</span>value<span class="token operator">:</span> subClass<span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 也要让子类继承父类的静态方法</span>    subClass<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> superClass<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">Child</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Parent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 表示儿子继承Parent类，要包多一层不然传参会传到Child上</span>    <span class="token function">_inherits</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 表示继承 儿子继承父亲</span>    <span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 类的调用检查</span>        <span class="token comment">// 在子类中应该调用父类的构造函数</span>        <span class="token comment">// Parent.call(this);</span>        <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> obj <span class="token operator">=</span>  Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Child.__proto__ = Object.getPrototypeOf(Child) 继承父类的私有方法，为了保险不用Parent.call(this)，因为不一定继承父类</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//如果是对象把obj作为实例</span>            that <span class="token operator">=</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> that<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> Child<span class="token punctuation">&#125;</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型与原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链-4-new一个对象的详细过程与手写new</title>
      <link href="/2022/01/28/yuan-xing-yu-yuan-xing-lian-4-new-yi-ge-dui-xiang-de-xiang-xi-guo-cheng-yu-shou-xie-new/"/>
      <url>/2022/01/28/yuan-xing-yu-yuan-xing-lian-4-new-yi-ge-dui-xiang-de-xiang-xi-guo-cheng-yu-shou-xie-new/</url>
      
        <content type="html"><![CDATA[<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="ES5创建类"><a href="#ES5创建类" class="headerlink" title="ES5创建类"></a>ES5创建类</h5><p>ES5中创建类的实例，以及如何禁止用户把类当作普通函数执行（ new target）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// console.log(new.target);</span>    <span class="token comment">// ES6增加的语法，如果是通过new执行的，返回的结果是当前创建的类；</span>    <span class="token comment">// 如果是当作普通函执行（Person()），返回的是undefined</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">new</span><span class="token punctuation">.</span>target <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">SyntaxError</span><span class="token punctuation">(</span><span class="token string">'当前Person不能作为一个普通函数执行'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>            <span class="token comment">// new执行的时候，this是当前类的实例，this.xxx=xxx是给当前实例增加的私有属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 原型上存放的是公有的属性和方法：给创建的实例使用</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    constructor<span class="token operator">:</span> Person<span class="token punctuation">,</span>    <span class="token function-variable function">say</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, i am </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> years old</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 把Person当作一个普通的对象，给对象设置的私有属性</span>Person<span class="token punctuation">.</span><span class="token function-variable function">study</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello, study hard please!'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jay'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span>p1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// my name is jay, i am 20 years old</span>p1<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// p1.study is not a function 私有属性不会继承</span>Person<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello, study hard please!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ES6中创建类"><a href="#ES6中创建类" class="headerlink" title="ES6中创建类"></a>ES6中创建类</h5><p>class的内部是通过Object.definePropterty来定义的，把公共方法定义在原型链上。把静态方法定义再类上</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">'jay'</span><span class="token punctuation">,</span> age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">// 给实例设置的私有属性</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 直接在大括号中编写的方法都设置在类的原型上，ES6默认把constructor的问题解决了，此时原型上的constructor指向的就是Person</span>    <span class="token function">say</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string">, i am </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">$&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">&#125;</span></span><span class="token string"> years old</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>        <span class="token comment">// 把Person当作普通对象设置属性和方法，只需要在设置的方法前加static即可</span>    <span class="token keyword">static</span> <span class="token function">study</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello, study hard please!'</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'renee'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p1<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// my name is jay, i am 20 years old</span>p1<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 p1.study is not a function</span>p1<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// 'jay'</span>p1<span class="token punctuation">.</span>age<span class="token punctuation">;</span> <span class="token comment">// 20</span><span class="token comment">// Person(); </span><span class="token comment">// 报错 ES6中使用class创建的类，天生自带new.target的验证，不允许把创建的类当作普通函数执行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h5><p>Object.create:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'parent'</span><span class="token punctuation">&#125;</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">smoking</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'smoking'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 继承公有属性 Object.create是如何实现的</span><span class="token keyword">function</span> <span class="token function">create</span> <span class="token punctuation">(</span><span class="token parameter">Pproto</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token function-variable function">Fn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 创建一个空函数 没有私有属性和公用属性</span>    <span class="token class-name">Fn</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Pproto<span class="token punctuation">;</span> <span class="token comment">// 将父类的公有属性放在这个函数上</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 产生的实例就只有公有属性了</span><span class="token punctuation">&#125;</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Parent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>constructor<span class="token operator">:</span> <span class="token punctuation">&#123;</span>value<span class="token operator">:</span> Child<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Child</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>extends继承:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> arg<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sum</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">&#123;</span>     <span class="token comment">// 创建了Child类，并且让Child类继承了Person类</span>    <span class="token comment">// 1.把Person中的私有属性继承过来设置给了子类实例的私有属性</span>    <span class="token comment">// 2.让子类实例的原型链上能够找到Person父类的原型（这样子类的实例就可以调用父类原型上的方法了）</span>        <span class="token comment">// constructor () &#123;&#125; // 报错</span>    <span class="token comment">// ----------------</span>    <span class="token comment">// 我们可以不写constructor，浏览器会默认创建它，而且默认就把父类私有的属性继承过来了（而且把传给子类的参数值也传递给父类了）</span>    <span class="token comment">// constructor (...arg) &#123;</span>        <span class="token comment">// arg：传递给子类的参数（数组），[剩余运算符]</span>        <span class="token comment">// super(...arg)</span>        <span class="token comment">// [扩展运算符] 把arg中每一项值展开，分别传递给父类方法super(10，20，30) </span>    <span class="token comment">// &#125; </span>    <span class="token comment">// ----------------</span>    <span class="token comment">// 很多时候我们不仅要继承父类私有的，还需要给子类增加一些额外私有的，此时就必须写constructor，但是一定要在constructor中第一行写上super，否则会报错</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">...</span>arg<span class="token punctuation">)</span> <span class="token comment">// super must be first</span>        <span class="token keyword">let</span> <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">,</span> z<span class="token punctuation">]</span> <span class="token operator">=</span> arg<span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'arg: '</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>z <span class="token operator">=</span> z    <span class="token punctuation">&#125;</span>         <span class="token comment">// constructor (x,y,z) &#123;</span>    <span class="token comment">//    super() // Person.prototype.constructor.call(this)</span>    <span class="token comment">//    this.z = z;</span>    <span class="token comment">// &#125; </span>        <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'我是公有方法'</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">static</span> <span class="token function">fn1</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'我是私有方法'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token comment">// arg: [10, 20, 30];</span>c<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '我是公有方法'</span>c<span class="token punctuation">.</span><span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c.fn1 is not a function</span>c<span class="token punctuation">.</span>z<span class="token punctuation">;</span> <span class="token comment">// 30</span>c<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="ES6继承的实现原理"><a href="#ES6继承的实现原理" class="headerlink" title="ES6继承的实现原理"></a>ES6继承的实现原理</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 负责将原型的方法和静态方法定义在构造函数上的</span><span class="token keyword">function</span> <span class="token function">defineProperties</span> <span class="token punctuation">(</span><span class="token parameter">constructor<span class="token punctuation">,</span> properties</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> length <span class="token operator">=</span> properties<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>            <span class="token operator">...</span>properties<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>            enumerable<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>            writeable<span class="token operator">:</span><span class="token boolean">true</span><span class="token punctuation">,</span>            configurable<span class="token operator">:</span><span class="token boolean">true</span>        <span class="token punctuation">&#125;</span>        Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>constructor<span class="token punctuation">,</span> properties<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 对不同的属性做处理 如果是原型上的方法挂载Class.prototype 如果是静态方法放在 Class上</span><span class="token keyword">function</span> <span class="token function">_createClass</span> <span class="token punctuation">(</span><span class="token parameter">con<span class="token punctuation">,</span>protoProperty<span class="token punctuation">,</span> staticProperty</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>protoProperty<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">defineProperties</span><span class="token punctuation">(</span>con<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> protoProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>staticProperty<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">defineProperties</span><span class="token punctuation">(</span>con<span class="token punctuation">,</span> staticProperty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 父类</span><span class="token keyword">var</span> <span class="token function-variable function">Parent</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function">Parent</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 类的调用检测</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'zfpx'</span>        <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>a<span class="token operator">:</span><span class="token number">100</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 用来描述这个类的原型方法和静态方法</span>    <span class="token function">_createClass</span><span class="token punctuation">(</span>Parent<span class="token punctuation">,</span> <span class="token punctuation">[</span> <span class="token comment">// 第一个数组表示的是公共方法的描述 descirptor</span>        <span class="token punctuation">&#123;</span>key<span class="token operator">:</span> <span class="token string">'getName'</span><span class="token punctuation">,</span> <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">1000</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span> <span class="token comment">//描述静态的方法</span>        <span class="token punctuation">&#123;</span>key<span class="token operator">:</span> <span class="token string">'fn'</span><span class="token punctuation">,</span> <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token number">100</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> Parent<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">// 类的调用检测</span><span class="token keyword">function</span> <span class="token function">_classCallCheck</span> <span class="token punctuation">(</span><span class="token parameter">instance<span class="token punctuation">,</span> constructor</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//检查当前类  有没有new出来的，不是new出来的this属于window</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>instance <span class="token keyword">instanceof</span> <span class="token class-name">constructor</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token string">'without new'</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 继承共有方法和静态方法</span><span class="token keyword">function</span> <span class="token function">_inherits</span> <span class="token punctuation">(</span><span class="token parameter">subClass<span class="token punctuation">,</span> superClass</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 子类继承父类的公有方法</span>    subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>        constructor<span class="token operator">:</span> <span class="token punctuation">&#123;</span>value<span class="token operator">:</span> subClass<span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 也要让子类继承父类的静态方法</span>    subClass<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> superClass<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> <span class="token function-variable function">Child</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">Parent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 表示儿子继承Parent类，要包多一层不然传参会传到Child上</span>    <span class="token function">_inherits</span><span class="token punctuation">(</span>Child<span class="token punctuation">,</span> Parent<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 表示继承 儿子继承父亲</span>    <span class="token keyword">function</span> <span class="token function">Child</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 类的调用检查</span>        <span class="token comment">// 在子类中应该调用父类的构造函数</span>        <span class="token comment">// Parent.call(this);</span>        <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> Child<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> that <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> obj <span class="token operator">=</span>  Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Child<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Child.__proto__ = Object.getPrototypeOf(Child) 继承父类的私有方法，为了保险不用Parent.call(this)，因为不一定继承父类</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//如果是对象把obj作为实例</span>            that <span class="token operator">=</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> that<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> Child<span class="token punctuation">&#125;</span><span class="token punctuation">(</span>Parent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">let</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型与原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链-3-JS实现继承的几种方式与优缺点</title>
      <link href="/2022/01/25/yuan-xing-yu-yuan-xing-lian-3-js-shi-xian-ji-cheng-de-ji-chong-fang-shi-yu-you-que-dian/"/>
      <url>/2022/01/25/yuan-xing-yu-yuan-xing-lian-3-js-shi-xian-ji-cheng-de-ji-chong-fang-shi-yu-you-que-dian/</url>
      
        <content type="html"><![CDATA[<h3 id="JS实现继承的方法以及优缺点"><a href="#JS实现继承的方法以及优缺点" class="headerlink" title="JS实现继承的方法以及优缺点"></a>JS实现继承的方法以及优缺点</h3><p>整理《javascript高级程序设计》中继承的方法以及优缺点。</p><h4 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h4><p>ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。<br>原型链继承的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<br>简单回顾一下构造函数、原型和实例的关系：<strong>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。</strong><br>那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>property <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSuperValue</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subProperty <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getSubValue</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>subproperty<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span><span class="token function">getSuperValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码定义了两个类型：SuperType和SubType。每个类型分别有一个属性和一个方法。它们的主要区别是SubType继承了SuperType，而继承是通过创建SuperType的实例，并将该实例赋给SubType.prototype实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于SuperType的实例中的所有属性和方法，现在也存在于SubType.prototype中了。在确立了继承关系之后，我们给SubType.prototype添加了一个方法，这样就在继承了SuperType的属性和方法的基础上又添加了一个新方法。</p><p><img src="image-20220125235004133.png">  </p><p>要注意instance.constructor现在指向的是SuperType，这是因为原来SubType.prototype中的constructor被重写了的缘故。实际上，不是SubType的原型的constructor属性被重写了，而是SubType的原型指向了另一个对象——SuperType的原型，而这个原型对象的constructor属性指向的是SuperType。  </p><p>别忘记默认的原型，事实上，前面例子中展示的原型链还少一环。我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。这也正是所有自定义类型都会继承toString()、valueOf()等默认方法的根本原因。  </p><p><img src="image-20220125235104412.png"></p><p><font style="color: red;"> 缺点: </font></p><ul><li>子类实例共享属性，造成实例间的属性会相互影响。(包含引用类型值的原型)<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">//继承了SuperType</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//"red,blue,green,black"</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//"red,blue,green,black"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>原型链的第二个问题是，在创建子类型的实例时，不能向超类型的构造函数中传递参数。实际上，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。有鉴于此，再加上前面刚刚讨论过的由于原型中包含引用类型值所带来的问题，实践中很少会单独使用原型链</li></ul><h4 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h4><p>在子类型构造函数的内部调用超类型构造函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "blue", "green", "black"]</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "blue", "green"]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过使用call()方法（或apply()方法也可以），我们实际上是在（未来将要）新创建的SubType实例的环境下调用了SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。结果，SubType的每个实例就都会具有自己的colors属性的副本了。  </p><p>对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 继承了SuperType, 同时还传递了参数</span>    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'Jay'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 实例属性</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jay</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font style="color: red;"> 缺点: </font>  </p><ul><li>方法都在构造函数中定义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式<h4 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h4>组合继承（combination inheritance），有时候也叫做伪经典继承，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">SuperType</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">SubType</span> <span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 继承属性</span>    <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 继承方法</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'jay'</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'black'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "blue", "green", "black"]</span>instance1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jay</span>instance1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span><span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">'chou'</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ["red", "blue", "green"]</span>instance2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// chou</span>instance2<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 21</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JavaScript中最常用的继承模式。而且，instanceof和isPrototypeOf也能够用于识别基于组合继承创建的对象。<br><font style="color: red;"> 缺点: </font>  </li><li>无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部，造成内存浪费<h4 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h4>这种方法并没有使用严格意义上的构造函数。借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">object</span> <span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token constant">F</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>    <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">"Nicholas"</span><span class="token punctuation">,</span>    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"Shelby"</span><span class="token punctuation">,</span> <span class="token string">"Court"</span><span class="token punctuation">,</span> <span class="token string">"Van"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>anotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Greg"</span><span class="token punctuation">;</span>anotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Rob"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> yetAnotherPerson <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>yetAnotherPerson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Linda"</span><span class="token punctuation">;</span>yetAnotherPerson<span class="token punctuation">.</span>friends<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"Barbie"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// "Shelby,Court,Van,Rob,Barbie"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>ECMAScript 5通过新增Object.create()方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，Object.create()与object()方法的行为相同。  </li></ul><p>Object.create()方法的第二个参数与Object.defineProperties()方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">"Nicholas"</span><span class="token punctuation">,</span>    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"Shelby"</span><span class="token punctuation">,</span> <span class="token string">"Court"</span><span class="token punctuation">,</span> <span class="token string">"Van"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token punctuation">&#123;</span>        value<span class="token operator">:</span> <span class="token string">"Greg"</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>anotherPerson<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//"Greg"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font style="color: red;"> 缺点: </font></p><ul><li>在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。不过别忘了，包含引用类型值的属性始终都会共享相应的值，就像使用原型模式一样<h4 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h4>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真的是它做了所有工作一样返回对象<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">createAnother</span> <span class="token punctuation">(</span><span class="token parameter">original</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//通过调用函数创建一个新对象</span>    clone<span class="token punctuation">.</span><span class="token function-variable function">sayHi</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token comment">//以某种方式来增强这个对象</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> clone<span class="token punctuation">;</span>                    <span class="token comment">//返回这个对象</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>在这个例子中，createAnother()函数接收了一个参数，也就是将要作为新对象基础的对象。然后，把这个对象（original）传递给object()函数，将返回的结果赋值给clone。再为clone对象添加一个新方法sayHi()，最后返回clone对象。可以像下面这样来使用createAnother()函数：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    name<span class="token operator">:</span> <span class="token string">"Nicholas"</span><span class="token punctuation">,</span>    friends<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"Shelby"</span><span class="token punctuation">,</span> <span class="token string">"Court"</span><span class="token punctuation">,</span> <span class="token string">"Van"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> anotherPerson <span class="token operator">=</span> <span class="token function">createAnother</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>anotherPerson<span class="token punctuation">.</span><span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//"hi"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>这个例子中的代码基于person返回了一个新对象——anotherPerson。新对象不仅具有person的所有属性和方法，而且还有自己的sayHi()方法。<br><font style="color: red;"> 缺点: </font></li><li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率；这一点与构造函数模式类似<h4 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h4></li></ul><p><img src="image-20220125235244585.png"></p><p>所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。  </p><p>其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">inheritPrototype</span> <span class="token punctuation">(</span><span class="token parameter">subType<span class="token punctuation">,</span> superType</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建对象</span>    prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span> <span class="token comment">// 增强对象</span>    subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span> <span class="token comment">// 指定对象</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个示例中的inheritPrototype()函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认的constructor属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。<br> <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"> <span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"red"</span><span class="token punctuation">,</span> <span class="token string">"blue"</span><span class="token punctuation">,</span> <span class="token string">"green"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>      <span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">inheritPrototype</span><span class="token punctuation">(</span>SubType<span class="token punctuation">,</span> SuperType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br> 这个例子的高效率体现在它只调用了一次SuperType构造函数，并且因此避免了在SubType.prototype上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用instanceof和isPrototypeOf()。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型与原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链-2-instanceof的底层实现原理与手动实现</title>
      <link href="/2022/01/24/yuan-xing-yu-yuan-xing-lian-2-instanceof-de-di-ceng-shi-xian-yuan-li-yu-shou-dong-shi-xian/"/>
      <url>/2022/01/24/yuan-xing-yu-yuan-xing-lian-2-instanceof-de-di-ceng-shi-xian-yuan-li-yu-shou-dong-shi-xian/</url>
      
        <content type="html"><![CDATA[<h5 id="instanceof的作用"><a href="#instanceof的作用" class="headerlink" title="instanceof的作用"></a>instanceof的作用</h5><ul><li>引用数据类型判断：用来判断一个引用数据类型是否属于构造函数</li><li>继承关系判断：用来判断一个实例是否属于它的父类型<h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5>首先判断左边的变量的隐式原型（proto）是否全等于右边的变量的显示原型（prototype），如果相等返回true，如果不等则沿着原型链依次向上进行判断，如果都不等则返回false。<h5 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> <span class="token function-variable function">new_instance_of</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">L</span><span class="token punctuation">,</span> <span class="token constant">R</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> R_prototype <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>    <span class="token keyword">var</span> L_proto <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断为后续添加条件使用，此处没卵用</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L_proto <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L_proto <span class="token operator">===</span> R_prototype<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        L_proto <span class="token operator">=</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span> <span class="token comment">// 貌似没卵用</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">new_instance_of</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token comment">// 简写</span><span class="token keyword">function</span> <span class="token function">test_instance_of</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token constant">L</span><span class="token punctuation">,</span> <span class="token constant">R</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token constant">L</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">R</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型与原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链-1. 理解原型设计模式以及JavaScript中的原型规则</title>
      <link href="/2022/01/21/yuan-xing-yu-yuan-xing-lian-1-li-jie-yuan-xing-she-ji-mo-shi-yi-ji-javascript-zhong-de-yuan-xing-gui-ze/"/>
      <url>/2022/01/21/yuan-xing-yu-yuan-xing-lian-1-li-jie-yuan-xing-she-ji-mo-shi-yi-ji-javascript-zhong-de-yuan-xing-gui-ze/</url>
      
        <content type="html"><![CDATA[<h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><h6 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h6><p>在函数内创建一个对象，给对象赋予属性及方法再将对象返回。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> People <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    People<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jay'</span><span class="token punctuation">;</span>    People<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">'20'</span><span class="token punctuation">;</span>    People<span class="token punctuation">.</span><span class="token function-variable function">sex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'man'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> People<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jay</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">sex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// man</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="二、构造函数模式"><a href="#二、构造函数模式" class="headerlink" title="二、构造函数模式"></a>二、构造函数模式</h6><p>无需在函数内部重新创建对象，而是用this指代</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jay'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">'20'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">sex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'man'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jay</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">sex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// man</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="三、原型模式"><a href="#三、原型模式" class="headerlink" title="三、原型模式"></a>三、原型模式</h6><p>函数中不对属性进行定义，利用prototype属性对属性进行定义，可以让所有对象实例共享它所包含的属性及方法。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jay'</span><span class="token punctuation">;</span>    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">'20'</span><span class="token punctuation">;</span>    <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sex</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token string">'man'</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jay</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">sex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// man</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="四、混合模式"><a href="#四、混合模式" class="headerlink" title="四、混合模式"></a>四、混合模式</h6><p>原型模式+构造函数模式。这种模式中，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jay'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">'20'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jay</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="五、动态原型模式"><a href="#五、动态原型模式" class="headerlink" title="五、动态原型模式"></a>五、动态原型模式</h6><p>将所有信息封装在了构造函数中，而通过构造函数中初始化原型，这个可以通过判断该方法是否有效而选择是否需要初始化原型。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'jay'</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">'20'</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>_sayName<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        Person<span class="token punctuation">.</span>_sayName <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jay</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="原型规则"><a href="#原型规则" class="headerlink" title="原型规则"></a>原型规则</h4><h6 id="一、原型规则"><a href="#一、原型规则" class="headerlink" title="一、原型规则"></a>一、原型规则</h6><ul><li>所有的引用类型（数组、对象、函数），都具有对象特征，即可自由扩展属性<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [a: 1]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>所有的引用类型，都有一个_proto_ 属性（隐式原型），属性值是一个普通对象</li><li>所有函数，都具有一个prototype（显示原型），属性值也是一个普通原型</li><li>所有的引用类型（数组、对象、函数），其隐式原型指向其构造函数的显式原型（obj.proto === Object.prototype）</li><li>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_（即它的构造函数的prototype）中去寻找<h6 id="二、原型对象-prototype"><a href="#二、原型对象-prototype" class="headerlink" title="二、原型对象: prototype"></a>二、原型对象: prototype</h6>在js中，函数对象其中一个属性：原型对象prototype。普通对象没有prototype属性，但有_proto_属性。 原型的作用就是给这个类的每一个对象都添加一个统一的方法，在原型中定义的方法和属性被所有实例对象所共享。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 通过person.prototype设置函数对象属性</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'jay'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// jay // test 继承getName属性</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="三、原型链"><a href="#三、原型链" class="headerlink" title="三、原型链"></a>三、原型链</h6>当试图得到一个对象f的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_（即它的构造函数的prototype）obj._proto_中去寻找；当obj._proto也没有时，便会在obj._proto.proto（即obj的构造函数的prototype的构造函数的prototype）中寻找；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原型与原型链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-10. js数字处理精度丢失</title>
      <link href="/2022/01/20/js-bian-liang-yu-lei-xing-10-js-shu-zi-chu-li-jing-du-diu-shi/"/>
      <url>/2022/01/20/js-bian-liang-yu-lei-xing-10-js-shu-zi-chu-li-jing-du-diu-shi/</url>
      
        <content type="html"><![CDATA[<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token number">0.1</span><span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0.30000000000000004</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于浮点数的四则运算，几乎所有的编程语言都会有类似精度误差的问题，只不过在 C++/C#/Java 这些语言中已经封装好了方法来避免精度的问题，而 JavaScript 是一门弱类型的语言，从设计思想上就没有对浮点数有个严格的数据类型，所以精度误差的问题就显得格外突出。    </p><h6 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h6><p>计算机是二进制计算，对于0.1 + 0.2的运算，计算机会做下列的相关处理：<br>0.1 =&gt; 0.0001 1001 1001 1001…（无限循环）</p><p>0.2 =&gt; 0.0011 0011 0011 0011…（无限循环）<br>对于无限循环的小数，计算机会进行四舍五入处理。进行双精度浮点数的小数部分最多支持 52 位，所以两者相加之后得到这么一串 0.0100110011001100110011001100110011001100110011001100 因浮点数小数位的限制而截断的二进制数字，这时候，我们再把它转换为十进制，就成了 0.30000000000000004。</p><h6 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h6><ul><li>方法一 toFixed()<br>指定要保留的小数位数(0.1+0.2).toFixed(1) = 0.3;这个方法toFixed是进行四舍五入的也不是很精准，对于计算金额这种严谨的问题，不推荐使用，而且不同浏览器对toFixed的计算结果也存在差异。</li><li>方法二 升级降级法<br>把需要计算的数字升级（乘以10的n次幂）成计算机能够精确识别的整数，等计算完毕再降级（除以10的n次幂），这是大部分编程语言处理精度差异的通用方法。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">(</span><span class="token number">0.1</span><span class="token operator">*</span><span class="token number">10</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0.3</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-9. 隐式类型转换</title>
      <link href="/2022/01/19/js-bian-liang-yu-lei-xing-9-yin-shi-lei-xing-zhuan-huan/"/>
      <url>/2022/01/19/js-bian-liang-yu-lei-xing-9-yin-shi-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>定义：JavaScript 默认自动转换，没有任何警告 隐式类型转换常见场景</p><h6 id="自动转换Boolean"><a href="#自动转换Boolean" class="headerlink" title="自动转换Boolean"></a>自动转换Boolean</h6><p>应用场景： if (表达式) {}</p><h6 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h6><p>在非 Numeber 类型进行数学运算符 <font style="color: red;">‘-‘</font> , <font style="color: red;">‘*’</font> , <font style="color: red;">‘/‘</font> 时，会先将非 Number 转换成 Number 类型。<font style="color: red;"> + </font>运算符要考虑字符串的情况，在操作数中存在字符串时，优先转换成字符串。<br><font style="color: red;">+ </font>运算符其中一个操作数是字符串的话，会进行连接字符串的操作。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'2'</span> <span class="token comment">// '12'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font style="color: red;"> + </font>操作符的执行顺序是：</p><ul><li>当一侧操作数为 String 类型，会优先将另一侧转换为字符串类型。</li><li>当一侧操作数为 Number 类型，另一侧为原始类型，则将原始类型转换为 Number 类型。</li><li>当一侧操作数为 Number 类型，另一侧为引用类型，将引用类型和 Number 类型转换成字符串后拼接。<h6 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h6>只有在 JavaScript 表达式或语句中需要用到数字或字符串时，对象才被隐式转换。<br>当需要将对象转换为数字时，需要三个步骤:</li><li>调用 valueOf()。如果结果是原始值（不是一个对象），则将其转换为一个数字。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">&#123;</span><span class="token function-variable function">valueOf</span><span class="token operator">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 15</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>否则，调用 toString() 方法。如果结果是原始值，则将其转换为一个数字。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">&#123;</span><span class="token function-variable function">toString</span><span class="token operator">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">// 15</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>否则，抛出一个类型错误。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">&#123;</span><span class="token function-variable function">toString</span><span class="token operator">:</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token comment">//TypeError: Cannot convert object to primitive value</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>问题： {} + {} = ?<br>“[object Object][object Object]”<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 这里他们都是字符串</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">'false'</span><span class="token punctuation">)</span> <span class="token comment">// true</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token comment">// true</span><span class="token comment">// 问题:如何让：a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3</span><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    value<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-8. 判断js数据类型的方式</title>
      <link href="/2022/01/18/js-bian-liang-yu-lei-xing-8-pan-duan-js-shu-ju-lei-xing-de-fang-shi/"/>
      <url>/2022/01/18/js-bian-liang-yu-lei-xing-8-pan-duan-js-shu-ju-lei-xing-de-fang-shi/</url>
      
        <content type="html"><![CDATA[<p>数据类型分为基本类型和引用类型。</p><h5 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h5><p>String, Number, Boolean, Null, Undefined, Symbol</p><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>Object, Array, Date, Function, Error, RegExp, Math, Number, String, Boolean, Globle</p><h5 id="js内置类型"><a href="#js内置类型" class="headerlink" title="js内置类型"></a>js内置类型</h5><p>String, Number, Boolean, Null, Undefined, Symbol, Object</p><h5 id="判断数据类型的方法"><a href="#判断数据类型的方法" class="headerlink" title="判断数据类型的方法"></a>判断数据类型的方法</h5><p>typeof、instanceof、constructor、Object.prototype.toString.call()  </p><ul><li><h6 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h6>typeof可以对基本类型（包括function）做出准确的判断，但对于引用类型，用它就有点力不从心了。<br>typeof 返回一个表示数据类型的字符串，返回结果包括：<font color="blue"> number、 </font><font color="blue"> boolean、 </font><font color="blue"> string、 </font><font color="blue"> object、 </font><font color="blue"> undefined、 </font><font color="blue"> function、 </font><font color="blue"> Symbol </font>7种数据类型。</li></ul><p>对于引用类型，返回的都是object，其实返回object也没有错，因为所有对象的原型链最终都指向了Object, Object是所有对象的<code>祖宗</code>。<br>但当我们需要知道某个对象的具体类型时，typeof 就显得有些力不从心了。</p><p><font color="red">注意：typeof null也是返回object</font>  </p><ul><li><h6 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h6>判断对象和构造函数在原型链上是否有关系，如果有关系，返回真，否则返回假<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">const</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 判断a1和Aaa是否在同一个原型链上，是的话返回真，否则返回假</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> a1 <span class="token keyword">instanceof</span> <span class="token class-name">Aaa</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true </span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Aaa</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>对于基本数据类型与引用类型的判断：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bool <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> nul <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nul <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> und <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>und <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token keyword">const</span> oDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>oDate <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fun <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error <span class="token keyword">instanceof</span> <span class="token class-name">Error</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>从上面的运行结果我们可以看到，基本数据类型是没有检测出他们的类型，但是我们使用下面的方式创建num、str、boolean，是可以检测出类型的：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'abcdef'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> boolean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num <span class="token keyword">instanceof</span> <span class="token class-name">Number</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>boolean <span class="token keyword">instanceof</span> <span class="token class-name">Boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h6 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h6>查看对象对应的构造函数，constructor 在其对应对象的原型下面，是自动生成的。当我们写一个构造函数的时候，程序会自动添加：构造函数名.prototype.constructor = 构造函数名<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// Aaa.prototype.constructor = Aaa; // 每一个函数都会有的，都是自动生成的</span> <span class="token comment">// Aaa.prototype.constructor = Aaa;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>判断数据类型的方法：<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>constructor <span class="token operator">===</span> String<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bool<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Boolean<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Number<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> nul <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nul<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错 </span><span class="token keyword">const</span> und <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>und<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错</span><span class="token keyword">const</span> oDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>oDate<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Date<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reg<span class="token punctuation">.</span>constructor <span class="token operator">===</span> RegExp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fun<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Function<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>从上面的测试中我们可以看到，undefined和null是不能够判断出类型的，并且会报错。因为null和undefined是无效的对象，因此是不会有constructor存在的。<br>同时我们也需要注意到的是：使用constructor是不保险的，因为constructor属性是可以被修改的，会导致检测出的结果不正确。<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">Aaa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 程序可以自动添加，当我们写个构造函数的时候，程序会自动添加这句代码</span><span class="token class-name">Aaa</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Aaa<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token constant">BBB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token comment">// 此时我们就修改Aaa构造函数的指向问题</span><span class="token class-name">Aaa</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> <span class="token constant">BBB</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Aaa<span class="token punctuation">.</span>construtor <span class="token operator">===</span> Aaa<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>可以看出，constructor并没有正确检测出正确的构造函数</li></ul><p><font color="red"> 备注：使用Object.create()创建的js对象，没有constructor </font></p><ul><li><h6 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a>Object.prototype.toString</h6>可以说不管是什么类型，它都可以立即判断出。<br>toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object xxx],xxx是具体的数据类型，其中包括：<br>String,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument,… 基本上所有对象的类型都可以通过这个方法获取到。 <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object String]</span><span class="token keyword">const</span> bool <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>bool<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//[object Boolean]</span><span class="token keyword">const</span> num <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Number]</span><span class="token keyword">const</span> nul <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>nul<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Null]</span><span class="token keyword">const</span> und <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>und<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Undefined]</span><span class="token keyword">const</span> oDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>oDate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Date]</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Object]</span><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Array]</span><span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">a</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object RegExp]</span><span class="token keyword">const</span> <span class="token function-variable function">fun</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>fun<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Function]</span><span class="token keyword">const</span> error <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[object Error]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>从这个结果也可以看出，不管是什么类型的，Object.prototype.toString.call();都可以判断出其具体的类型。<br>优缺点总结：<table><thead><tr><th>类型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>typeof</td><td>使用简单</td><td>只能检测出基本类型（除了null）</td></tr><tr><td>instanceof</td><td>能检测出引用类型</td><td>不能检测出基本类型，且不能跨iframe</td></tr><tr><td>constructor</td><td>基本能检测所有的类型（除了null和undefined</td><td>constructor易被修改，也不能跨iframe IE6下，undefined和null均为Object</td></tr><tr><td>Object.prototype.toString.call</td><td>检测出所有的类型</td><td>/</td></tr><tr><td>instanceof和constructor不能跨iframe。</td><td></td><td></td></tr></tbody></table><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">window<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> oF <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span> oF <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">const</span> ifArray <span class="token operator">=</span> window<span class="token punctuation">.</span>frames<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Array<span class="token punctuation">;</span>        <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ifArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Array <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-7. js中null与undefined的区别</title>
      <link href="/2022/01/18/js-bian-liang-yu-lei-xing-7-js-zhong-null-yu-undefined-de-qu-bie/"/>
      <url>/2022/01/18/js-bian-liang-yu-lei-xing-7-js-zhong-null-yu-undefined-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h5 id="js中null-与-undefined-的区别"><a href="#js中null-与-undefined-的区别" class="headerlink" title="js中null 与 undefined 的区别"></a>js中null 与 undefined 的区别</h5><p>在JavaScript中存在这样两种原始类型:Null与Undefined。<br>Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。<br>Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。  </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> oValue<span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>oValue <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true  没有初始化</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">===</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'notExistElement'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>当页面上不存在id为”notExistElement”的DOM节点时，这段代码显示为”true”，因为我们尝试获取一个不存在的对象。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined  </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object  </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="为什么null的类型是Object？"><a href="#为什么null的类型是Object？" class="headerlink" title="为什么null的类型是Object？"></a>为什么null的类型是Object？</h6><p>其实这是JavaScript最初实现的一个错误，后来被ECMAScript沿用下来。在今天我们可以解释为，null即是一个不存在的对象的占位符，但是在实际编码时还是要注意这一特性。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">null</span> <span class="token operator">==</span> <span class="token keyword">undefined</span> <span class="token comment">// true</span><span class="token keyword">null</span> <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>ECMAScript认为undefined是从null派生出来的，所以把它们定义为值相等的，类型不相等。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-6. 理解值类型和引用类型</title>
      <link href="/2022/01/14/js-bian-liang-yu-lei-xing-6-li-jie-zhi-lei-xing-he-yin-yong-lei-xing/"/>
      <url>/2022/01/14/js-bian-liang-yu-lei-xing-6-li-jie-zhi-lei-xing-he-yin-yong-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>值类型也称基本类型string、number、array也就是除了object以外的类型  </p><p>例一：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'aaaaa'</span>a<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'bar'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为js内部对基本类型a进行a.foo=’bar’操作时，会在内部创建一个对应的包装类型（在上例中也就是一个String类型）的临时对象，对a的操作会有这个基本类型代理，不管是赋值还是调用成员函数（也就是变量a可以使用String的函数，也可以给自己添加属性），操作完后，这个临时对象就释放掉了（给自己添加的属性也一起释放掉了）。下次访问时，会重新创建一个新的临时对象（访问不到释放了的对象中的属性）</p><p>例二：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">a<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'bar'</span>a<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>foo2 <span class="token operator">=</span> <span class="token string">'bar2'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>foo<span class="token punctuation">,</span> a<span class="token punctuation">.</span>foo2<span class="token punctuation">)</span> <span class="token comment">// undefined "bar2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对__proto__操作起作用不是因为临时对象没有释放，而是临时对象是String,Sring是函数，函数的__proto__是他构造函数的prototype,跟这个函数创建出来的临时对象没关系了。这个临时对象只是引用了他的构造函数的prototype而已（构造函数的prototype不会因为临时对象被释放而被释放）。而所有同类型的对象的构造函数是同一个。也就是同一个prototype，所以可以修改到更深层。</p><p>例三：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'aaaaa'</span><span class="token keyword">var</span> b <span class="token operator">=</span> ab <span class="token operator">=</span> <span class="token string">'ccccc'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token comment">// aaaaa ccccc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是引用的话，a、b两个值应该一起改变。这是值类型，所以是两个无关的值。</p><p>例四：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span>name<span class="token operator">:</span><span class="token string">'aaa'</span><span class="token punctuation">&#125;</span><span class="token keyword">var</span> b <span class="token operator">=</span> ab<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'bbbbb'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token comment">// &#123;name: "bbbbb"&#125; &#123;name: "bbbbb"&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>引用类型，一个修改，一起改变</p><p>例五：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'aaaaa'</span><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token string">'aaaaa'</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span> <span class="token comment">// true</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'aaaaa'</span><span class="token punctuation">)</span>str <span class="token operator">==</span> str2<span class="token boolean">true</span>str <span class="token operator">===</span> str2<span class="token boolean">false</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// string</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// object</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值一样，但是类型不一样。String,Number,Boolean在JS中是基本类型，基本类型是存储在栈(stack)内存中的,数据大小确定，内存空间大小可以分配。</p><p>而引用类型是存储在堆(heap)内存中的,例如对象, 栈中存在的仅仅是一个堆的指针，这也就是我们日常遇到 a = {num:1}, b=a, b.num1 = 2, 那么a.num1 也为2 的原因。因为a,b同时指向同一个地址。</p><p>前两种方式定义出来的是在栈中并且值相等，而第三种方法定义出来的仅仅是栈中的一个指针。<br>所以这也是为什么 三种方式定义出来的不一样。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment">// 5</span>str<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token string">'world'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment">//undefined</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span>lengh<span class="token punctuation">)</span> <span class="token comment">// 5</span>str1<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token string">'world'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment">//undefined</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span>lengh<span class="token punctuation">)</span> <span class="token comment">// 5</span>str2<span class="token punctuation">.</span>say <span class="token operator">=</span> <span class="token string">'world'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">.</span>say<span class="token punctuation">)</span> <span class="token comment">//world</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>indexOf <span class="token operator">===</span> <span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>indexOf<span class="token punctuation">)</span> <span class="token comment">//true</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span>indexOf <span class="token operator">===</span> <span class="token class-name">String</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>indexOf<span class="token punctuation">)</span> <span class="token comment">//true</span>str <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// false</span>str1 <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="str-又-不属于String-却拥有-String-的方法"><a href="#str-又-不属于String-却拥有-String-的方法" class="headerlink" title="str 又 不属于String 却拥有 String 的方法?"></a>str 又 不属于String 却拥有 String 的方法?</h6><p>这是JS中的设计。</p><ul><li>原始资料类型的方法与属性是”借”来的</li><li>一个原始的资料类型值，并没有如对象会有属性或方法，</li><li>原始的资料类型在运算时用的属性与方法，是向包装对象”借来”的用的，</li><li>所以原始资料类型是可以向 new String() 或者 new Number()借来所有的方法。但是自己本身却没有属性和方法。</li></ul><p>所以这也就是为什么第一种第二种我们无法去自定义属性却可以使用对应类型的方法的原因。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-5. js基本类型的装箱与拆箱</title>
      <link href="/2022/01/12/js-bian-liang-yu-lei-xing-5-js-ji-ben-lei-xing-de-zhuang-xiang-yu-chai-xiang/"/>
      <url>/2022/01/12/js-bian-liang-yu-lei-xing-5-js-ji-ben-lei-xing-de-zhuang-xiang-yu-chai-xiang/</url>
      
        <content type="html"><![CDATA[<h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>所谓装箱，就是把基本类型转变为对应的对象。装箱分为隐式和显示。</p><h5 id="隐式装箱"><a href="#隐式装箱" class="headerlink" title="隐式装箱"></a>隐式装箱</h5><p>每当读取一个基本类型的值时，后台会创建一个该基本类型所对应的对象。在这个基本类型上调用方法，其实是在这个基本类型对象上调用方法。这个基本类型的对象是临时的，它只存在于方法调用那一行代码执行的瞬间，执行方法后立刻被销毁。具体到代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">num<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '123.00'</span><span class="token comment">//上方代码在后台的真正步骤为</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c<span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当我们访问 num 时，要从内存中读取这个数字的值，此时访问过程处于读取模式。在读取模式中，后台进行了三步处理：</p><ul><li>创建一个 Number 类型的实例</li><li>在实例上调用方法</li><li>销毁实例</li></ul><h5 id="显式装箱"><a href="#显式装箱" class="headerlink" title="显式装箱"></a>显式装箱</h5><p>通过内置对象 Boolean、Object、String 等可以对基本类型进行显示装箱。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h4><p>拆箱与装箱相反，把对象转变为基本类型的值。拆箱过程内部调用了抽象操作 ToPrimitive 。该操作接受两个参数，第一个参数是要转变的对象，第二个参数 PreferredType 是对象被期待转成的类型。第二个参数不是必须的，默认该参数为 number，即对象被期待转为数字类型。有些操作如 String(obj) 会传入 PreferredType 参数。有些操作如 obj + “ “ 不会传入 PreferredType。  </p><p>具体转换过程是这样的。默认情况下，ToPrimitive 先检查对象是否有 valueOf 方法，如果有则再检查 valueOf 方法是否有基本类型的返回值。如果没有 valueOf 方法或 valueOf 方法没有返回值，则调用 toString 方法。如果 toString 方法也没有返回值，产生 TypeError 错误。  </p><p>PreferredType 影响 valueOf 与 toString 的调用顺序。如果 PreferrenType 的值为 string。则先调用 toString ,再调用 valueOf。</p><p>具体测试代码如下：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">valueOf</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"valueOf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>    <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"toString"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">String</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// toString</span><span class="token comment">// valueOf</span><span class="token comment">// Uncaught TypeError: Cannot convert object to primitive value</span>obj <span class="token operator">+</span> <span class="token string">''</span><span class="token punctuation">;</span><span class="token comment">// valueOf</span><span class="token comment">// toString</span><span class="token comment">// Uncaught TypeError: Cannot convert object to primitive value</span><span class="token function">Number</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// valueOf</span><span class="token comment">// toString</span><span class="token comment">// Uncaught TypeError: Cannot convert object to primitive value</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-4. js中的变量在内存中的具体存储形式</title>
      <link href="/2022/01/11/js-bian-liang-yu-lei-xing-4-js-zhong-de-bian-liang-zai-nei-cun-zhong-de-ju-ti-cun-chu-xing-shi/"/>
      <url>/2022/01/11/js-bian-liang-yu-lei-xing-4-js-zhong-de-bian-liang-zai-nei-cun-zhong-de-ju-ti-cun-chu-xing-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h4><p>javascript中的变量分为基本类型和引用类型。  </p><ul><li>基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，按值访问。</li><li>引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，javascript不允许直接访问堆内存中的位置，因此操作对象时，实际上操作的事对象的引用。  </li></ul><h5 id="结合代码与图理解"><a href="#结合代码与图理解" class="headerlink" title="结合代码与图理解"></a>结合代码与图理解</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token string">"this is string"</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> a3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 变量b存在于栈中，&#123; x: 10 &#125;作为对象存在于堆中</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 变量c存在于栈中，[1, 2, 3]作为对象存在于堆中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20220119003023489.png"></p><h5 id="访问堆内存中的引用数据类型"><a href="#访问堆内存中的引用数据类型" class="headerlink" title="访问堆内存中的引用数据类型:"></a>访问堆内存中的引用数据类型:</h5><ul><li>访问栈内存，获取该对象的地址引用</li><li>通过地址，从堆内存中获取需要的数据</li></ul><h5 id="基本类型发生复制行为"><a href="#基本类型发生复制行为" class="headerlink" title="基本类型发生复制行为"></a>基本类型发生复制行为</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="image-20220119003057391.png"></p><p>在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值，最后这些变量都是相互独立互不影响的。</p><h5 id="引用类型发生复制行为"><a href="#引用类型发生复制行为" class="headerlink" title="引用类型发生复制行为"></a>引用类型发生复制行为</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>b<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>引用类型的复制，同样为新的变量b分配一个新的值，保存在栈内存中，不同的是，这个值仅仅是引用类型的一个地址指针</li><li>他们两个指向同一个值，也就是地址指针相同，在堆内存中访问到的具体对象实际上是同一个,因此改变b.x时，a.x也发生了变化，这就是引用类型的特性</li></ul><p><img src="image-20220119003111587.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="image-20220119003124330.png"></p>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-3. js Symbol类型在实际开发中的应用</title>
      <link href="/2022/01/07/js-bian-liang-yu-lei-xing-3-js-symbol-lei-xing-zai-shi-ji-kai-fa-zhong-de-ying-yong/"/>
      <url>/2022/01/07/js-bian-liang-yu-lei-xing-3-js-symbol-lei-xing-zai-shi-ji-kai-fa-zhong-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h4 id="开发应用"><a href="#开发应用" class="headerlink" title="开发应用"></a>开发应用</h4><ul><li>Symbol 是一种基本数据类型，由Symbol函数生成<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// 无参数情况</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token comment">// Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Symbol(foo)</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c <span class="token operator">===</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token comment">// Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。</span><span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Symbol is not a constructor at new Symbol</span><span class="token comment">// instanceof 的结果为 false</span><span class="token keyword">var</span> aa <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>aa <span class="token keyword">instanceof</span> <span class="token class-name">Symbol</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span><span class="token comment">// 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</span><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token string">'abc'</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Symbol(abc)</span><span class="token comment">// Symbol 值不能与其他类型的值进行运算，会报错</span><span class="token keyword">var</span> sym1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'My symbol'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"your symbol is "</span> <span class="token operator">+</span> sym1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// TypeError: Cannot convert a Symbol value to a string</span><span class="token comment">// Symbol 值可以显式转为字符串</span><span class="token keyword">var</span> sym2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'My symbol'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">String</span><span class="token punctuation">(</span>sym2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Symbol(My symbol)'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'Symbol(My symbol)'</span><span class="token comment">// Symbol的唯一性，可以作为标识符，用于对象的属性名</span><span class="token keyword">var</span> symbol1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> symbol2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> symbol3 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 写法一</span><span class="token constant">A</span><span class="token punctuation">[</span>symbol1<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>symbol1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span><span class="token comment">// 写法二</span><span class="token constant">A</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    symbol2<span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">&#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>symbol2<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span><span class="token comment">// 写法三</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> symbol3<span class="token punctuation">,</span> <span class="token punctuation">&#123;</span>value<span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">[</span>symbol3<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hello</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><font style="color: red">注意：</font> 该属性不会出现在 <font style="color: red"> for…in </font>、<font style="color: red"> for…of </font> 循环中，也不会被<font style="color: blue"> Object.keys() </font>、<font style="color: blue"> Object.getOwnPropertyNames() </font>、<font style="color: blue"> JSON.stringify() </font> 返回。但是，它也不是私有属性，有一个<font style="color: blue"> Object.getOwnPropertySymbols </font>  方法，可以获取指定对象的所有 Symbol 属性名。</li><li>使用同一个 Symbol 值，可以使用 Symbol.for<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> s1 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token keyword">var</span> s2 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s1 <span class="token operator">===</span> s2<span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> s1 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Symbol<span class="token punctuation">.</span><span class="token function">keyFor</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "foo"</span> <span class="token keyword">var</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Symbol<span class="token punctuation">.</span><span class="token function">keyFor</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>使用  </li></ul><p>当需要区分形状，正方形，圆形，菱形 会使用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> shape <span class="token operator">=</span> <span class="token punctuation">&#123;</span> triangle<span class="token operator">:</span> ‘triangle’<span class="token punctuation">,</span> circle<span class="token operator">:</span> ‘circle’<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不优雅，可以使用:</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> shape <span class="token operator">=</span> <span class="token punctuation">&#123;</span> triangle<span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> circle<span class="token operator">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-2-js对象的底层数据结构</title>
      <link href="/2022/01/05/js-bian-liang-yu-lei-xing-2-js-dui-xiang-de-di-ceng-shu-ju-jie-gou/"/>
      <url>/2022/01/05/js-bian-liang-yu-lei-xing-2-js-dui-xiang-de-di-ceng-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h4 id="栈内存和堆内存"><a href="#栈内存和堆内存" class="headerlink" title="栈内存和堆内存"></a>栈内存和堆内存</h4><p>javascript中的变量分为基本类型和引用类型。  </p><ul><li>基本类型是保存在栈内存中的简单数据段，它们的值都有固定的大小，保存在栈空间，按值访问。</li><li>引用类型是保存在堆内存中的对象，值大小不固定，栈内存中存放的该对象的访问地址指向堆内存中的对象，javascript不允许直接访问堆内存中的位置，因此操作对象时，实际上操作的事对象的引用。  </li></ul><h5 id="结合代码与图理解"><a href="#结合代码与图理解" class="headerlink" title="结合代码与图理解"></a>结合代码与图理解</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> a2 <span class="token operator">=</span> <span class="token string">"this is string"</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> a3 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 栈内存</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">10</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 变量b存在于栈中，&#123; x: 10 &#125;作为对象存在于堆中</span><span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 变量c存在于栈中，[1, 2, 3]作为对象存在于堆中</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="访问堆内存中的引用数据类型"><a href="#访问堆内存中的引用数据类型" class="headerlink" title="访问堆内存中的引用数据类型:"></a>访问堆内存中的引用数据类型:</h5><ul><li>访问栈内存，获取该对象的地址引用</li><li>通过地址，从堆内存中获取需要的数据</li></ul><h5 id="基本类型发生复制行为"><a href="#基本类型发生复制行为" class="headerlink" title="基本类型发生复制行为"></a>基本类型发生复制行为</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在栈内存中的数据发生复制行为时，系统会自动为新的变量分配一个新值，最后这些变量都是相互独立互不影响的。</p><h5 id="引用类型发生复制行为"><a href="#引用类型发生复制行为" class="headerlink" title="引用类型发生复制行为"></a>引用类型发生复制行为</h5><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">&#123;</span> x<span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">20</span> <span class="token punctuation">&#125;</span><span class="token keyword">let</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>b<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>引用类型的复制，同样为新的变量b分配一个新的值，保存在栈内存中，不同的是，这个值仅仅是引用类型的一个地址指针</li><li>他们两个指向同一个值，也就是地址指针相同，在堆内存中访问到的具体对象实际上是同一个,因此改变b.x时，a.x也发生了变化，这就是引用类型的特性</li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS变量与类型-1.js语言类型与Symbol,Iteratorl理解</title>
      <link href="/2022/01/04/js-bian-liang-yu-lei-xing-1-js-yu-yan-lei-xing-yu-symbol-iteratorl-li-jie/"/>
      <url>/2022/01/04/js-bian-liang-yu-lei-xing-1-js-yu-yan-lei-xing-yu-symbol-iteratorl-li-jie/</url>
      
        <content type="html"><![CDATA[<h4 id="JavaScript规定了几种语言类型？"><a href="#JavaScript规定了几种语言类型？" class="headerlink" title="JavaScript规定了几种语言类型？"></a>JavaScript规定了几种语言类型？</h4><p>七种： 1.Undefined, 2.Null, 3.Boolean, 4.String, 5.Number, 6.Symbol, 7.Object  </p><h5 id="Symbol的概念"><a href="#Symbol的概念" class="headerlink" title="Symbol的概念"></a>Symbol的概念</h5><p>Symbol表示独一无二的值，它是一切非字符串的对象key的集合。<br>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。<br>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，但是即使描述相同，Symbol值也不相等。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s1 <span class="token operator">===</span> s2 <span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>一些标准中提到的 Symbol，可以在全局的 Symbol 函数的属性中找到。例如，我们可以使用 Symbol.iterator 来自定义 for…of 在对象上的行为： </p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span>o<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>        <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span> value<span class="token operator">:</span> v<span class="token operator">++</span><span class="token punctuation">,</span> done<span class="token operator">:</span> v <span class="token operator">></span> <span class="token number">10</span> <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> v <span class="token keyword">of</span> o<span class="token punctuation">)</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0 1 2 3 ... 9</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Iterator（遍历器）的概念"><a href="#Iterator（遍历器）的概念" class="headerlink" title="Iterator（遍历器）的概念"></a>Iterator（遍历器）的概念</h5><p>Javascript表示集合的数据结构，有数组(Array)、对象(Object)、Map、Set四种。用户可以组合使用，定义自己的数据结构。例如:数组的成员为Map,Map的成员为对象。这样就需要一种统一的机制，来处理不同的数据结构。<br>遍历器(Iterator)就是这样一种机制，它是一种接口，为不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator机制，就可以完成遍历操作。（即依次处理该数据结构的所有成员）。  </p><h5 id="Iterator（遍历器）的作用"><a href="#Iterator（遍历器）的作用" class="headerlink" title="Iterator（遍历器）的作用"></a>Iterator（遍历器）的作用</h5><ul><li>为各种数据结构，提供一个统一的、简便的访问接口</li><li>使得数据结构的成员能够按照某种次序排序</li><li>ES6提供了一种新的遍历命令<font color='red'> for…of </font>循环，Iterator接口主要供<font color='red'> for…of </font>消费  </li></ul><h5 id="Iterator（遍历器）的遍历过程"><a href="#Iterator（遍历器）的遍历过程" class="headerlink" title="Iterator（遍历器）的遍历过程"></a>Iterator（遍历器）的遍历过程</h5><ul><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的<font color='red'> next </font>方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的<font color='red'> next </font>方法，指针将指向数据结构的第二个成员。</li><li>不断调用指针对象的<font color='red'> next </font>方法，直到指针指向数据结构的结束位置。<br>每一次调用数据结构的<font color='red'> next </font>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<font color='red'> value </font>和<font color='red'> done </font>两个属性的对象。其中，<font color='red'> value </font>是当前成员的值，<font color='red'> done </font>是一个布尔值，表示遍历是否结束。（true表示结束，false表示不结束）<br>下面是一个模拟遍历器<font color='red'> next </font>方法返回值的例子:</li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">makeIterator</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">var</span> nextIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>    <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">?</span>        <span class="token punctuation">&#123;</span>value<span class="token operator">:</span> array<span class="token punctuation">[</span>nextIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span> <span class="token operator">:</span>        <span class="token punctuation">&#123;</span>done<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="默认Iterator接口"><a href="#默认Iterator接口" class="headerlink" title="默认Iterator接口"></a>默认Iterator接口</h5><p>Iterator接口的目的，就是为所有的数据结构，提供一种统一的访问机制，即<font color='red'> for…of </font>循环。当使用<font color='red'> for…of </font>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。<br>一种数据结构只要部署了Iterator接口，就称这种数据结构是可遍历的。(iterable)<br>ES6规定，默认的Iterator接口部署在数据结构的<font color='red'> Symbol.iterator </font>属性，或者说，一个数据结构只要具有<font color='red'> Symbol.iterator </font>属性，就可以认为是可遍历的。<font color='red'> Symbol.iterator </font>就是当前数据结构默认的遍历器生成函数，返回值为一个遍历器。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">&#123;</span>    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>            <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>                    value<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>                    done<span class="token operator">:</span> <span class="token boolean">true</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为 Symbol 的特殊值，所以要放在方括号内。<br>ES6 的有些数据结构原生具备 Iterator 接口（比如数组），即不用任何处理，就可以被for…of循环遍历。原因在于，这些数据结构原生部署了Symbol.iterator属性，另外一些数据结构没有（比如对象）。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。<br>原生具备 Iterator 接口的数据结构：  </p><ul><li>Array</li><li>Map </li><li>Set: 类似于数组，只不过其成员值都是唯一的，没有重复的值。</li><li>String</li><li>TypedArray: 一个TypedArray对象描述一个底层的二进制数据缓存区的一个类似数组(array-like)视图。</li><li>函数的 arguments 对象</li><li>NodeList 对象: NodeList 对象是一个节点的集合，是由 Node.childNodes 和 document.querySelectorAll返回的.NodeList不是一个数组，是一个类似数组的对象(Like Array Object).虽然NodeList不是一个数组，但是可以使用forEach()对其进行迭代。还可以使用Array.from()将其转换为实际数组。<br>以数组为例： </li></ul><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">let</span> iter <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: 'a', done: false &#125;</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: 'b', done: false &#125;</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: 'c', done: false &#125;</span>iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &#123; value: undefined, done: true &#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对象（Object）之所以没有默认部署 Iterator 接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作 Map 结构使用，ES5 没有 Map 结构，而 ES6 原生提供了。<br>一个对象如果要具备可被for…of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">class</span> <span class="token class-name">RangeIterator</span> <span class="token punctuation">&#123;</span>    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">start<span class="token punctuation">,</span> stop</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> start<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>stop <span class="token operator">=</span> stop<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">next</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>stop<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>done<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> value<span class="token operator">:</span> value<span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> <span class="token punctuation">&#123;</span>done<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">function</span> <span class="token function">range</span> <span class="token punctuation">(</span><span class="token parameter">start<span class="token punctuation">,</span> stop</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RangeIterator</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> stop<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value <span class="token keyword">of</span> <span class="token function">range</span><span class="token punctuation">(</span><span class="token parameter"><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span></span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 0, 1, 2</span><span class="token punctuation">&#125;</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;done: false, value: '0'&#125;</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;done: false, value: '1'&#125;</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;done: false, value: '2'&#125;</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &#123;done: true, value: undefined&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码是一个类部署 Iterator 接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。  </p>]]></content>
      
      
      <categories>
          
          <category> Javascript基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS变量与类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#泛型</title>
      <link href="/2020/05/14/csharp-fan-xing/"/>
      <url>/2020/05/14/csharp-fan-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="ArrayList类缺陷"><a href="#ArrayList类缺陷" class="headerlink" title="ArrayList类缺陷"></a>ArrayList类缺陷</h4><p>在ArrayList类中，所有的元素类型都为object类型。.NET中的object类是所有类的基类，因此ArrayList类可以接受任何类型的值作为它的元素。使用ArrayList中的元素时，必须强制进行类型转换，将元素转换为合适的类型。如果元素是值类型的值，会引起CLR进行拆箱和装箱的操作，造成一定的性能开销。而且，还必须小心处理类型转换中可能出现的错误。</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型是一种类型占位符，或称为类型参数。我们知道在一个方法中，一个变量的值可以作为参数，但其实这个变量的类型本身也可以作为参数。泛型允许程序员在代码中将变量或参数的类型先用“类型占位符”来代替，在调用的时候再指定这个类型参数是什么。</p><p>在System.Collections.Generic命名空间中包含了多个泛型集合类，List<T>和Dictionary&lt;K,V&gt;是其中常用的两种泛型集合类，在实际应用中有很重要的作用。</p><h5 id="List-lt-T-gt-类"><a href="#List-lt-T-gt-类" class="headerlink" title="List&lt;T&gt;类"></a>List&lt;T&gt;类</h5><p>List类是ArrayList相对应的泛型集合，用法与ArrayList类似，有更好的类型安全性，无需拆、装箱。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法List&lt;T&gt; 集合名 &#x3D; new List&lt;T&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在泛型定义中，泛型类型参数“<T>”是必须指定的，其中的“T”是定义泛型类时的占位符，其并不是一种类型，仅代表某种可能的类型。在定义时“T”会被使用的类型代替。泛型集合List<T>中只能有一个参数类型，“<T>”中的“T”可以对集合中的元素类型进行约束。</p><p><strong>注意：泛型集合必须实例化，实例化时和普通类实例化时相同，必须在后面加上“()”。</strong></p><p>List<T>的添加、删除和检索等方法和ArrayList相似，但是不需要像ArrayList那样装箱和拆箱。<br>用法与ArrayList基本相同，ArrayList示例可查看链接：<a href="https://blog.csdn.net/JeayNeverGiveUp/article/details/105998420">ArrayList类相关方法</a></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; List类部分方法示例List&lt;int&gt; list1 &#x3D; new List&lt;int&gt;();list1.Add(1);list1.Add(2);list1.Insert(2, 3);int[] strs1 &#x3D; &#123; 5, 6 &#125;;list1.AddRange(strs1);int[] strs2 &#x3D; &#123; 4 &#125;;list1.InsertRange(3, strs2);Console.WriteLine(&quot;list1的容量为&#123;0&#125;，数目为&#123;1&#125;&quot;, list1.Capacity, list1.Count); &#x2F;&#x2F; 8 6foreach (var i in list1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 1 2 3 4 5 6Console.WriteLine();list1.Remove(1);foreach (var i in list1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 2 3 4 5 6Console.WriteLine();list1.RemoveAt(3);foreach (var i in list1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 2 3 4 6Console.WriteLine();list1.RemoveRange(1, 2); &#x2F;&#x2F; list1.RemoveRange(index, count)foreach (var i in list1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 2 6Console.WriteLine();Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="Dictionary-lt-K-V-gt-类"><a href="#Dictionary-lt-K-V-gt-类" class="headerlink" title="Dictionary&lt;K,V&gt;类"></a>Dictionary&lt;K,V&gt;类</h5><p>在System.Collections.Generic命名空间中，与HashTable相对应的泛型集合是Dictionary&lt;K,V&gt;，其存储数据的方式和哈希表相似，通过键/值来保存元素，并具有泛型的全部特征，编译时检查类型约束，读取时无需进行类型转换。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法Dictionary&lt;K, V&gt; 泛型集合名 &#x3D; new Dicitionary&lt;K, V&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中“K”为占位符，具体定义时用存储键“Key”的数据类型代替，“V”同样也是占位符，用元素的值“Value”的数据类型代替，这样在定义该集合时，就声明了存储元素的键和值的数据类型，保证了类型的安全性。</p><p>Dictionary用法与Hashtable基本相同，Hashtable示例可查看链接：<a href="https://blog.csdn.net/JeayNeverGiveUp/article/details/106056179">ArrayList类相关方法</a></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 部分示例Dictionary&lt;string, string&gt; openWith &#x3D; new Dictionary&lt;string, string&gt;();openWith.Add(&quot;txt&quot;, &quot;test.exe&quot;);openWith.Add(&quot;bmp&quot;, &quot;paint.exe&quot;);foreach(var i in openWith)&#123;    Console.WriteLine(i.Key + &quot;: &quot; + i.Value);&#125;&#x2F;** * txt: test.exe * bmp: paint.exe *&#x2F;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="泛型优点"><a href="#泛型优点" class="headerlink" title="泛型优点"></a>泛型优点</h5><ul><li>性能高。使用泛型不需要进行类型转换，可以避免装箱和拆箱操作，能提高性能</li><li>类型安全。泛型集合对其存储对象进行了类型约束，不是定义时声明的类型，是无法存储到泛型集合中的，从而保证了数据的类型安全</li><li>代码重用。使用泛型类型可以最大限度地重用代码、保护类型的安全以及提高性能。在处理集合类时，如果遇到下列情况，则可考虑使用泛型类<br>1&gt; 如需要对多种类型进行相同的操作处理。<br>2&gt;  如需要处理值类型，使用泛型则可避免装箱/拆箱带来的性能开销。</li><li>使用泛型可以在应用程序编译时发现类型错误，增强程序的健壮性</li><li>减少不必要的重复编码，使代码结构更加清晰</li></ul><p><strong>可以根据需要创建自己的泛型接口、泛型类、泛型方法、泛型事件和泛型委托。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#常用非泛型集合类-Hashtable类</title>
      <link href="/2020/05/13/csharp-chang-yong-fei-fan-xing-ji-he-lei-hashtable-lei/"/>
      <url>/2020/05/13/csharp-chang-yong-fei-fan-xing-ji-he-lei-hashtable-lei/</url>
      
        <content type="html"><![CDATA[<h4 id="HashTable类"><a href="#HashTable类" class="headerlink" title="HashTable类"></a>HashTable类</h4><p>HashTable称为哈希表，利用键/值来存储数据。每个元素都是一个键/值对，并且是一一对应的，通过“键”就可以得到“值”。</p><p><strong>常用属性</strong><br>| 属性名称 | 属性说明 |<br>|–|–|<br>| Count | 获取包含在Hashtable中键/值对的数目 |<br>| Keys | 获取包含在Hashtable中所有键的集合 |<br>| Values | 获取包含在Hashtable中所有值得集合 |<br><strong>常用方法</strong><br>| 方法名称 | 方法说明 |<br>|–|–|<br>| Add | 将带有指定键和值得元素添加到Hashtable中 |<br>| Clear | 从Hashtable中移除所有元素 |<br>| Contains | 确认Hashtable是否包含特定键 |<br>| GetEnumberator | 返回IDictionaryEnumberator，可以遍历Hashtable |<br>| Remove | 从Hashtable中移除带有指定键的元素 |<br><strong>常用构造函数声明</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Hashtable ht1 &#x3D; new Hashtable(); &#x2F;&#x2F; 使用所有默认值构建哈希表实例（初始容量为 16，负载因子为 0.75），实际容量为16 * 0.75 &#x3D; 12Hashtable ht2 &#x3D; new Hashtable(20); &#x2F;&#x2F; 指定哈希表的初始容量为20，实际容量为20 * 0.75 &#x3D; 15Hashtable ht3 &#x3D; new Hashtable(20, 0.8f); &#x2F;&#x2F; 初始容量为20个元素，加载因子为0.8,实际容量为10 *0.8 &#x3D; 16Hashtable ht4 &#x3D; new Hashtable(s1); &#x2F;&#x2F; 传入实现了IDicitionary接口的参数创建哈希表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>加载因子：</p><ul><li>加载因子是表示Hsah表中元素的填满的程度。若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但冲突的机会加大了。反之,加载因子越小,填满的元素越少。好处是:冲突的机会减小了,但空间浪费多了</li><li>冲突的机会越大,则查找的成本越高.反之,查找的成本越小.因而,查找时间就越小</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Hashtable openWith &#x3D; new Hashtable();openWith.Add(&quot;bmp&quot;, &quot;paint.exe&quot;);openWith.Add(&quot;did&quot;, &quot;paint.exe&quot;);openWith.Add(&quot;rtf&quot;, &quot;wordpad.exe&quot;);Console.WriteLine(&quot;键&#x3D;\&quot;rtf\&quot;，值&#x3D;&#123;0&#125;&quot;, openWith[&quot;rtf&quot;]); &#x2F;&#x2F; wordpad.exeopenWith[&quot;doc&quot;] &#x3D; &quot;winword.exe&quot;; &#x2F;&#x2F; 如果对不存在的键设置值，则添加新的键值对&#x2F;&#x2F; 通常添加之前用ContainsKey来判断某个键是否存在if(!openWith.ContainsKey(&quot;ht&quot;))&#123;    openWith.Add(&quot;ht&quot;, &quot;ht.exe&quot;);    Console.WriteLine(openWith[&quot;ht&quot;]); &#x2F;&#x2F; ht.exe&#125;&#x2F;&#x2F; 遍历foreach(DictionaryEntry de in openWith) &#x2F;&#x2F; Hashtable的键&#x2F;值是DicitionaryEntry类型&#123;    Console.WriteLine(&quot;键 &#x3D; &#123;0&#125;，值 &#x3D; &#123;1&#125;&quot;, de.Key, de.Value);&#125;&#x2F;** * 键 &#x3D; ht，值 &#x3D; ht.exe * 键 &#x3D; rtf，值 &#x3D; wordpad.exe * 键 &#x3D; bmp，值 &#x3D; paint.exe * 键 &#x3D; did，值 &#x3D; paint.exe * 键 &#x3D; doc，值 &#x3D; winword.exe *&#x2F;&#x2F;&#x2F; 删除openWith.Remove(&quot;doc&quot;);if (!openWith.ContainsKey(&quot;doc&quot;))    Console.WriteLine(&quot;false&quot;); &#x2F;&#x2F; falseConsole.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>遍历时应注意，Hashtable的每个元素都是一个键/值对，因此元素类型既不是键的类型，也不是值的类型，而是DictionaryEntry类型。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>int.Parse与int.TryParse的区别</title>
      <link href="/2020/05/13/int-parse-yu-int-tryparse-de-qu-bie/"/>
      <url>/2020/05/13/int-parse-yu-int-tryparse-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p><strong>Convert.ToInt32<br>int.Parse（Int32.Parse）<br>int.TryParse<br>(int)</strong><br>四者都可以解释为将类型转换为 int，那它们的区别是什么呢？</p><p>Convert.ToInt32 与 int.Parse 较为类似，实际上 Convert.ToInt32 内部调用了 int.Parse：</p><ul><li>Convert.ToInt32 参数为 null 时，返回 0；</li><li>int.Parse 参数为 null 时，抛出异常。  </li><li>Convert.ToInt32 参数为 “” 时，抛出异常；</li><li>int.Parse 参数为 “” 时，抛出异常。 </li><li>Convert.ToInt32 可以转换的类型较多；</li><li>int.Parse 只能转换数字类型的字符串。<br>int.TryParse 与 int.Parse 又较为类似，但它不会产生异常，转换成功返回 true，转换失败返回 false。最后一个参数为输出值，如果转换失败，输出值为 0。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int m; if(int.TryParse(&quot;2&quot;),out m)&#123;...&#125;&#x2F;&#x2F; 返回true ,运行&#123;&#125;内，并给m赋值为2； if(int.TryParse(&quot;ddd&quot;),out m)&#123;...&#125;&#x2F;&#x2F; 返回false,不运行if&#123;&#125;内，并给m赋值为0；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#常用非泛型集合类-ArrayList类</title>
      <link href="/2020/05/11/csharp-chang-yong-fei-fan-xing-ji-he-lei-arraylist-lei/"/>
      <url>/2020/05/11/csharp-chang-yong-fei-fan-xing-ji-he-lei-arraylist-lei/</url>
      
        <content type="html"><![CDATA[<p>ArrayList是System.Collections命名空间中的非泛型集合类，类似于数组，有人称其为动态数组，其容量可以根据需要自动扩充，元素的索引也可根据元素数量重新分配，可以动态实现元素的添加、删除等操作。</p><p>可以将ArrayList类理解为Array的优化版本，该类既有数组的特征，又有集合的特性，例如，既可以通过下标进行元素访问，对元素进行排序、搜索，又可以像处理集合一样添加，在指定索引处插入及删除元素。</p><p><strong>常用属性</strong></p><ul><li>Capacity： 获取或设置ArrayList可包含的元素数，默认为4</li><li>Count: 获取ArrayList中实际包含的元素数</li><li>Item: 获取或设置指定索引处的元素</li></ul><p><strong>常用方法</strong></p><ul><li>Add(): 将元素添加到ArrayList的结尾处</li><li>AddRange(): 在ArrayList的末尾增加一定范围内的元素</li><li>Clear(): 清除ArrayList中的所有元素</li><li>Contains(): 检查某元素是否在ArrayList中</li><li>IndexOf: 返回ArrayList中某个元素值得第一个匹配项对应的索引</li><li>Insert(): 将元素插入ArrayList的指定索引处</li><li>Remove(): 从ArrayList移除特定元素的第一个匹配项</li><li>Reverse(): 将ArrayList或它的一部分中的元素的顺序反转</li><li>Sort(): 对ArrayList或它的一部分中的元素进行排序</li></ul><p><em><strong>由于ArrayList中元素的类型默认为object，因此在获取集合元素时需要强制进行类型转换。并且由于object是引用类型，在与值类型进行转换时会引起装箱和拆箱的操作，因此需要付出一些性能代价。</strong></em></p><p><strong>为了实现上面的例子，必须在using区添加System.Collections命名空间。</strong></p><h5 id="创建ArrayList"><a href="#创建ArrayList" class="headerlink" title="创建ArrayList"></a>创建ArrayList</h5><p>ArrayList的四种创建方式：</p><ol><li>使用默认的初始容量创建ArrayList，该实例没有任何元素<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList al1 &#x3D; new ArrayList();al1.Add(&quot;hello&quot;);al1.Add(&quot;C#&quot;);al1.Add(&quot;world!&quot;);Console.WriteLine(&quot;al1中容量是&#123;0&#125;, 个数是&#123;1&#125;&quot;, al1.Capacity, al1.Count); &#x2F;&#x2F; 4 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>使用实现了ICollection接口的集合类来初始化新创建的ArrayList,该实例与参数中的集合具有相同的初始容量<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList al2 &#x3D; new ArrayList(al1);Console.WriteLine(&quot;al2容量是&#123;0&#125;, 个数是&#123;1&#125;&quot;,al2.Capacity, al2.Count); &#x2F;&#x2F; 3 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>经由一个整数数值来初始化ArrayList的容量<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList al3 &#x3D; new ArrayList(18);Console.WriteLine(&quot;al3的容量是：&#123;0&#125;, 元素个数是&#123;1&#125;&quot;, al3.Capacity, al3.Count); &#x2F;&#x2F; 18 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>将指定abc字符串重复n次构造数组，以下以三次示例<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList al4 &#x3D; ArrayList.Repeat(&quot;abc&quot;, 3);Console.WriteLine(&quot;al4的容量是：&#123;0&#125;，元素个数是&#123;1&#125;&quot;, al4.Capacity, al4.Count); &#x2F;&#x2F; 4 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="向ArrayList中添加元素的方法"><a href="#向ArrayList中添加元素的方法" class="headerlink" title="向ArrayList中添加元素的方法"></a>向ArrayList中添加元素的方法</h4></li></ol><ul><li>Add方法可以将单个元素添加到列表的尾部；AddRange方法可以获取一个实现ICollection接口的集合实例，例如，Array、Queue、Stack等，并将这个集合实例按顺序添加到列表的尾部。</li><li>使用Insert和InsertRange方法向ArrayList中指定的位置插入元素。Insert方法用于添加单个元素到指定的索引位置，InsertRange从指定的位置开始添加一个实现了ICollection接口的实例。</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList a1 &#x3D; new ArrayList(20);a1.Add(&quot;我是元素1&quot;);a1.Add(&quot;我是元素2&quot;);string[] strs &#x3D; &#123; &quot;我是元素3&quot;, &quot;我是元素4&quot; &#125;;a1.AddRange(strs);a1.Insert(0, &quot;新增第1个元素&quot;);ArrayList a2 &#x3D; new ArrayList();a2.Add(&quot;我是新增元素1&quot;);a2.Add(&quot;我是新增元素2&quot;);a1.InsertRange(2, a2);foreach(var i in a1)&#123;    Console.WriteLine(i);&#125;&#x2F;** * 新增第1个元素 * 我是元素1 * 我是新增元素1 * 我是新增元素2 * 我是元素2 * 我是元素3 * 我是元素4 *&#x2F;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除ArrayList中的元素"><a href="#删除ArrayList中的元素" class="headerlink" title="删除ArrayList中的元素"></a>删除ArrayList中的元素</h4><p>ArrayList提供了Remove、RemoveAt和RemoveRange3种方法将指定元素从集合中移除。</p><ul><li>Remove方法接受一个object类型的参数，用于移除指定元素值的第一个匹配集合元素</li><li>RemoveAt方法接受一个int类型的参数，用于删除指定索引的集合元素</li><li>RemoveRange方法从集合中移除一定范围的元素</li></ul><p>Clear方法可移除所有的元素</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList a1 &#x3D; new ArrayList(20);int[] strs &#x3D; &#123; 0, 1, 2, 3, 4&#125;;a1.AddRange(strs);foreach(var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 01234&#125;Console.WriteLine();a1.Remove(0);foreach(var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 1234&#125;Console.WriteLine();a1.RemoveAt(1);foreach(var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 134&#125;Console.WriteLine();a1.RemoveRange(1, 2); &#x2F;&#x2F; a1.RemoveRange(index, count)foreach(var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 1&#125;Console.WriteLine();a1.Clear();foreach (var i in a1)&#123;    Console.Write(i); &#x2F;&#x2F; 空 &#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>使用Sort方法对ArrayList集合中的元素进行排序。Sort有3种重载方法。</p><ul><li>使用集合元素的比较方式进行排序。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public virtual void Sort();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用自定义比较器进行排序<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public virtual void Sort(IComparer comparer);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用自定义比较器进行指定范围的排序<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public virtual void Sort(int index, int count, Icomparer comparer);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>示例：<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">ArrayList a1 &#x3D; new ArrayList();a1.AddRange(new string[5] &#123; &quot;Array1&quot;, &quot;Array2&quot;, &quot;Array5&quot;, &quot;Array3&quot;, &quot;Array&quot; &#125;);foreach (var i in a1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; Array1 Array2 Array5 Array3 ArrayConsole.WriteLine();a1.Sort();foreach (var i in a1)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; Array Array1 Array2 Array3 Array5Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找ArrayList中的集合元素"><a href="#查找ArrayList中的集合元素" class="headerlink" title="查找ArrayList中的集合元素"></a>查找ArrayList中的集合元素</h4></li><li>IndexOf: 从前向后搜索指定的字符串，如果找到，则返回匹配的第1项的自0开始的索引，否则返回-1</li><li>LastIndexOf: 从后向前搜索指定的字符串，如果找到，则返回匹配的最后一项的自0开始的索引，否则返回-1</li><li>BinarySearch: 使用二分算法从集合中搜索指定的值，并返回找到的从0开始的索引，否则返回-1</li></ul><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[] nums &#x3D; &#123; 1, 2, 3, 4, 5, 4 &#125;;ArrayList a1 &#x3D; new ArrayList(nums);int i &#x3D; a1.IndexOf(3);Console.WriteLine(i); &#x2F;&#x2F; 2int j &#x3D; a1.LastIndexOf(4);Console.WriteLine(j); &#x2F;&#x2F; 5int k &#x3D; a1.BinarySearch(4);int m &#x3D; a1.BinarySearch(0);Console.WriteLine(k); &#x2F;&#x2F; 3Console.WriteLine(m); &#x2F;&#x2F; -1Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="泛型List"><a href="#泛型List" class="headerlink" title="泛型List"></a>泛型List</h4><p>因为ArrayList存在不安全类型与装箱拆箱的缺点，所以在C#2.0后出现了泛型的概念。而List类是ArrayList类的泛型等效类。它的大部分用法都与ArrayList相似，因为List类也继承了IList接口。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">List&lt;int&gt; list &#x3D; new List&lt;int&gt;();&#x2F;&#x2F;新增数据list.Add(1);list.Add(3);&#x2F;&#x2F; list.Add(&quot;1&quot;) &#x2F;&#x2F; 报错，只能为int型，不能为stringforeach (var i in list)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 1 3Console.WriteLine();&#x2F;&#x2F;修改数据list[0] &#x3D; 2;foreach (var i in list)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 2 3Console.WriteLine();&#x2F;&#x2F;移除数据list.RemoveAt(0);foreach (var i in list)    Console.Write(i + &quot; &quot;); &#x2F;&#x2F; 3Console.WriteLine();Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#匿名方法与lambda表达式</title>
      <link href="/2020/04/20/csharp-ni-ming-fang-fa-yu-lambda-biao-da-shi/"/>
      <url>/2020/04/20/csharp-ni-ming-fang-fa-yu-lambda-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<h4 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h4><p>要将代码块传递为委托参数，创建匿名方法则是唯一的方法。匿名方法就是为了将代码块传递为委托参数，因此也有人将其称为匿名委托。使用C#的匿名方法可以使委托及事件的代码编写更加精简、高效。一般情况下，事件注册事件处理方法，需要首先定义这个方法，如果该方法仅用于订阅特定的事件，则可使用代码更加简明的匿名方法。<br><strong>示例</strong><br>委托与事件中的烧水示例，Heater类不变，去掉Alarm类和Display类，使用匿名方法订阅事件修改Main方法中的代码。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Heater heater &#x3D; new Heater();heater.BoilEvent +&#x3D; delegate (int param) &#x2F;&#x2F;水快开时报警的匿名方法&#123;    Console.WriteLine(&quot;Alarm: 嘀嘀嘀，水已经&#123;0&#125;度了！&quot;, param);&#125;;heater.BoilEvent +&#x3D; delegate (int param) &#x2F;&#x2F; 表示水温的匿名方法&#123;    Console.WriteLine(&quot;Display: 水快烧开了，当前温度：&#123;0&#125;度！&quot;, param);&#125;;heater.BoilWater();Console.ReadKey();&#x2F;*** Alarm: 嘀嘀嘀，水已经97度了!* Display：水快烧开了，当前温度：97度。* Alarm: 嘀嘀嘀，水已经98度了!* Display：水快烧开了，当前温度：98度。* Alarm: 嘀嘀嘀，水已经99度了!* Display：水快烧开了，当前温度：99度。* Alarm: 嘀嘀嘀，水已经100度了!* Display：水快烧开了，当前温度：100度。*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>lambda表达式是一种可用于创建委托或表达式目录树类型的匿名函数。通过使用lambda表达式，可以写入可作为参数传递或作为函数调用值返回的本地函数。lambda表达式对于编写LINQ查询表达式特别有用。若要创建lambda表达式，需要在lambda运算符 =&gt; 左侧指定输入参数（如果有），然后在另一侧输入表达式或语句块。<br><strong>联想理解：类似于ES6的箭头函数</strong><br>示例：使用lambda表达式实现委托，进行数组排序。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Linq.Expressions;namespace LambdaTest&#123;    class Program    &#123;        public delegate bool SortDelegate(int[] x); &#x2F;&#x2F; 定义委托SortDelegate        static void Main(string[] args)        &#123;            int[] arr &#x3D; new int[] &#123; 8, 9, 2, 1, 4, 3 &#125;;            Console.WriteLine(&quot;排序前的数组：&quot;);            foreach (int i in arr) Console.Write(i); &#x2F;&#x2F; 892143            Console.WriteLine();            &#x2F;&#x2F; 用lamdba表达式实例化委托            SortDelegate myDelegate &#x3D; array &#x3D;&gt;            &#123;                for (int i &#x3D; array.GetUpperBound(0); i &gt;&#x3D; 0; i--)                &#123;                    &#x2F;&#x2F; 冒泡排序                    for (int j &#x3D; 0; j &lt;&#x3D; i; j++)                    &#123;                        if (array[j] &lt;&#x3D; array[i])                        &#123;                            int temp &#x3D; array[j];                            array[j] &#x3D; array[i];                            array[i] &#x3D; temp;                        &#125;                    &#125;                &#125;                return true;            &#125;;            myDelegate(arr);            Console.WriteLine(&quot;排序后的数组：&quot;);            foreach(int i in arr) Console.Write(i); &#x2F;&#x2F; 984321            Console.ReadKey();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp委托与事件</title>
      <link href="/2020/04/16/csharp-wei-tuo-yu-shi-jian/"/>
      <url>/2020/04/16/csharp-wei-tuo-yu-shi-jian/</url>
      
        <content type="html"><![CDATA[<h4 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h4><p>委托也叫代理，即把事情交给别人代办。C#中如果将一个方法委托给一个对象，对象即可全权代理该方法的执行。使用委托时首先要定义委托，声明委托所能代理方法的类型。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法&lt;访问修饰符&gt; delegate 返回类型 委托名();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>委托没有具体的实现体，委托能够代表什么样的方法由它的返回值类型和参数列表决定。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 示例public delegate void testDelegate(string name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义了上述委托示例之后要使用委托，首先要实例化委托，也就是将其指向某个方法，即调用委托的构造函数，并将相关联的方法作为参数传递。然后通过调用    委托，执行相关方法的代码，实现委托。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 使用委托对数组进行降序排列using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace DelegateSort&#123;    class Program    &#123;        public delegate bool SortDelegate(int[] x); &#x2F;&#x2F; 定义委托SortDelegate        static void Main(string[] args)        &#123;            int[] arr &#x3D; new int[] &#123; 8, 9, 5, 3, 4, 6, 1 &#125;;            Console.WriteLine(&quot;排序前的数组是： &quot;);            foreach (int i in arr) Console.Write(&quot;&#123;0&#125;&quot;, i); &#x2F;&#x2F; 8953461            SortDelegate myDelegate; &#x2F;&#x2F; 声明委托变量            myDelegate &#x3D; new SortDelegate(Test.SortArray); &#x2F;&#x2F; 实例化委托变量，委托Test的SortArray            myDelegate(arr); &#x2F;&#x2F; 传递参数，调用委托排序            Console.WriteLine(&quot;&quot;);            Console.WriteLine(&quot;排序后的数组是：&quot;);            foreach (int i in arr) Console.Write(&quot;&#123;0&#125;&quot;, i); &#x2F;&#x2F; 9865431            Console.ReadKey();        &#125;    &#125;    class Test    &#123;        public static bool SortArray(int[] array )        &#123;            &#x2F;&#x2F; 定义方法SortArray用于按照降序排序            &#x2F;&#x2F; GetUpperBound(int dimension): 获取数组中指定维度最后一个元素的索引。 dimension Int32 数组的从零开始的维度，其上限需要确定。            for (int i &#x3D; array.GetUpperBound(0); i &gt;&#x3D; 0; i--) &#x2F;&#x2F; 循环从后向前取出数组的元素            &#123;                &#x2F;&#x2F; 冒泡排序，将数值小的元素移到后面，直到所有的元素按照降序排列                for(int j &#x3D; 0; j &lt;&#x3D; i; j++)                &#123;                    if(array[j] &lt;&#x3D; array[i]) &#x2F;&#x2F; 判断数组前面的值是否小于后面的值                    &#123;                        Swap(ref array[j], ref array[i]); &#x2F;&#x2F; 交换二者的位置                    &#125;                &#125;            &#125;            return true; &#x2F;&#x2F; 并非所有代码都有返回值，故加return true        &#125;        static void Swap(ref int x, ref int y) &#x2F;&#x2F; 交换方法        &#123;            int temp &#x3D; y;            y &#x3D; x;            x &#x3D; temp;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件是C#中的一个高级概念，是操作发生时允许执行特定应用程序的代码的机制。事件要么在相关联的操作发生前发生（事前事件），要么在操作发生后发生（事后事件）。例如，当用户单击窗口中的按钮时，将引发一个事后事件，以允许执行特定于应用程序的方法。</p><p>类或对象可以通过事件向其他类或对象通知发生的相关事情。发送（或引发）事件的类称为“发行者”，接收（或处理）事件的类称为“订户”。在典型的C# Windows窗体或Web应用程序中，可以订阅由控件（如按钮和列表框）引发的事件。</p><p>定义和使用事件的步骤：<br>(1) 在一个类中声明关于事件的委托。</p><pre class="line-numbers language-none"><code class="language-none">public delegate void 事件类型名称(object serder, EventArgs e); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>事件类型名称建议用EventHandler结尾。如果想自定义事件的参数EventArgs，可以用EventArgs类派生自己的事件参数类，也可以没有参数。<br>(2)在类中声明事件，使用步骤(1)的delegate作为事件的类型。 </p><pre class="line-numbers language-none"><code class="language-none">public event 事件类型名称 事件名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(3)在类中需要引发事件的方法中，编写引发事件的方法。</p><pre class="line-numbers language-none"><code class="language-none">事件名称(this, new EventArgs());&#x2F;&#x2F; 或者if(事件名称 !&#x3D; null) 事件名称 (this, new EventArgs());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>(4)订阅事件，当事件发生时通知订户。</p><pre class="line-numbers language-none"><code class="language-none">带有事件的类实例.事件名称 +&#x3D; new 事件名称(事件处理方法名称);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>(5)编写事件处理方法。</p><pre class="line-numbers language-none"><code class="language-none">public void 事件处理方法(object sender, EventArgs e)&#123;&#x2F;&#x2F; 相关代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>(6)在适当的条件下触发事件，即需要调用步骤(3)中的引发事件的方法。</p><p><strong>事件的定义和使用示例</strong><br>假设设计一个高档热水器，通电加热到水温超过96℃的时候，扬声器会发出语音告诉你水的温度，液晶屏显示水温的变化，提示水快烧开了。定义一个类来代表热水器的类Heater，它有代表水温的字段temperature，有给水加热的BoilWater()方法，发出语音警报的MakeAlert()方法，显示水温的ShowMsg()方法。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace HeaterEvent&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Heater heater &#x3D; new Heater(); &#x2F;&#x2F; 创建热水器对象heater            Alarm alarm &#x3D; new Alarm(); &#x2F;&#x2F; 创建报警器对象alarm            heater.BoilEvent +&#x3D; alarm.MakeAlert; &#x2F;&#x2F; 给alarm的MakeAlert方法订阅事件            heater.BoilEvent +&#x3D; Display.ShowMsg; &#x2F;&#x2F; 订阅静态方法            heater.BoilWater(); &#x2F;&#x2F; 烧水，会自动调用订阅过的对象方法            Console.ReadKey();            &#x2F;**             * Alarm: 嘀嘀嘀，水已经97度了!             * Display：水快烧开了，当前温度：97度。             * Alarm: 嘀嘀嘀，水已经98度了!             * Display：水快烧开了，当前温度：98度。             * Alarm: 嘀嘀嘀，水已经99度了!             * Display：水快烧开了，当前温度：99度。             * Alarm: 嘀嘀嘀，水已经100度了!             * Display：水快烧开了，当前温度：100度。             *&#x2F;        &#125;    &#125;    public class Heater &#x2F;&#x2F; 热水器类Heater    &#123;        private int temperature; &#x2F;&#x2F; 声明表示水温的字段        public delegate void BoilHandler(int param); &#x2F;&#x2F; 声明关于事件的委托        public event BoilHandler BoilEvent; &#x2F;&#x2F; 声明水要烧开的事件        public void BoilWater() &#x2F;&#x2F; 烧水的方法        &#123;            for(int i &#x3D; 0; i &lt;&#x3D; 100; i++) &#x2F;&#x2F; 循环表示水温的变化            &#123;                temperature &#x3D; i; &#x2F;&#x2F; 设置水的温度                if(temperature &gt; 96) &#x2F;&#x2F; 水温超过96度，引发事件BoilEvent                &#123;                    &#x2F;*if(BoilEvent !&#x3D; null)                    &#123;                        &#x2F;&#x2F; 如果有对象订阅                        BoilEvent(temperature); &#x2F;&#x2F; 调用所有订阅对象的方法                    &#125;*&#x2F;                    &#x2F;&#x2F; 优化                    BoilEvent?.Invoke(temperature); &#x2F;&#x2F; 如果有对象订阅，调用所有订阅对象的方法                &#125;            &#125;        &#125;    &#125;    public class Alarm &#x2F;&#x2F; 定义报警类    &#123;        public void MakeAlert(int param) &#x2F;&#x2F; 水快开时报警的方法        &#123;            Console.WriteLine(&quot;Alarm: 嘀嘀嘀，水已经&#123;0&#125;度了!&quot;, param);        &#125;    &#125;    public class Display &#x2F;&#x2F; 显示水温的显示类    &#123;        &#x2F;&#x2F; 静态方法 ShowMsg用于显示水温        public static void ShowMsg(int param)        &#123;            Console.WriteLine(&quot;Display：水快烧开了，当前温度：&#123;0&#125;度。&quot;, param);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#抽象类与密封类</title>
      <link href="/2020/04/15/csharp-chou-xiang-lei-yu-mi-feng-lei/"/>
      <url>/2020/04/15/csharp-chou-xiang-lei-yu-mi-feng-lei/</url>
      
        <content type="html"><![CDATA[<p><strong>继承是面向对象设计理论的基石，抽象理论和方法是继承理论的顶梁柱。</strong></p><h4 id="抽象类与抽象方法"><a href="#抽象类与抽象方法" class="headerlink" title="抽象类与抽象方法"></a>抽象类与抽象方法</h4><p>用来描述共性的类叫做抽象类，抽象类中不考虑具体实现，只确定必须具有的行为，即确定抽象方法。</p><p>如教师的任务是教学，具体教什么，如何教，每个教师都有自己独特的一面，对教学这个动作就可以提取出来作为抽象方法，而不考虑具体实现内容。</p><p>包含抽象方法的类就是抽象类，抽象类和抽象方法声明使用<strong>abstract</strong>关键字。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法&lt;访问修饰符&gt; abstract class 抽象类名&#123;&#x2F;&#x2F; 类体&lt;访问修饰符&gt; abstract 返回类型方法(); &#x2F;&#x2F; 抽象方法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 示例public abstract class Test&#123;public abstract void Display(); &#x2F;&#x2F; 抽象方法 --&gt; Display()后面不能加 &#123;&#125;, 声明了abstract无法声明主体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实现抽象方法"><a href="#实现抽象方法" class="headerlink" title="实现抽象方法"></a>实现抽象方法</h4><p><strong>C#中通过方法重写来实现抽象方法。</strong></p><ul><li>当一个抽象基类派生一个派生类时，派生类将继承基类的所有特征，重新实现所有的抽象方法。</li><li>在派生类中实现基类的抽象方法，是使用override关键字来重写基类方法。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace AbstractTest&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Manager objManager &#x3D; new Manager(&quot;jay&quot;);            objManager.Display(); &#x2F;&#x2F; name: jay            Console.ReadKey();        &#125;    &#125;    public abstract class Employee &#x2F;&#x2F; 声明抽象类    &#123;        public abstract void Display(); &#x2F;&#x2F; 抽象方法Display()    &#125;    public class Manager: Employee &#x2F;&#x2F; 创建抽象类Employee的派生类Manager类    &#123;        private string name;        public Manager(string name) &#x2F;&#x2F; 构造函数实现name初始化        &#123;            this.name &#x3D; name;        &#125;        public override void Display() &#x2F;&#x2F; 重写基类Employee中的抽象方法Display()        &#123;            Console.WriteLine(&quot;name: &quot; + name);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="接口、类和抽象类"><a href="#接口、类和抽象类" class="headerlink" title="接口、类和抽象类"></a>接口、类和抽象类</h4>一个类可以同时继承类和接口，或者抽象类和接口，抽象类和类不能在一个类的继承列表中同时出现。</li></ul><p>如果派生类同时继承类或抽象类和接口，一定要把类或者抽象类写在前面，接口写在后面，类名和接口名之间用“,”隔开，接口没有先后顺序。每一种继承都要根据各自的规则去实现。</p><h6 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h6><ul><li>抽象类是一个不完全的类，需要通过派生类完善</li><li>接口只是对类的约束，它仅仅承诺了类能够调用的方法</li><li>一个类一次可以实现若干个接口，但一个类只能继承一个基类</li><li>抽象类只需派生类实现它的抽象方法，接口要求必须实现它的所有成员</li><li>在实际编程中，接口的使用要比抽象类广泛得多</li></ul><h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>与抽象类相反的是，C#支持创建密封类，密封类是不能当做基类的类。其他的类不能从此类派生，从而保证了密封类的密封性和安全性。在C#中使用<strong>sealed</strong>关键字创建密封类。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 示例public sealed class Animal &#x2F;&#x2F; 创建密封类&#123;public Animal() &#x2F;&#x2F; 创建构造函数&#123;&#x2F;&#x2F; 函数主体Console.WriteLine(&quot;Animal被构造&quot;)&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当从Animal派生派生类时，编译器会提示出现错误。设计类的时候，通常情况下是不需要将类设置为密封类的，因为密封类会让类的扩展性非常差，这个类也无法再次扩展和派生。但是出于某种目的，当程序块只需要完成某些特定的功能或者在商业上为了保密，就可以使用密封类对类进行密封，以保证类的可靠性。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#接口</title>
      <link href="/2020/04/14/csharp-jie-kou/"/>
      <url>/2020/04/14/csharp-jie-kou/</url>
      
        <content type="html"><![CDATA[<h4 id="统一的标准-接口"><a href="#统一的标准-接口" class="headerlink" title="统一的标准-接口"></a>统一的标准-接口</h4><p>接口是面向对象编程的一个重要技术，在C#中负责实现多重继承。一个接口定义一个协定，实现接口的类或结构必须遵守其协定。</p><h5 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h5><ul><li>接口用来描述一种程序的规定，可定义属于任何类或结构的一组相关行为。</li><li>接口可由方法、属性、事件、索引器或这4种成员类型的任何组合构成。</li><li>接口不能包含常数、字段、运算符、实例构造函数、析构函数或类型，也不能包含任何种类的静态成员。</li><li>接口成员一定是公共的。</li><li>接口不能包含其所定义的成员的任何实现语句，接口只指定实现该接口的类或必须提供的成员。<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法：&lt;访问修饰符&gt; interface 接口名&#123;&#x2F;&#x2F;接口主体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h5>定义了接口后，就要在类或结构中实现。C#中通常把派生类和基类的关系称为继承，类和接口的关系称为实现。</li></ul><p>实现接口的语法和继承类一样，都有“：”，接口中的方法在类中实现时不是重载，不需要使用override关键字。</p><p><strong>示例： 声明接口IPoint描述一个点的坐标并实现该接口。</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; IPoint.csusing System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace interfaceTest&#123;    interface IPoint    &#123;        &#x2F;&#x2F; 定义属性成员x，它含有读&#x2F;写抽象访问        int x &#123; get; set; &#125;        &#x2F;&#x2F; 定义属性成员y，它含有读&#x2F;写抽象访问        int y &#123; get; set; &#125;        &#x2F;**         * 对接口名称建议以“I”开头，如Ipoint；         * 对接口的访问修饰符可以选择使用，但是接口的方法前面不能添加任何访问修饰符，它是隐式公开的；         * 接口不能包含构造函数，接口不能实现任何方法、属性和索引器。         *&#x2F;    &#125;    &#x2F;&#x2F; 从接口IPoint派生一个新类，这个类用来实现Point接口成员    class Point: IPoint    &#123;        &#x2F;&#x2F; 定义两个类内部访问的私有成员变量        private int px;        private int py;        &#x2F;&#x2F; 构造函数实现类的私有化，为私有变量赋值        public Point(int x, int y)        &#123;            px &#x3D; x;            py &#x3D; y;        &#125;        &#x2F;&#x2F; 接口属性实现        public int x        &#123;            get &#123; return px; &#125; &#x2F;&#x2F; 实现读访写            set &#123; px &#x3D; value; &#125; &#x2F;&#x2F; 实现写访问        &#125;        public int y        &#123;            get &#123; return py; &#125; &#x2F;&#x2F; 实现读访写            set &#123; py &#x3D; value; &#125; &#x2F;&#x2F; 实现写访问        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>IPoint接口内部声明了两个属性成员x和y，x和y一起组成了一个点的坐标。属性成员x和y包含抽象的读/写访问，分别表示属性成员可以对坐标进行读和写。<br>定义类Point来实现IPoint接口，它包含了对接口成员的具体实现。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Program.csusing System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace interfaceTest&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Point p &#x3D; new Point(5, 30); &#x2F;&#x2F; 应用接口的派生类Point实例化一个新的对象并进行初始化赋值            Console.WriteLine(&quot;新创建的Point点的坐标是：&quot;);            Console.WriteLine(&quot;x &#x3D; &#123;0&#125;, y &#x3D; &#123;1&#125;&quot;, p.x, p.y); &#x2F;&#x2F; x &#x3D; 5, y &#x3D; 30        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>对接口名称建议以“I”开头，如Ipoint；</li><li>对接口的访问修饰符可以选择使用，但是接口的方法前面不能添加任何访问修饰符，它是隐式公开的；</li><li>接口不能包含构造函数，接口不能实现任何方法、属性和索引器。</li></ul><p>扩展：定义一个IPerson接口，接口包含DoWork和DoExercise两个抽象方法，并用Person类实现接口。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; IPerson.csinterface IPerson &#x2F;&#x2F; 声明接口IPerson&#123;void DoWork(); &#x2F;&#x2F; 声明DoWork方法void DoExercise(); &#x2F;&#x2F; 声明DoExercise方法&#125;&#x2F;&#x2F; 定义Person类实现IPerson接口public class Person: IPerson&#123;&#x2F;&#x2F; 定义基类的共有属性private string _name; &#x2F;&#x2F; 声明姓名字段public string Name &#x2F;&#x2F; 声明姓名属性&#123;get &#123; return this._name; &#125;set &#123;this._name &#x3D; value; &#125;&#125;public Person()&#123;&#125; &#x2F;&#x2F; 声明无参构造函数public Person(string name) &#x2F;&#x2F; 声明有参构造函数&#123;this._name &#x3D; name;&#125;public void DoWork() &#x2F;&#x2F; 定义工作方法&#123;Console.WriteLine(&quot;I&#39;m working!&quot;);&#125;public void DoExercise() &#x2F;&#x2F; 定义锻炼方法&#123;Console.WriteLine(&quot;I&#39;m doing exercise!&quot;);&#125;public void Display() &#x2F;&#x2F; 基类的共有方法&#123;Console.WriteLine(&quot;我是&#123;0&#125;&quot;, this._name);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; Program.csPerson objPerson &#x3D; new Person(&quot;小明&quot;);objPerson.Display(); &#x2F;&#x2F;  我是小明objPerson.DoWork(); &#x2F;&#x2F; I&#39;m working!objPerson.DoExercise(); &#x2F;&#x2F; I&#39;m doing exercise!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="接口的实现-1"><a href="#接口的实现-1" class="headerlink" title="接口的实现"></a>接口的实现</h5><ul><li>C#中的派生类只能有一个基类，不支持类的多重继承，但可以继承多个接口，通过接口实现多继承。</li><li>如在现实中儿子不但可以继承父亲的财产，如伯父无子女，也可以继承伯父的财产，在C#中这属于多重继承，要用接口来实现，其实接口就是为了实现多重继承而产生的。</li><li>在C#中接口可以多继承，接口之间可以互相继承，普通类和抽象类可以继承自接口。</li><li>一个类可以同时继承一个类和多个接口，但是接口不能继承类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#多态</title>
      <link href="/2020/04/13/csharp-duo-tai/"/>
      <url>/2020/04/13/csharp-duo-tai/</url>
      
        <content type="html"><![CDATA[<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h5 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h5><p>同一操作作用于不同的类的对象，不同的类的对象进行不同的执行，最后产生不同的执行结果。</p><h5 id="多态的实现"><a href="#多态的实现" class="headerlink" title="多态的实现"></a>多态的实现</h5><p>C#中支持基于接口的多态和基于继承的多态，基于继承的多态设计在基类中定义方法，并在派生类中重写方法。</p><p>多态和重写是紧密联系的，重写是实现多态的重要手段。重写基类方法就是修改它的实现，或者说在派生类中对继承的基类方法重新编写。</p><p>在基类中用<strong>virtual</strong>关键字声明的方法（叫做虚拟方法）在派生类中可以重写。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法访问修饰符 virtual 返回类型 方法名()&#123;&#x2F;&#x2F; 方法体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;...public virtual void Display() &#x2F;&#x2F; 基类中定义成虚拟方法，使用virtual关键字&#123;&#x2F;&#x2F; Father does sth....&#125;&#125;class Son: Father&#123;...public override void Display() &#x2F;&#x2F; 重写基类的Display方法&#123;&#x2F;&#x2F; Son does sth....&#x2F;&#x2F; 若想派生类方法执行后，继续执行基类方法，执行 base.Display() 方法base.Display();&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重写时，子类重写方法的访问级别和父类虚拟方法的访问级别必须相同。</strong></p><h5 id="方法重载、重写和隐蔽"><a href="#方法重载、重写和隐蔽" class="headerlink" title="方法重载、重写和隐蔽"></a>方法重载、重写和隐蔽</h5><p>在基类和派生类中可以存在同名方法，这些同名的方法可以分为重载、重写和隐藏3种类型。</p><ul><li>重载<br>重载是在同一个作用域内发生（比如一个类里面），定义一系列同名方法，但是方法的参数列表不同，就是签名不同，签名由方法名和参数组成。<br>能通过传递不同的参数来决定到底调用哪一个同名方法。</li></ul><p><strong>注意返回值类型不同不能构成重载，因为签名不包括返回值。</strong></p><ul><li>重写<br>基类方法中使用virtual关键字声明的方法和派生类中使用override关键字声明的方法名称相同，参数列表也相同，就是基类方法和派生类方法的签名相同，实现了派生类重写基类中的同名方法。</li><li>隐藏<br>基类中的方法不声明为virtual（默认为非虚方法），在派生类中声明与基类同名时，需使用new关键字，以隐藏基类同名方法。</li></ul><p><strong>示例：</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father&#123;...public virtual void Display() &#x2F;&#x2F; 基类中定义成虚拟方法，使用virtual关键字&#123;&#x2F;&#x2F; Father does sth....&#125;public void Display(int id)&#123;&#x2F;&#x2F; 若想执行无参方法this.Display();&#x2F;&#x2F; 有参方法Console.WriteLine(&quot;id: &quot; + id);&#125;&#125;class Son: Father&#123;...public override void Display() &#x2F;&#x2F; 重写基类的Display方法&#123;&#x2F;&#x2F; do sth....&#x2F;&#x2F; 若想派生类方法执行后，继续执行基类方法，执行 base.Display() 方法base.Display();&#125;public new void Display(int no) &#x2F;&#x2F; 使用new隐藏基类&#123;&#x2F;&#x2F; do sth....&#x2F;&#x2F; 若想派生类方法执行后，继续执行基类方法，执行 base.Display() 方法base.Display();&#x2F;&#x2F; 隐藏基类自定义方法Console.WriteLine(&quot;no: &quot; + no);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#数据类型</title>
      <link href="/2020/04/10/csharp-shu-ju-lei-xing/"/>
      <url>/2020/04/10/csharp-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h4 id="数据类型相关操作"><a href="#数据类型相关操作" class="headerlink" title="数据类型相关操作"></a>数据类型相关操作</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">var intNum &#x3D; 250;int i &#x3D; intnum; &#x2F;&#x2F; var 型变量intnum隐式转换成整型var name &#x3D; &quot;john&quot;;string strname &#x3D; name; &#x2F;&#x2F; var型变量name隐式转换成string型Console.WriteLine(&quot;转换后的内容是&#123;0&#125;，&#123;1&#125;&quot;, i, name); &#x2F;&#x2F; 转换后的内容是250, johnConsole.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">decimal pi &#x3D; 3.14159M; &#x2F;&#x2F; 字母M表示是decimal类型int r &#x3D; 12; &#x2F;&#x2F; 圆的半径decimal s &#x3D; 0; &#x2F;&#x2F; 圆的面积s &#x3D; pi*r*r;Console.WriteLine(&quot;圆的半径是&#123;0&#125;，\n圆的面积是&#123;1&#125;&quot;, r, s);Console.ReadLine();MessageBox.Show(&quot;圆的半径是&quot;+r+&quot;\n圆的面积是&quot;+s);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">float pi &#x3D; 3.14f; &#x2F;&#x2F; 定义一个单精度的实数int i &#x3D; (int)pi; &#x2F;&#x2F; 将单精度强制转换成整型计算，i的值是3，不是3.14，造成信息丢失Console.WriteLine(&quot;转换后的内容是&#123;0&#125;&quot;, i);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Convert类转换"><a href="#Convert类转换" class="headerlink" title="Convert类转换"></a>Convert类转换</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string myString &#x3D; &quot;true&quot;;bool MyBool &#x3D; Convert.ToBoolean(myString); &#x2F;&#x2F; 将string转换成Boolean型，Mybool &#x3D; truestring newString &#x3D; &quot;12345&quot;;int myInt &#x3D; Convert.ToInt32(newString); &#x2F;&#x2F; 将字符串转为数字值，myInt &#x3D; 12345Console.WriteLine(&quot;转换后的内容是&#123;0&#125;，&#123;1&#125;&quot;, MyBool, myInt); &#x2F;&#x2F; true 12345Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="隐式转换、显式转换使用举例："><a href="#隐式转换、显式转换使用举例：" class="headerlink" title="隐式转换、显式转换使用举例："></a>隐式转换、显式转换使用举例：</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(&quot;隐式、显式转换例子：&quot;);short r &#x3D; 25; &#x2F;&#x2F; 表示圆的半径int i &#x3D; r; &#x2F;&#x2F; 将短整型r隐式转换成整型float pi &#x3D; 3.14f; &#x2F;&#x2F; 定义一个单精度的实数double s1 &#x3D; pi * i * i; &#x2F;&#x2F; s1为double型，表示圆的面积int s2;s2 &#x3D; (int)pi * i * i; &#x2F;&#x2F; s2为int型，表示圆的面积 强制转换var name &#x3D; &quot;john&quot;;string strName &#x3D; name; &#x2F;&#x2F; var类型变量name隐式转换为string型Console.WriteLine(&quot;r&#x3D;25，圆的面积&#x3D;&#123;0&#125;,&#123;1&#125;&quot;, s1, s2);Console.WriteLine(&quot;转换成功！&quot;);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Convert转换使用举例："><a href="#Convert转换使用举例：" class="headerlink" title="Convert转换使用举例："></a>Convert转换使用举例：</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(&quot;隐式、显式转换例子：&quot;);short r &#x3D; 25; &#x2F;&#x2F; 表示圆的半径int i &#x3D; Convert.ToInt32(r); &#x2F;&#x2F; 将短整型r隐式转换成整型float pi &#x3D; 3.14f; &#x2F;&#x2F; 定义一个单精度的实数double s1 &#x3D; pi * i * i; &#x2F;&#x2F; s1为double型，表示圆的面积int s2;s2 &#x3D; Convert.ToInt32(pi) * i * i; &#x2F;&#x2F; s2为int型，表示圆的面积var memberName &#x3D; &quot;Johnson&quot;;string strName &#x3D; Convert.ToString(memberName); &#x2F;&#x2F; var型变量隐式转换为string型Console.WriteLine(&quot;r&#x3D;25，圆的面积&#x3D;&#123;0&#125;,&#123;1&#125;&quot;, s1, s2);Console.WriteLine(&quot;memberName&#x3D;&#123;0&#125;&quot;, memberName);Console.WriteLine(&quot;转换成功！&quot;);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="字符串与数值之间的转换"><a href="#字符串与数值之间的转换" class="headerlink" title="字符串与数值之间的转换"></a>字符串与数值之间的转换</h4><ul><li>ToString()方法：数值类型的ToString()方法可以将数值型数据转换为字符串。</li><li>Parse()方法：数值类型的Parse()方法可以将字符串转换为数值型，例如,字符串转换为整型使用int.Parse(string)，字符串转换为双精度浮点型使用double.Parse(string)等。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int num1 &#x3D; 25;string str1 &#x3D; num1.ToString(); &#x2F;&#x2F; num1的toString()方法将num1转换成string赋值给str1string str2 &#x3D; &quot;38&quot;;int num2 &#x3D; int.Parse(str2); &#x2F;&#x2F; int.Parse()方法将字符串str2转换成int类型string str3 &#x3D; &quot;21&quot;;double num3 &#x3D; double.Parse(str3); &#x2F;&#x2F; double.Parse()将字符串转换为双精度浮点型、string str4 &#x3D; &quot;56&quot;;float num4 &#x3D; float.Parse(str4); &#x2F;&#x2F; float.Parse()将字符串转换成单精度浮点型Console.WriteLine(&quot;num1、num2、num3、num4对应的数值为: &#123;0&#125;, &#123;1&#125;, &#123;2&#125;, &#123;3&#125;&quot;, num1, num2, num3,num4);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 拆箱：引用类型-&gt;值类型&#x2F;&#x2F; 装箱：值类型-&gt;引用类型int n &#x3D; 4; &#x2F;&#x2F; n是值类型object obj &#x3D; n; &#x2F;&#x2F; 装箱，把任何值类型隐式转换为object类型，其中object为引用类型console.writeline(&quot;n的初始值为：&#123;0&#125;，装箱后的值为：&#123;1&#125;&quot;, n, obj.tostring());int m &#x3D; (int)obj; &#x2F;&#x2F;拆箱，把一个object类型隐式的转换为值类型console.writeline(&quot;引用类型的值为：&#123;0&#125;，拆箱后的值为：&#123;1&#125;&quot;, obj.tostring(), m);console.readline();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="引用类型与值类型"><a href="#引用类型与值类型" class="headerlink" title="引用类型与值类型"></a>引用类型与值类型</h4><p>引用类型和值类型变量的使用是C#中的高级技巧之一。值类型变量中保存的是自己的实际数据，在赋值的时候会把源变量的数据复制一份，然后赋给目的变量；引用类型变量中保存的是“指向实际数据的指针”，即实际对象数据的内存地址，在进行赋值操作的时候，它和值类型一样，也是先有一个复制的操作，不过它复制的不是实际的数据，而是引用（真实数据的内存地址）。</p><ol><li>怎么区分值类型与引用类型以struct关键字定义的数据类型就是值类型，另外，枚举类型也是值类型；以class关键字定义的数据类型就是引用类型。</li><li>值类型变量与引用类型变量的使用区别值类型变量不需要使用new关键字来分配内存。相信大家使用int型变量时，就没有使用new来为其分配内存，定义完之后，就可以直接使用；引用类型变量则需要为其赋值后，才能使用。下面举例说明值类型与引用类型在使用上的区别。<br>首先定义两种类型的员工：结构体SEmployee和类CEmployee。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">struct SEmployee   &#123;       public int age;   &#125;   class CEmployee   &#123;       public int age;   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">SEmployee se;se.age &#x3D; 4;CEmployee ce;ce &#x3D; new CEmployee();ce.age &#x3D; 5;Console.WriteLine(&quot;年龄：&#123;0&#125;&quot;, se.age);Console.WriteLine(&quot;年龄：&#123;0&#125;&quot;, ce.age);Console.ReadLine();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>值类型变量在定义后，就直接可以使用，而引用类型必须使用new关键字后才能使用。对于引用类型会有“未将对象引用设置到对象的实例”错误，而值类型不会发生这种错误。<h4 id="typeof运算符"><a href="#typeof运算符" class="headerlink" title="typeof运算符"></a>typeof运算符</h4>typeof运算符用于获得系统原型对象的类型，也就是Type类型。Type类包含关于值类型和引用类型的信息。</li></ol><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Type t  &#x3D; typeof(int);Console.WriteLine(&quot;类型：&#123;0&#125;&quot;, t); &#x2F;&#x2F; System.Int32Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="checked和unchecked运算符"><a href="#checked和unchecked运算符" class="headerlink" title="checked和unchecked运算符"></a>checked和unchecked运算符</h4><p>checked和unchecked运算符用于允许或者禁止对指定的运算进行检测，并指出相应的错误提示信息。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">byte s &#x3D; 255;checked &#x2F;&#x2F; checked会检查溢出报错，并给出错误提示&#x2F;&#x2F; unchecked &#x2F;&#x2F; checked 改为 unckcked,控制台不报错，输出1&#123;    s +&#x3D; 2;&#125;Console.WriteLine(s.ToString());Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="成绩练习代码"><a href="#成绩练习代码" class="headerlink" title="成绩练习代码"></a>成绩练习代码</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(&quot;请输入成绩0-100：&quot;);int score &#x3D; int.Parse(Console.ReadLine());if (score &gt;&#x3D; 90)&#123;    Console.WriteLine(&quot;优秀&quot;);&#125;else if (score &gt;&#x3D; 80)&#123;    Console.WriteLine(&quot;良好&quot;);&#125;else if (score &gt;&#x3D; 70)&#123;    Console.WriteLine(&quot;中等&quot;);&#125;else if (score &gt;&#x3D; 60)&#123;    Console.WriteLine(&quot;及格&quot;);&#125;else&#123;    Console.WriteLine(&quot;不及格&quot;);&#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="循环练习代码"><a href="#循环练习代码" class="headerlink" title="循环练习代码"></a>循环练习代码</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; for循环计算0-100的和int sum &#x3D; 0;for (int i &#x3D; 1; i &lt;101; i++)&#123;    sum +&#x3D; i;&#125;Console.WriteLine(sum);Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; while循环计算0-100的和    int i &#x3D; 1, sum &#x3D; 0;    while(i &lt; 101)    &#123;        sum +&#x3D; i;        i++;    &#125;    Console.WriteLine(sum);    Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; do-while计算0-100的和int i&#x3D;1, sum &#x3D;0;do&#123;    sum +&#x3D; i;    i++;&#125; while (i &lt;&#x3D; 100);Console.WriteLine(sum);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; for-each循环string[]week &#x3D; &#123;&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;&#125;; &#x2F;&#x2F; 定义数组并赋值foreach(string s in week) &#x2F;&#x2F; 遍历数组&#123;    Console.WriteLine(s);&#125;Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 输出九九乘法表for (int i &#x3D; 1; i &lt; 10; i++)&#123;    for (int j &#x3D; 1; j &lt;&#x3D; i; j++)    &#123;        int k &#x3D; i*j;        Console.Write(&quot;&#123;0&#125;*&#123;1&#125; &#x3D; &#123;2&#125;&quot;, j, i, k);        if (i !&#x3D; j)Console.Write(&quot;,&quot;);    &#125;    Console.WriteLine();&#125;Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 输出小于100的素数Console.WriteLine(&quot;小于100的素数有：&quot;);for (int i &#x3D; 2; i &lt; 100; i++)&#123;    bool isPrime &#x3D; true;    for (int j &#x3D; 2; j &lt; i-1; j++)    &#123;        if (i % j &#x3D;&#x3D; 0)        &#123;            isPrime &#x3D; false;            break;        &#125;    &#125;    if (isPrime)Console.WriteLine(i);&#125;Console.ReadKey(); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 复印纸数练习Console.WriteLine(&quot;请输入复印数量：&quot;);int num &#x3D; int.Parse(Console.ReadLine());double money &#x3D; 0;if (num &lt; 51) money &#x3D; 0.5*num;else money &#x3D; 0.5*50 + (num - 50)*0.2;Console.WriteLine(money);Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp字符串操作</title>
      <link href="/2020/04/10/csharp-zi-fu-chuan-cao-zuo-xiang-guan/"/>
      <url>/2020/04/10/csharp-zi-fu-chuan-cao-zuo-xiang-guan/</url>
      
        <content type="html"><![CDATA[<h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Equals() 判断两个字符串是否相等，若相等则返回True，否则返回False * 语法：字符串变量1.Equals(字符串2) * 调用string类的静态方法： string.Equals(字符串1, 字符串2)*&#x2F;string str1 &#x3D; &quot;aaa&quot;;Console.WriteLine(str1.Equals(&quot;aaa&quot;)); &#x2F;&#x2F; true &lt;&#x3D;&#x3D;&gt; str1 &#x3D;&#x3D; &quot;aaa&quot;Console.WriteLine(str1.Equals(&quot;bbb&quot;)); &#x2F;&#x2F; flaseConsole.WriteLine(string.Equals(str1, &quot;aaa&quot;));  &#x2F;&#x2F; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串比较-CompareTo"><a href="#字符串比较-CompareTo" class="headerlink" title="字符串比较 CompareTo( )"></a>字符串比较 CompareTo( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * CompareTo( )用于比较字符串变量与给定字符串的大小，返回值为0、1或者-1 * 字符串的比较方式是，找到两个字符串中第一个不相同的字符，该字符ASCII值小的字符串较小。 * 若一直比较到字符串结束，每个对应字符都相同，那么若两个字符串长度相同，则两个字符串相等； * 若两个字符串长度不同，则短的字符串较小。 * 若字符串变量小于字符串2，则返回-1，反之返回1;若字符串变量与字符串2相等，则返回0。 * 语法： 字符串变量.CompareTo(字符串2) * 也可以使用静态方法Compare( )比较字符串1和字符串2的大小，相等则返回0，字符串1小则返回-1，字符串1大则返回1 * 语法: string.Compare(字符串1, 字符串2); *&#x2F;string s &#x3D; &quot;123&quot;;string str &#x3D; s;Console.WriteLine(s.CompareTo(str)); &#x2F;&#x2F; 0Console.WriteLine(s.CompareTo(&quot;121&quot;)); &#x2F;&#x2F; 1Console.WriteLine(string.Compare(str, &quot;124&quot;)); &#x2F;&#x2F; -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串包含-Contains"><a href="#字符串包含-Contains" class="headerlink" title="字符串包含 Contains( )"></a>字符串包含 Contains( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Contains( )用于判断字符串变量是否包含指定字符或字符串，是则返回True，否则返回False。 * 语法： 字符串变量.Contains(字符1&#x2F;字符串1); *&#x2F;string s &#x3D; &quot;123&quot;;Console.WriteLine(s.Contains(&quot;1&quot;)); &#x2F;&#x2F; trueConsole.WriteLine(s.Contains(&quot;12&quot;)); &#x2F;&#x2F; trueConsole.WriteLine(s.Contains(&quot;123&quot;)); &#x2F;&#x2F; trueConsole.WriteLine(s.Contains(&quot;1234&quot;));  &#x2F;&#x2F; false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串位置-IndexOf"><a href="#字符串位置-IndexOf" class="headerlink" title="字符串位置 IndexOf( )"></a>字符串位置 IndexOf( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * IndexOf( )用于查找给定字符或字符串在字符串变量中第一次出现的位置，返回字符或者字符串首字母在字符串变量中的位置数值。 * 不存在，则返回-1 * 语法：字符串变量.IndexOf(字符1) * LastIndexOf( )，用于查找给定字符或字符串在字符串变量中最后一次出现的位置数值。 *&#x2F;string s &#x3D; &quot;123123&quot;;Console.WriteLine(s.IndexOf(&quot;1&quot;)); &#x2F;&#x2F; 0Console.WriteLine(s.IndexOf(&quot;23&quot;)); &#x2F;&#x2F; 1Console.WriteLine(s.IndexOf(&quot;4&quot;)); &#x2F;&#x2F; -1Console.WriteLine(s.LastIndexOf(&quot;2&quot;));  &#x2F;&#x2F; 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="字符串截取-SubString"><a href="#字符串截取-SubString" class="headerlink" title="字符串截取 SubString( )"></a>字符串截取 SubString( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * SubString( )用于从字符串变量中获取指定位置开始的指定长度的子字符串，如果未指定子字符串长度，则取至字符串变量结尾，返回值为该子字符串。 * 语法：字符串变量.SubString(起始位置, 字符串长度) * 无长度参数即为从起始位置到末尾 * 若起始位置或者子字符串长度超出字符串变量允许范围，则系统返回异常ArgumentOutOfRangeException。 *&#x2F;string str &#x3D; &quot;Hello World!&quot;;Console.WriteLine(str.Substring(6)); &#x2F;&#x2F; worldConsole.WriteLine(str.Substring(0, 4)); &#x2F;&#x2F; hell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="插入子串-Insert"><a href="#插入子串-Insert" class="headerlink" title="插入子串 Insert( )"></a>插入子串 Insert( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Insert( )用于在字符串变量中指定位置插入给定子字符串，返回值为该子字符串。 * 语法：字符串变量.Insert(起始位置, 子字符串2) *&#x2F;string str &#x3D; &quot;world!&quot;;Console.WriteLine(str.Insert(0, &quot;hello &quot;)); &#x2F;&#x2F; hello world<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="删除子串-Remove"><a href="#删除子串-Remove" class="headerlink" title="删除子串 Remove( )"></a>删除子串 Remove( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Remove( )用于在字符串变量中删除指定位置开始的指定长度的子字符串，返回值为删除指定子串后的字符串变量。 * 语法：字符串.Remove(起始位置, 子串长度) * 无长度参数即为从起始位置到末尾 *&#x2F;string str &#x3D; &quot;this is a test&quot;;Console.WriteLine(str.Remove(0, 5)); &#x2F;&#x2F; is a testConsole.WriteLine(str.Remove(1, 5)); &#x2F;&#x2F; ts a testConsole.WriteLine(str.Remove(4)); &#x2F;&#x2F; this<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="替换子串-Replace"><a href="#替换子串-Replace" class="headerlink" title="替换子串 Replace( )"></a>替换子串 Replace( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Replace( )用于替换字符串变量中的指定字符或子字符串，返回值为替换完毕后的字符串变量 * 语法：字符串变量.Replace(字符1, 字符2) &#x2F;&#x2F; 用字符2替换字符1 * 或者：字符串变量.Replace(字符串1, 字符串2) &#x2F;&#x2F; 用字符串2替换字符串1 *&#x2F;string str &#x3D; &quot;Tom is a good boy!&quot;;Console.WriteLine(str.Replace(&quot;Tom&quot;, &quot;Jack&quot;)); &#x2F;&#x2F; Jack is a good boy!Console.WriteLine(str.Replace(&#39;o&#39;, &#39;k&#39;)); &#x2F;&#x2F; Tkm is a gkkd bky!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="去除字符串空格-Trim"><a href="#去除字符串空格-Trim" class="headerlink" title="去除字符串空格 Trim( )"></a>去除字符串空格 Trim( )</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * Trim( )用于去除字符串变量中头部和尾部的空格，返回值为去除空格的字符串变量 * 语法：字符串变量.Trim() * TrimStart()与TrimEnd()可以分别去除头部和尾部的空格 *&#x2F;string str &#x3D; &quot;   this is a test   &quot;;Console.WriteLine(str); &#x2F;&#x2F; (3空格)this is a test(3空格)   Console.WriteLine(str.Trim()); &#x2F;&#x2F; this is a testConsole.WriteLine(str.TrimStart()); &#x2F;&#x2F; this is a test(3空格)  Console.WriteLine(str.TrimEnd()); &#x2F;&#x2F; (3空格)this is a test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;** * String类是引用类型，每次改变String类对象的值，即修改字符串变量对应的字符串，都需要在内存中为新字符串重新分配空间。 * 在某些特定情况，例如，循环中可能需要反复修改一个字符串变量的值，内存开销会比较大。 * StringBuilder类则没有这一问题，StringBuilder类的对象可以调用ToString( )方法将StringBuilder类的内容作为String类字符串输出， * 调用Append( )和AppendLine( )方法添加内容。 *&#x2F;StringBuilder str &#x3D; new StringBuilder();str.Append(&quot;我爱你！&quot;);str.AppendLine(&quot;中国！&quot;);str.Append(&quot;我的祖国！&quot;);Console.WriteLine(str); &#x2F;&#x2F; 我爱你！中国！                                        &#x2F;&#x2F; 我的祖国！Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp数组操作</title>
      <link href="/2020/04/10/csharp-shu-zu-cao-zuo/"/>
      <url>/2020/04/10/csharp-shu-zu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>语法：数据类型[] 数组名    /   数组名 = new 数据类型[]</p><pre class="line-numbers language-none"><code class="language-none">int[] a   &#x2F;   a &#x3D; new int[5]&#123;1, 2, 3, 4, 5&#125;   &#x2F;   a &#x3D; new int[5]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string[] week &#x3D; &#123; &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot; &#125;;for(int i &#x3D; 0; i &lt; week.Length; i++)&#123;    Console.WriteLine(week[i]);&#125;Console.ReadLine();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>语法：数据类型[, ]数组名</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[,] b &#x3D; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6 &#125;, &#123; 7, 8, 9 &#125; &#125;;for (int i &#x3D; 0; i &lt; 3; i++)    for (int j &#x3D; 0; j &lt; 3; j++)        Console.WriteLine(&quot;&#123;0&#125;行&#123;1&#125;列元素为&#123;2&#125;&quot;, i, j, b[i, j]);for (int i &#x3D; 0; i &lt; 3; i++)&#123;    for (int j &#x3D; 0; j &lt; 3; j++)    &#123;        Console.Write(&quot;&#123;0,-5&#125;&quot;, b[i, j]); &#x2F;&#x2F; 输出数组元素，每个元素占五格，靠左对齐        &#x2F;**         * 1    2    3        * 4    5    6         * 7    8    9         *&#x2F;    &#125;    Console.WriteLine();&#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="三维数组"><a href="#三维数组" class="headerlink" title="三维数组"></a>三维数组</h4><p>可以把三维数组看做一本记录本，每页都是一个表格，那么，可以使用页号、行号、列号来定位三维数组的一个元素。<br>语法：数据类型[, , ] 数组名</p><h4 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h4><p> 交错数组可以看成是数组的数组，交错数组的每个元素又是一个数组<br> 语法：<br> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[][] &#x3D; new int[3][]&#123;    new int[] &#123; 1, 2, 3 &#125;,    new int[] &#123; 4, 5, 6 &#125;,    new int[] &#123; 7, 8, 9 &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[][] c;c &#x3D; new int[3][];c[0] &#x3D; new int[] &#123; 1, 2, 3 &#125;;c[1] &#x3D; new int[] &#123; 4, 5, 6, 7 &#125;;c[2] &#x3D; new int[] &#123; 8, 9, 10, 11, 12 &#125;;for (int i &#x3D; 0; i &lt; c.Length; i++)&#123;    for (int j &#x3D; 0; j &lt; c[i].Length; j++)    &#123;        Console.Write(&quot;&#123;0, -5&#125;&quot;, c[i][j]);    &#125;    Console.WriteLine();&#125;&#x2F;** * 1    2    3 * 4    5    6    7 * 8    9    10    11    12 *&#x2F;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数组基本操作"><a href="#数组基本操作" class="headerlink" title="数组基本操作"></a>数组基本操作</h3><h4 id="数组排序与反转"><a href="#数组排序与反转" class="headerlink" title="数组排序与反转"></a>数组排序与反转</h4><p>Array类的静态方法Sort()可以实现数组的排序，无返回值。<br>语法：Array.Sort(数组名)</p><p>Array类的静态方法Reverse()可以实现数组的反转，无返回值。<br>语法：Array.Reverse(数组名)</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[] a &#x3D; &#123; 3, 8, 1, 7, 4 &#125;;Array.Sort(a);for (int i &#x3D; 0; i &lt; a.Length; i++)&#123;    Console.Write(&quot;&#123;0, -5&#125;&quot;, a[i]); &#x2F;&#x2F; 1    3    4    7    8&#125;Console.WriteLine();Array.Reverse(a);for (int i &#x3D; 0; i &lt; a.Length; i++)&#123;    Console.Write(&quot;&#123;0, -5&#125;&quot;, a[i]); &#x2F;&#x2F; 8    7    4    3    1&#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="查找数组元素"><a href="#查找数组元素" class="headerlink" title="查找数组元素"></a>查找数组元素</h4><p> Array类的静态方法IndexOf( )可以判断数组是否包含与给定值相等的元素，是则返回对应数组元素的下标，否则返回-1。<br>语法：Array.IndexOf(数组名, 要查找的值)</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[] a &#x3D; &#123; 4, 5, 2, 7, 1 &#125;;Console.WriteLine(Array.IndexOf(a, 4)); &#x2F;&#x2F; 0Console.WriteLine(Array.IndexOf(a, 10)); &#x2F;&#x2F; -1Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>####数组求和，最大值，最小值，平均值<br>Sum(), Max(), Min(), Average()<br>语法：数组名.Sum()</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[] a &#x3D; &#123; 3, 8, 1, 7, 4 &#125;;Console.WriteLine(a.Sum()); &#x2F;&#x2F; 23Console.WriteLine(a.Max()); &#x2F;&#x2F; 8Console.WriteLine(a.Min()); &#x2F;&#x2F; 1Console.WriteLine(a.Average()); &#x2F;&#x2F; 4.6Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组字符串相互转化"><a href="#数组字符串相互转化" class="headerlink" title="数组字符串相互转化"></a>数组字符串相互转化</h4><p> String类的静态方法Join( )可以将数组中所有元素连接起来，生成一个字符串，返回值为该字符串。<br> 语法：String.Join(分隔符, 数组名)  –&gt; Join( )方法分隔符类型为字符串</p><p> 方法Split( )可以根据分隔符将字符串切分为多个部分，每个部分作为一个数组元素生成一个字符串数组，返回值为该字符串数组。<br>语法：字符串变量.Split(分隔符)  –&gt; Split( )方法中的分隔符类型为字符型</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">string[] a &#x3D; &#123; &quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;, &quot;!&quot; &#125;;string b &#x3D; String.Join(&quot; &quot;, a);Console.WriteLine(b);string[] a1 &#x3D; b.Split(&#39; &#39;);for (int i &#x3D; 0; i &lt; a1.Length; i++)&#123;    Console.WriteLine(a1[i]);&#125;Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在字符串中查找、删除字符数组元素"><a href="#在字符串中查找、删除字符数组元素" class="headerlink" title="在字符串中查找、删除字符数组元素"></a>在字符串中查找、删除字符数组元素</h4><p> String类方法IndexOfAny( )用于在字符串中查找给定字符数组中的所有元素，返回字符数组元素在字符串中首次出现的位置值，查找失败则返回-1。<br> 语法：字符串变量.IndexOfAny(字符数组名)</p><p>String类方法LastIndexOfAny( )用于在字符串中查找给定字符数组中的所有元素，返回字符数组元素在字符串中最后出现的位置值，查找失败则返回-1。<br>语法：字符串变量.LastIndexOfAny(字符数组名)</p><p> String类方法Trim( )可以在字符串的首部和尾部去除给定字符数组中的所有元素，返回操作后的字符串。<br> 语法：字符串变量.Trim(字符数组名)</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">char[] a &#x3D; &#123; &#39;a&#39;, &#39;t&#39;, &#39;i&#39; &#125;;string str &#x3D; &quot;This is a test!&quot;;Console.WriteLine(str.IndexOfAny(a)); &#x2F;&#x2F; 2Console.WriteLine(str.LastIndexOfAny(a)); &#x2F;&#x2F; 13char[] b &#x3D; &#123; &#39;T&#39;, &#39;h&#39;, &#39;t&#39; &#125;;Console.WriteLine(str.Trim(b)); &#x2F;&#x2F; is is a test!Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p> 枚举类型用于声明一组命名常数。<br> 语法：enum 枚举类型名 {枚举成员列表}<br>例：enum Week { 星期一, 星期二, 星期三, 星期四, 星期五, 星期六, 星期天 };</p><p> 枚举类型week包含七个常数，默认第一个常数为0，对应“星期一”，每个名称对应的常数都比前边一个加1，最后一个常数为6，对应“星期天”。<br> 相当于为常数起了个名字，把七个常数组合在一起构成枚举类型week。</p><p> enum Week { 星期一 = 1, 星期二, 星期三, 星期四, 星期五, 星期六, 星期天 };<br> 给出第一个名称星期一对应的常数为1，后边的名称对应的常数值分别是2、3、4、5、6、7。<br> <pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 定义枚举类型变量x，选择枚举类型中的一个名称为变量x赋值Week x &#x3D; Week.星期一;&#x2F;&#x2F; 定义枚举类型变量y，将整数2强制转换为week类型的值赋值给变量Week y &#x3D; (Week)2;Console.WriteLine(x.ToString()); &#x2F;&#x2F; 星期一Console.WriteLine(y.ToString()); &#x2F;&#x2F; 星期二Console.WriteLine((Week)2); &#x2F;&#x2F; 输出枚举类型Week中常量2对应的名称 --&gt; 星期二Console.WriteLine((int)Week.星期天); &#x2F;&#x2F; 输出枚举类型Week中名称“星期天”对应的常量  --&gt;  7Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p><ul><li>枚举类型的最大作用是可以自定义一个类型，将许多相关的名称作为一个集合保存和使用，每个名称对应一个整型常量。</li><li>相对于直接使用数值，使用枚举类型可以使代码更加清晰易懂，便于记忆。</li><li>枚举类型的变量只能选择几个常量中的一个，方便控制变量取值范围，保证程序的执行过程安全可靠。</li><li>常量值和枚举值之间转换方便，使用枚举类型使代码更容易编写和维护。<h4 id="字符串与字符数组相互转化"><a href="#字符串与字符数组相互转化" class="headerlink" title="字符串与字符数组相互转化"></a>字符串与字符数组相互转化</h4>使用语句“string str = new string(‘a’,5);”创建包含5个相同字符的字符串str，str对应的字符串为“aaaaa”。<br>事实上，我们可以使用任意一个字符类型数组初始化一个字符串。<br>反之，一个字符串可以直接作为一个字符类型数组使用，直接在字符串名后面加上下标即可<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">char[] c &#x3D; &#123; &#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;W&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;, &#39;！&#39; &#125;;string str &#x3D; new string(c);Console.WriteLine(str); &#x2F;&#x2F; Hello World!Console.WriteLine(str[0]); &#x2F;&#x2F; HConsole.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="foreach遍历二维数组"><a href="#foreach遍历二维数组" class="headerlink" title="foreach遍历二维数组"></a>foreach遍历二维数组</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int[,] a &#x3D; &#123; &#123; 1, 2, 3 &#125;, &#123; 4, 5, 6&#125;, &#123; 7, 8, 9&#125; &#125;;foreach (int x in a)    Console.Write(&quot;&#123;0, -4&#125;&quot;, x);Console.ReadKey(); &#x2F;&#x2F; 1   2   3  4   5   6   7   8   9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>使用foreach循环遍历二维数组，访问数组元素的顺序是先行后列，因此输出结果为123456。</li><li>如果需要按照先列后行遍历数组元素的话，需要使用嵌套的for循环。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#类与对象</title>
      <link href="/2020/04/10/csharp-lei-yu-dui-xiang/"/>
      <url>/2020/04/10/csharp-lei-yu-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h4 id="C-类的修饰符"><a href="#C-类的修饰符" class="headerlink" title="C#类的修饰符"></a>C#类的修饰符</h4><ul><li>Public：公有的, 是类型和类型成员的访问修饰符。对其访问不受任何限制。</li><li>Private：私有的,私有成员只有在声明它们的类和结构体中才是可访问的。</li><li>Protected：保护成员，该类内部和继承类中可以访问。 </li><li>internal：内部访问,同一个程序集中的所有类都可以访问,一般都是限于本项目内。</li><li>Protected internal：受内部保护的,只限于本项目或是子类访问，其他不能访问。 </li></ul><p>一个类[包括接口，结构体，枚举，委托]上可以使用的访问修饰符有：public, internal默认的值是internal。<br>内部成员的默认级别</p><ul><li>class: private     enum: public    </li><li>interface(接口): public    struct: private</li></ul><h5 id="对象与类知识练习代码："><a href="#对象与类知识练习代码：" class="headerlink" title="对象与类知识练习代码："></a>对象与类知识练习代码：</h5><p>phone类文件，phone.cs</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public const string PhoneType &#x3D; &quot;GSM&quot;; &#x2F;&#x2F; 声明常量，隐式静态        public static string emergency_Call &#x3D; &quot;119&quot;;        private string phoneNumber; &#x2F;&#x2F; 定义私有字段表示电话号码        public string PhoneNumber &#x2F;&#x2F; 定义公有属性，设置和获取phoneNumber的值        &#123;            get &#123; return phoneNumber; &#125;            set &#123; phoneNumber &#x3D; value; &#125;        &#125;        public void Dial() &#x2F;&#x2F; 无参数方法成员，表示电话具有拨打功能        &#123;            Console.WriteLine(&quot;您正在拨打电话！&quot;);        &#125;        public void DialNumber(string number) &#x2F;&#x2F; 有参数方法成员，表示拨打具体电话号码        &#123;            Console.WriteLine(&quot;您正在拨打&quot; + number);        &#125;        public static void EmergencyCall() &#x2F;&#x2F; 静态方法EmergencyCall        &#123;            Console.WriteLine(&quot;您正在拨打急救电话119！&quot;);        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h5><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Phone.EmergencyCall(); &#x2F;&#x2F; 您正在拨打急救电话119！Console.WriteLine(Phone.emergency_Call); &#x2F;&#x2F; 119Phone objPhone &#x3D; new Phone&#123;    PhoneNumber &#x3D; &quot;123456&quot;&#125;;Console.WriteLine(&quot;电话号码是&quot; + objPhone.PhoneNumber); &#x2F;&#x2F; 电话号码是123456objPhone.Dial(); &#x2F;&#x2F; 您正在拨打电话！objPhone.DialNumber(&quot;404404&quot;); &#x2F;&#x2F; 您正在拨打404404Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>实例中定义了常量PhoneType、静态字段emergency_Call和静态方法EmergencyCall，对这些静态成员的使用方法是“类名.静态成员名”，不需要实例化；</li><li>类中还定义了如下实例成员：phoneNumber、有参数的Dial方法和无参数的Dial方法，使用的时候先要创建对象，以“对象名.实例成员名”的方式调用。</li></ul><h4 id="面向对象思想理解（OOP-Object-Oriented-Programming）"><a href="#面向对象思想理解（OOP-Object-Oriented-Programming）" class="headerlink" title="面向对象思想理解（OOP-Object Oriented Programming）"></a>面向对象思想理解（OOP-Object Oriented Programming）</h4><ul><li>万物皆为对象</li><li>程序是对象的集合，通过发送消息完成程序工作</li><li>每一个对象在内存中都有一个唯一的地址</li><li>对象是类的实例，类是对象的模板。</li></ul><h4 id="new-一个对象"><a href="#new-一个对象" class="headerlink" title="new 一个对象"></a>new 一个对象</h4><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Phone objPhone &#x3D; new Phone()&#123;PhoneNumber &#x3D; &quot;12345&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Phone objPhone &#x3D; new Phone&#123;PhoneNumber &#x3D; &quot;12345&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h6 id="加括号与不加的区别"><a href="#加括号与不加的区别" class="headerlink" title="加括号与不加的区别"></a>加括号与不加的区别</h6><p>（1）加括号</p><ul><li><p>若括号为空，即无实参项，那么理解为调用默认构造函数；</p></li><li><p>若括号非空，即有实参项，可以理解为调用重载构造函数，或复合默认构造函数。</p></li></ul><p>（2）不加括号</p><p>调用默认构造函数，或复合默认构造函数。</p><h6 id="默认构造函数-与-复合默认构造函数的区别"><a href="#默认构造函数-与-复合默认构造函数的区别" class="headerlink" title="默认构造函数 与 复合默认构造函数的区别"></a>默认构造函数 与 复合默认构造函数的区别</h6><ul><li><p>默认构造函数：编译器会为每一个类默认提供一个构造函数，称之为默认构造函数。默认构造函数一般参数为空。</p></li><li><p>复合默认构造函数：一个由用户自定义的所有形式参数都赋有默认值的构造函数，称之为复合默认构造函数。</p></li></ul><p>两者联系：</p><ul><li><p>一个类中，若一旦有一个用户自定义构造函数，那么由编译器提供的默认构造函数就不再存在。用户自定义的构造函数为默认构造函数的重载版。</p></li><li><p>默认构造函数不复存在时，用户必须为这个类再自定义一个复合默认构造函数（选所有自定义构造函数其中之一，把形式参数均赋默认值即可）。</p></li></ul><p>不论自定义构造函数（即构造函数的重载版）有多少个，只允许有一个复合默认构造函数。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#类与对象2</title>
      <link href="/2020/04/10/csharp-lei-yu-dui-xiang-2/"/>
      <url>/2020/04/10/csharp-lei-yu-dui-xiang-2/</url>
      
        <content type="html"><![CDATA[<h4 id="构造函数与析构函数"><a href="#构造函数与析构函数" class="headerlink" title="构造函数与析构函数"></a>构造函数与析构函数</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><ul><li>构造函数是类的特殊方法成员，其名称和类名相同，主要用来完成对象的初始化。</li><li>C#通过new创建对象的过程实际上就是调用类的构造函数的过程，创建对象时调用构造函数对对象进行初始化。</li><li>每个类都有构造函数，如果没有定义，系统也会提供一个默认的构造函数，默认的构造函数一般不进行什么操作。</li><li>在访问一个类的时候，系统最先执行构造函数中的语句。</li><li>声明的构造函数是非静态的实例构造函数。构造函数也有静态的，静态构造函数用于初始化类中的静态字段成员。 <h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5></li><li>析构函数是对象销毁前释放所占用系统资源的类的成员。</li><li>析构函数的名字是在类名前面加一个符号“～”。析构函数不接受任何参数，也不返回任何值。</li><li>一个类只能有一个析构函数，析构函数不能手动调用，是系统自动调用的。<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Point&#123;          public int X &#123; get; set; &#125; &#x2F;&#x2F; 定义属性X，得到和设置点的横坐标     public int Y &#123; get; set; &#125; &#x2F;&#x2F; 定义属性Y，得到和设置点的纵坐标     public static int z;     static Point() &#x2F;&#x2F; 定义静态构造函数     &#123;         z &#x3D; 100;     &#125;     public Point() &#x2F;&#x2F; 无参构造函数用于初始化     &#123;         X &#x3D; 0; Y &#x3D; 2; &#x2F;&#x2F; 初始化     &#125;     public Point(int val_x, int val_y) &#x2F;&#x2F; 有参数构造函数     &#123;         X &#x3D; val_x; Y &#x3D; val_y; &#x2F;&#x2F; 用指定的参数初始化X和Y     &#125;     ~Point() &#x2F;&#x2F; 析构函数     &#123;         Console.WriteLine(&quot;析构函数主要用于清理资源！&quot;);         Console.ReadKey();     &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>Main方法测试代码<pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Console.WriteLine(&quot;静态构造函数：&quot; + Point.z); &#x2F;&#x2F; 静态构造函数：100Point objPoint1 &#x3D; new Point();Console.WriteLine(&quot;无参构造函数演示&quot;);Console.WriteLine(&quot;X &#x3D; &quot; + objPoint1.X); &#x2F;&#x2F; X &#x3D; 0Console.WriteLine(&quot;Y &#x3D; &quot; + objPoint1.Y); &#x2F;&#x2F; Y &#x3D; 2Point objPoint2 &#x3D; new Point(80, 90);Console.WriteLine(&quot;有参构造函数演示&quot;);Console.WriteLine(&quot;X &#x3D; &quot; + objPoint2.X); &#x2F;&#x2F; X &#x3D; 80Console.WriteLine(&quot;Y &#x3D; &quot; + objPoint2.Y); &#x2F;&#x2F; Y &#x3D; 90Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5></li><li>C#定义方法时声明的参数称为形参（或称虚拟参数）,调用方法时传给形参的值称为实参。</li><li>参数传递类型有值传递与引用传递两种。值传递是C#默认的传递方式。</li><li>如果希望所调用的方法能更改实在参数的值，则必须使用ref或out关键字声明通过引用传递方式传递参数。</li><li>引用传递是把实在参数的地址传给形式参数，形式参数和实在参数指向同一个存储单元，对形式参数的改变就是对实在参数的改变。</li><li>out传递与ref类似，二者的区别是，ref要求参数在传递之前必须初始化，out则不要求初始化。</li></ul><h6 id="值传递示例"><a href="#值传递示例" class="headerlink" title="值传递示例"></a>值传递示例</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 定义值传递方法private void Swap(int num1, int num2) &#x2F;&#x2F; 交换数据的方法&#123;    int temp; &#x2F;&#x2F; 定义用于交换变量值得中间变量    temp &#x3D; num1; &#x2F;&#x2F; 将num1值赋值给中间变量temp    num1 &#x3D; num2; &#x2F;&#x2F; 将num2赋值给num1    num2 &#x3D; temp; &#x2F;&#x2F; 将中间变量存储的num1的值赋值给num2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int num1 &#x3D; 1;int num2 &#x3D; 2;Console.WriteLine(&quot;此实例演示值传递参数&quot;);Console.WriteLine(&quot;交换之前的字符串顺序为：num1-&#123;0&#125;, num2-&#123;1&#125;&quot;, num1, num2); &#x2F;&#x2F; 1   2Program objProgram &#x3D; new Program();objProgram.Swap(num1, num2);Console.WriteLine(&quot;交换之后的字符串顺序为：num1-&#123;0&#125;, num2-&#123;1&#125;&quot;, num1, num2); &#x2F;&#x2F; 1   2Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果显示并没有真正交换num1和num2两个变量的值，因为选择的是值传递的方法来传递参数。</p><h6 id="ref引用传递示例"><a href="#ref引用传递示例" class="headerlink" title="ref引用传递示例"></a>ref引用传递示例</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 定义引用传递方法private void Swap(ref int num1, ref int num2) &#x2F;&#x2F; 交换数据的方法&#123;    int temp; &#x2F;&#x2F; 定义用于交换变量值得中间变量    temp &#x3D; num1; &#x2F;&#x2F; 将num1值赋值给中间变量temp    num1 &#x3D; num2; &#x2F;&#x2F; 将num2赋值给num1    num2 &#x3D; temp; &#x2F;&#x2F; 将中间变量存储的num1的值赋值给num2&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">int num1 &#x3D; 1;int num2 &#x3D; 2;Console.WriteLine(&quot;此实例演示引用传递参数&quot;);Console.WriteLine(&quot;交换之前的字符串顺序为：num1-&#123;0&#125;, num2-&#123;1&#125;&quot;, num1, num2); &#x2F;&#x2F; 1   2Program objProgram &#x3D; new Program();objProgram.Swap(ref num1, ref num2);Console.WriteLine(&quot;交换之后的字符串顺序为：num1-&#123;0&#125;, num2-&#123;1&#125;&quot;, num1, num2); &#x2F;&#x2F; 2   1Console.ReadKey();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ref引用传递交换了两个变量的值，在使用ref方式传递参数时，定义和调用时都要使用ref关键字。</p><h6 id="out引用传递"><a href="#out引用传递" class="headerlink" title="out引用传递"></a>out引用传递</h6><ul><li>out关键字与ref关键字类似，也是声明引用传递参数的，但ref要求变量必须在传递之前对实在参数初始化。</li><li>尽管作为out参数传递的变量不需要在传递之前初始化，但需要调用方法在方法返回之前对out传递的参数赋值。</li><li>当希望方法返回多个值时，可以使用out方式，使用out参数的方法可以将变量用做返回类型，还可以将一个或多个对象作为out参数返回给调用方法。</li></ul><p>下面的例子使用out在一个方法调用中返回3个值。请注意，第3个参数所赋的值为null，这样能允许方法有选择地返回值。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">namespace PointClass&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            int value;            string str1, str2;            Console.WriteLine(&quot;此实例演示out引用传递&quot;);            Method(out int value, out string str1, out string str2);            Console.WriteLine(&quot;参数value的值是：&quot; + value); &#x2F;&#x2F; 参数value的值是：44            Console.WriteLine(&quot;参数str1的值是：&quot; + str1); &#x2F;&#x2F; 参数str1的值是：I&#39;ve been returned!            Console.WriteLine(&quot;参数str2的值是：&quot; + str2); &#x2F;&#x2F; 参数str2的值是：            Console.ReadKey();        &#125;        static void Method(out int i, out string s1, out string s2) &#x2F;&#x2F; 定义静态方法使用out进行参数的传递        &#123;            i &#x3D; 44;            s1 &#x3D; &quot;I&#39;ve been returned!&quot;;            s2 &#x3D; null;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#结构与类</title>
      <link href="/2020/04/10/csharp-jie-gou-yu-lei/"/>
      <url>/2020/04/10/csharp-jie-gou-yu-lei/</url>
      
        <content type="html"><![CDATA[<h4 id="结构与类"><a href="#结构与类" class="headerlink" title="结构与类"></a>结构与类</h4><ul><li>结构和类相似，通常用来封装小型的相关变量组。</li><li>结构是一种值类型，通常创建结构要比创建类的速度快。如果需要一些紧凑循环，需要在其中创建大量的新数据结构，则应考虑使用结构而不是类。</li><li>在C#中，可以将结构看成轻量级的类。定义结构和定义类相似，采用struct进行定义，每个struct类型数据可以是常量、变量、构造函数、方法和属性等成员。</li></ul><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">&lt;访问修饰符&gt; struct结构名&#123;    &#x2F;&#x2F; 结构体定义&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用：通过声明结构体变量或使用new来实例化结构对象，然后通过“结构体变量.结构成员名”或“结构对象.结构成员”的方式来使用结构。</strong></p><h6 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace StructTest&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Student goodStu; &#x2F;&#x2F; 创建结构goodStu表示好学生            goodStu.stuNum &#x3D; &quot;20200409&quot;;            goodStu.stuName &#x3D; &quot;小明&quot;;            goodStu.stuAge &#x3D; 19;            goodStu.stuClass &#x3D; 1;            goodStu.stuGrade &#x3D; 100;            Console.WriteLine(&quot;结构演示：&quot;);            Console.WriteLine(&quot;三好学生：学号-&#123;0&#125;，姓名-&#123;1&#125;，年龄-&#123;2&#125;，班级-&#123;3&#125;，成绩-&#123;4&#125;&quot;, goodStu.stuNum, goodStu.stuName, goodStu.stuAge, goodStu.stuClass, goodStu.stuGrade);            goodStu.DoHomeWork(); &#x2F;&#x2F; 调用结构的方法            Console.ReadKey();            &#x2F;**             * 三好学生：学号-20200409，姓名-小明，年龄-19，班级-1，成绩-100             * I&#39;m doing homework!             *&#x2F;            Student normalStu &#x3D; new Student(&quot;20200410&quot;, &quot;小红&quot;, 19, 1, 80);            Console.WriteLine(&quot;普通学生：学号-&#123;0&#125;，姓名-&#123;1&#125;，年龄-&#123;2&#125;，班级-&#123;3&#125;，成绩-&#123;4&#125;&quot;, normalStu.stuNum, normalStu.stuName, normalStu.stuAge, normalStu.stuClass, normalStu.stuGrade);            normalStu.DoHomeWork();            Console.ReadKey();            &#x2F;**             * 普通学生：学号-20200410，姓名-小红，年龄-19，班级-1，成绩-80             * I&#39;m doing homework!             *&#x2F;        &#125;    &#125;    struct Student    &#123;        public string stuNum; &#x2F;&#x2F; 学号        public string stuName; &#x2F;&#x2F; 姓名        public int stuAge; &#x2F;&#x2F; 年龄        public int stuClass; &#x2F;&#x2F; 班级        public int stuGrade; &#x2F;&#x2F; 成绩        public Student(string stuNum, string stuName, int stuAge, int stuClass, int stuGrade) &#x2F;&#x2F; 结构的构造函数，用参数给结构中的成员赋值        &#123;            this.stuNum &#x3D; stuNum;            this.stuName &#x3D; stuName;            this.stuAge &#x3D; stuAge;            this.stuClass &#x3D; stuClass;            this.stuGrade &#x3D; stuGrade;        &#125;        public void DoHomeWork() &#x2F;&#x2F; 结构中的方法        &#123;            Console.WriteLine(&quot;I&#39;m doing homework!&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="结构与类的关系"><a href="#结构与类的关系" class="headerlink" title="结构与类的关系"></a>结构与类的关系</h5><p>类和结构实际上都是创建对象的模板，都可以包含构造函数、常数、字段、方法、属性、索引器和运算符等成员。</p><ul><li>结构是值类型，类是引用类型，在内存中结构是存储在栈上的值类型，类是存储在堆(heap)上的引用类型。</li><li>结构的构造函数和类的构造函数不同，结构不能包含显式的无参数构造函数，结构成员会自动初始化为它们的默认值。结构不能包含以下形式的初始值设定类：base（参数列表）。</li><li>对于结构中的实例字段成员，不能在声明时赋值初始化。</li><li>声明了结构类型后，可以使用new运算符创建构造对象，也可以不使用new关键字。如果不使用new，那么在初始化所有字段之前，字段将保持未赋值状态且对象不可用。</li><li>结构不支持继承，即一个结构不能从另一个结构或类继承，而且不能作为一个类的基类。</li></ul><h5 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h5><p>在大型项目、特殊部署时，可能需要把一个类、结构或接口放在几个文件中来处理。等到编译时，自动地把它们组合起来，成为一个完整的类，这是C# 分部类。</p><ul><li>类型特别大，不宜放在一个文件中实现。</li><li> 一个类型中的一部分代码为自动化工具生成的代码，不宜与自己编写的代码混合在一起。</li><li>需要多人合作编写一个类。</li></ul><p><strong>分部类是一个纯语言层的编译处理，不影响任何执行机制。<br>事实上C#编译器在编译的时候仍会将各个部分的局部类型合并成一个完整的类。C# 分部类是在class前面添加关键字partial来定义。</strong></p><p><strong>分部类中还可以声明分部方法，分部方法是将方法的定义和实现分隔开。在方法前面用partial关键字修饰的方法就是分部方法。</strong><br>例如，在一个文件中声明分部类Person的代码如下： </p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial class Person &#x2F;&#x2F; 分部类Person的部分代码&#123;public void DoWork()&#123;&#x2F;&#x2F; 定义方法，表示Person类的工作功能&#125;partial void Drink(); &#x2F;&#x2F; 定义分部方法，表示Person类的喝水功能&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在另一个文件中声明分部类Person</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public partial class Person &#x2F;&#x2F; 分部类Person的部分代码&#123;public void HaveDinner()&#123;&#x2F;&#x2F; 定义方法，表示Person类的吃晚饭功能&#125;partial void Drink()&#123;&#x2F;&#x2F; 实现分部方法代码&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分部方法隐式为private类型，不可使用public访问修饰符。分部方法不可有返回值。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#继承</title>
      <link href="/2020/04/10/csharp-ji-cheng/"/>
      <url>/2020/04/10/csharp-ji-cheng/</url>
      
        <content type="html"><![CDATA[<h5 id="继承的定义与使用"><a href="#继承的定义与使用" class="headerlink" title="继承的定义与使用"></a>继承的定义与使用</h5><p>继承是软件复用的一种形式。使用继承可以复用现有类的数据和行为，为其赋予新功能而创建出新类。复用能节省程序开发的时间，能重用经过实践检验和调试的高质量代码，提高系统的质量。</p><p>在现有类（称为直接基类、父类）上建立新类（称为派生类、子类）的处理过程称为继承。<br>派生类能自动获得基类的除了构造函数和析构函数以外的所有成员，可以在派生类中添加新的属性和方法扩展其功能。</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 语法：&lt;访问修饰符&gt; class派生类名: 基类名&#123;&#x2F;&#x2F; 类的代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Person-cs（Person类）"><a href="#Person-cs（Person类）" class="headerlink" title="Person.cs（Person类）"></a>Person.cs（Person类）</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace InheritDemo&#123;    public class Person    &#123;        private string _id; &#x2F;&#x2F; 声明身份证号码字段 _id        public string Id &#x2F;&#x2F; 声明身份证号码属性ID        &#123;            get &#123; return _id; &#125; &#x2F;&#x2F; get访问器，获取身份证号码字段值            set &#123; _id &#x3D; value; &#125; &#x2F;&#x2F; set访问器，设置身份证号码字段值        &#125;        private string _name; &#x2F;&#x2F; 声明姓名字段        public string Name &#x2F;&#x2F; 声明姓名属性        &#123;            get &#123; return _name; &#125; &#x2F;&#x2F; get访问器，获取姓名字段值            set &#123; _name &#x3D; value; &#125; &#x2F;&#x2F; set访问器，设置身份证号码字段值        &#125;        private int _age; &#x2F;&#x2F; 声明年龄字段        public int Age &#x2F;&#x2F; 声明年龄属性        &#123;            get &#123; return _age; &#125;            set &#123; _age &#x3D; value; &#125;        &#125;        private string _gender; &#x2F;&#x2F; 声明性别字段        public string Gender &#x2F;&#x2F; 声明性别属性        &#123;            get &#123; return _gender; &#125;            set &#123; _gender &#x3D; value; &#125;        &#125;        public void Display() &#x2F;&#x2F; 基类的公有方法，用于输出Person对象的姓名、年龄与性别信息        &#123;            Console.WriteLine(&quot;&#123;0&#125;是&#123;1&#125;性，年龄为&#123;2&#125;&quot;, this._name, this._gender, this._age);        &#125;        public Person() &#x2F;&#x2F; 定义无参构造函数        &#123; &#125;        public Person(string name, int age, string gender) &#x2F;&#x2F; 定义有参构造函数        &#123;            _name &#x3D; name;            _age &#x3D; age;            _gender &#x3D; gender;        &#125;    &#125;    public class Student: Person&#x2F;&#x2F; 创建派生类，派生自Person类    &#123;        &#x2F;&#x2F; 定义派生类自己的属性        private string _class; &#x2F;&#x2F; 定义表示学生班级的字段_class        public string Class &#x2F;&#x2F; 定义设置和获取班级信息的属性Class        &#123;            get &#123; return _class; &#125;            set &#123; _class &#x3D; value; &#125;        &#125;        private string _department; &#x2F;&#x2F; 定义学生所属系的字段        public string Deparement &#x2F;&#x2F; 定义学生所属系的属性        &#123;            get &#123; return _department; &#125;            set &#123; _department &#x3D; value; &#125;        &#125;        private string _no; &#x2F;&#x2F; 定义学生学号        public string NO &#x2F;&#x2F; 定义学号的属性        &#123;            get &#123; return _no; &#125;            set &#123; _no &#x3D; value; &#125;        &#125;        public Student() &#x2F;&#x2F; 无参构造函数        &#123; &#125;        &#x2F;&#x2F; 定义派生类独有的方法Study，表示学生负有学习任务        public void Study()        &#123;            Console.WriteLine(&quot;好好学习，天天向上！&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Teacher-cs（Teacher类）"><a href="#Teacher-cs（Teacher类）" class="headerlink" title="Teacher.cs（Teacher类）"></a>Teacher.cs（Teacher类）</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace InheritDemo&#123;    class Teacher: Person    &#123;        private string _tid; &#x2F;&#x2F; 声明字段教师编号        public string Tid &#x2F;&#x2F; 定义教师编号属性        &#123;            get &#123; return _tid; &#125;            set &#123; _tid &#x3D; value; &#125;        &#125;        private string _course; &#x2F;&#x2F; 声明课程字段        public string Course &#x2F;&#x2F; 定义课程属性        &#123;            get &#123; return _course; &#125;            set &#123; _course &#x3D; value; &#125;        &#125;        &#x2F;&#x2F; 教师派生类的方法        public void Teaching()        &#123;            Console.WriteLine(&quot;正在上课中...&quot;);        &#125;    &#125;    class DoubleStudent: Student    &#123;        private string _sndBachelor; &#x2F;&#x2F; 声明第二学位名称字段        public string SndBachelor &#x2F;&#x2F; 声明第二学位属性        &#123;            get &#123; return _sndBachelor; &#125;            set &#123; _sndBachelor &#x3D; value; &#125;        &#125;        public DoubleStudent() &#x2F;&#x2F; 无参构造函数        &#123; &#125;        public void UsaBachelor() &#x2F;&#x2F; 定义方法        &#123;            Console.WriteLine(&quot;正在攻读xxx大学学位&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="Program-cs"><a href="#Program-cs" class="headerlink" title="Program.cs"></a>Program.cs</h6><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">using System;using System.Collections.Generic;using System.Linq;using System.Text;using System.Threading.Tasks;namespace InheritDemo&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            Console.WriteLine(&quot;Person类：&quot;);            Person objPerson &#x3D; new Person(&quot;张三&quot;, 18, &quot;男&quot;);            objPerson.Display(); &#x2F;&#x2F; 调用Display显式对象信息     --&gt;     张三是男性，年龄为18            Console.WriteLine(&quot;Student类：&quot;);            Student objStudent &#x3D; new Student()            &#123;                Name &#x3D; &quot;李四&quot;,                Age &#x3D; 18,                Gender &#x3D; &quot;女&quot;            &#125;;            objStudent.Display(); &#x2F;&#x2F; 访问基类的Display方法     --&gt;     李四是女性，年龄为18            objStudent.Study(); &#x2F;&#x2F; 调用派生类方法      --&gt;     好好学习，天天向上！            Console.ReadKey();            Console.WriteLine(&quot;Teacher类&quot;);            Teacher objTeacher &#x3D; new Teacher()            &#123;                Name &#x3D; &quot;Mary&quot;,                Age &#x3D; 26,                Gender &#x3D; &quot;女&quot;            &#125;;            objTeacher.Display(); &#x2F;&#x2F; 访问基类的Display方法            objTeacher.Teaching(); &#x2F;&#x2F; 访问Teacher类的方法            Console.WriteLine(&quot;DoubleStudent类&quot;);            DoubleStudent objSpecial &#x3D; new DoubleStudent()            &#123;                Name &#x3D; &quot;Bliss&quot;,                Age &#x3D; 22,                Gender &#x3D; &quot;女&quot;            &#125;;            objSpecial.Display(); &#x2F;&#x2F; 访问Person类方法            objSpecial.Study(); &#x2F;&#x2F; 访问Student类方法            objSpecial.UsaBachelor(); &#x2F;&#x2F; 调用DoubleStudent类方法            Console.ReadKey();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h6><p>C#中的继承主要有以下3种特性：</p><ul><li>继承的可传递性<br>如果C从B中派生，B又从A中派生，那么C不仅继承了B中声明的成员，同样也继承了A中的成员。<br>如示例代码中DoubleStudent类的基类是Student，Student的基类是Person，因此DoubleStudent类可以继承Person类中的成员。<br>派生类是对基类的扩展，在派生类中可以添加新成员，但不能去除已经继承的成员。</li><li>继承的单一性<br>继承的单一性是指派生类只能从一个基类中继承，不能同时继承多个基类。C#不支持类的多重继承，也就是说儿子只能有一个亲生父亲，不能同时拥有多个亲生父亲。但可以通过接口实现多重继承。（具体后续学习研究）</li><li>继承中的访问修饰符</li></ul><table><thead><tr><th align="center">访问性修饰符</th><th align="center">类内部</th><th align="center">派生类</th></tr></thead><tbody><tr><td align="center">public（公有访问）</td><td align="center">访问不受限制</td><td align="center">不受限制</td></tr><tr><td align="center">protected（保护访问）</td><td align="center">访问仅限于包含类或从包含类派生的类型（本类成员和子类可以访问，实例不能访问）</td><td align="center">可以访问</td></tr><tr><td align="center">internal（内部访问）</td><td align="center">访问仅限于当前项目</td><td align="center">可以访问</td></tr><tr><td align="center">protected internal（内部保护访问）</td><td align="center">访问从包含类派生的当前项目或类型（仅限于本项目或子类）</td><td align="center">可以访问</td></tr><tr><td align="center">private（私有访问）</td><td align="center">访问仅限于包含类型（仅限于本类成员，子类、实例都不能访问）</td><td align="center">不可访问</td></tr></tbody></table><h5 id="this和base关键字"><a href="#this和base关键字" class="headerlink" title="this和base关键字"></a>this和base关键字</h5><p>基类中只有被public、protected、internal修饰的成员才可以被访问，这些成员包括任何基类的字段、属性、方法和索引器，但是基类的构造函数和析构函数是不能被继承的。如果要继承基类的构造函数，必须使用base关键字来实现。</p><p>C#中的base关键字代表基类，使用base关键字可以调用基类的构造函数、属性和方法。<br><strong>语法：派生类构造函数: base(参数列表)</strong></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 给上述示例Student类添加一个有参构造函数public Student(string name, int age, string gender):base(name, age, gender) &#x2F;&#x2F; 构造函数&#123;&#x2F;&#x2F; 通过base(name, age, gender)调用基类的构造函数&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">&#x2F;&#x2F; 使用base关键字调用基类方法语法base: 基类方法&#x2F;&#x2F; 示例:public Student(string name, int age, string gender) : base(name, age, gender) &#x2F;&#x2F; 调用基类的构造函数&#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相对于base来说，this关键字是引用类的当前实例。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">public Person(string name, int age, string gender) &#x2F;&#x2F; 构造函数&#123;this._name &#x3D; name;this._age &#x3D; age;this._gender &#x3D; gender;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>派生类继承基类的属性和方法，从而使创建派生类变得简单，可实现代码的重用。</p><p><strong>基类对象可以引用派生类对象，也就是派生类对象可以赋值给基类对象变量。</strong><br>对这个特性可以这样理解：儿子继承于父亲，父亲也可以代表儿子处理事务，这就实现了基类对象引用派生类对象。</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">class Father()&#123;...&#125;class Son: Father&#123;...Public void CallDaddy() &#x2F;&#x2F; 派生类方法&#123;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">Son objSon &#x3D; new Son();Father objFather &#x3D; new Father();objFather &#x3D; objSon; &#x2F;&#x2F; 派生类对象objSon赋值给基类对象 objFather ((Son)objFather).CallDaddy(); &#x2F;&#x2F; 基类对象调用派生类的方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>父类对象引用子类实例时，注意要把父类型转为子类型，否则就会出错。</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C#基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
